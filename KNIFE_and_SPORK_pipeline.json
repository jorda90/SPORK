{
  "class": "Workflow",
  "steps": [
    {
      "id": "#MACHETE_RegIndels_ClassIDFile",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "revision 9 copied",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520439045,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 9 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520439070,
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "baseCommand": [
          "python",
          "RegIndels_ClassIDFile.py"
        ],
        "outputs": [
          {
            "id": "#temp_output_RegIndel",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*temp_output_RegIndel.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n"
                }
              }
            }
          },
          {
            "id": "#output_RegIndel",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*__output_RegIndel.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n"
                }
              }
            }
          },
          {
            "id": "#all_regindels_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "outputBinding": {
              "glob": "All*.sam",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n"
                }
              }
            }
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1520439070,
        "id": "milos_jordanski/spachete-salzman-collaboration/regindels-classidfile/1",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 1,
        "temporaryFailCodes": [],
        "sbg:revision": 1,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520439045,
        "x": 5916.355211788617,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 16:12:27 2015\n\n@author: Gillian\n\"\"\"\n# takes alignments from Indels and finds read partner.\n# all Far Junction and Scrambled junction reads where the alignment does not overlap the\n# Junction by args.window bp will be thrown out.\n\n\n################\n# Current categories\n# linear -- genomeGood, RegGood, JuncGood, RegIndelGood\n# anomaly -- genomeBad, RegBad, JuncBad, RegIndelBad\n##################\n\n\n\nimport argparse\nimport os\nimport glob\n\n\ndef AddToDict(inputtype, line_raw_comparison, line_raw_RI):\n    lineRI = ReadInfoRI(line_raw_RI)\n\n    if inputtype == \"RI\":  # if comparing Far Junc to Far Junc, they have to be identical\n        line2 = ReadInfoRI(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineRI.offset) + \"\\t\" + str(lineRI.MAPQ) + \"\\t\" + str(\n            lineRI.adjAS) + \"\\t\" + lineRI.NumN + \"\\t\" + str(lineRI.NumOfBases) + \"\\t\" + lineRI.junction[\n                                                                                        :-5] + \"\\t\" + lineRI.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if lineRI.junction == line2.junction and lineRI.refstrand in [\"0\", \"16\"] and line2.refstrand in [\"0\",\n                                                                                                         \"16\"] and lineRI.refstrand != line2.refstrand:\n            IDfiletype = \"linear,RegIndelGood,\" + lineRI.junction[-4:]\n        else:\n            IDfiletype = \"anomaly,RegIndelBad,\" + lineRI.junction[-4:]\n\n        IDfile.write(\n            line_raw_RI.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"reg\":\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineRI.offset) + \"\\t\" + str(lineRI.MAPQ) + \"\\t\" + str(\n            lineRI.adjAS) + \"\\t\" + lineRI.NumN + \"\\t\" + str(lineRI.NumOfBases) + \"\\t\" + lineRI.junction[\n                                                                                        :-5] + \"\\t\" + lineRI.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"linear,RegGood,\" + lineRI.junction[-4:]\n\n        if lineRI.chr == line2.chr and lineRI.refstrand != line2.refstrand and lineRI.strand == line2.strand:\n            if lineRI.strand == \"+\":\n                if line2.loc_right < lineRI.loc_left or line2.loc_left > lineRI.loc_right:\n                    pass\n                else:\n                    IDfiletype = \"anomaly,RegBad,\" + lineRI.junction[-4:]\n            elif lineRI.strand == \"-\":\n                if line2.loc_right > lineRI.loc_left or line2.loc_left < lineRI.loc_right:\n                    pass\n                else:\n                    IDfiletype = \"anomaly,RegBad,\" + lineRI.junction[-4:]\n        else:\n            IDfiletype = \"anomaly,RegBad,\" + lineRI.junction[-4:]\n\n        IDfile.write(\n            line_raw_RI.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"junc\":  # if reg or junc read, then one side has to be within 100KB, and meets refstrand criteria below\n\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineRI.offset) + \"\\t\" + str(lineRI.MAPQ) + \"\\t\" + str(\n            lineRI.adjAS) + \"\\t\" + lineRI.NumN + \"\\t\" + str(lineRI.NumOfBases) + \"\\t\" + lineRI.junction[\n                                                                                        :-5] + \"\\t\" + lineRI.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"linear,JuncGood,\" + lineRI.junction[-4:]\n\n        if lineRI.chr == line2.chr and lineRI.refstrand != line2.refstrand and lineRI.strand == line2.strand and min(\n                line2.loc_left, line2.loc_right) < lineRI.loc_left and min(line2.loc_left,\n                                                                           line2.loc_right) < lineRI.loc_right and max(\n                line2.loc_left, line2.loc_right) > lineRI.loc_left and max(line2.loc_left,\n                                                                           line2.loc_right) > lineRI.loc_right:\n            pass\n        else:\n            IDfiletype = \"anomaly,JuncBad,\" + lineRI.junction[-4:]\n\n        IDfile.write(\n            line_raw_RI.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"genome\":  # comparing FJ to genome, has to be within 100Kbp, meet ref strand criteria (opp refstrand if + read, same refstrand if - read)\n\n        line2 = ReadInfoGenome(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineRI.offset) + \"\\t\" + str(lineRI.MAPQ) + \"\\t\" + str(\n            lineRI.adjAS) + \"\\t\" + lineRI.NumN + \"\\t\" + str(lineRI.NumOfBases) + \"\\t\" + lineRI.junction[\n                                                                                        :-5] + \"\\t\" + lineRI.refstrand\n        IDfileoutputR2 = str(line2.loc) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(line2.NumOfBases) + \"\\t\" + line2.chr + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"linear,genomeGood,\" + lineRI.junction[-4:]\n\n        if lineRI.chr == line2.chr and lineRI.refstrand != line2.refstrand and lineRI.strand == \"+\":\n            if line2.loc > lineRI.loc_right or line2.loc < lineRI.loc_left:\n                pass\n            else:\n                IDfiletype = \"anomaly,genomeBad,\" + lineRI.junction[-4:]\n        elif lineRI.chr == line2.chr and lineRI.refstrand != line2.refstrand and lineRI.strand == \"-\":\n            if line2.loc > lineRI.loc_left or line2.loc > lineRI.loc_right:\n                pass\n            else:\n                IDfiletype = \"anomaly,genomeBad,\" + lineRI.junction[-4:]\n        else:\n            IDfiletype = \"anomaly,genomeBad,\" + lineRI.junction[-4:]\n\n        IDfile.write(\n            line_raw_RI.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\nclass ReadInfoRI:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        if line[2][-4:-1] == \"DEL\":\n            #            print \"is a deletion\"\n            #            print line[2][-1:]\n            self.indel = -int(line[2][-1:])\n\n        if line[2][-4:-1] == \"INS\":\n            self.indel = int(line[2][-1:])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr = JuncInfo[0]\n        self.loc_left = int(JuncInfo[2])\n        self.loc_right = int(JuncInfo[4])\n        self.strand = JuncInfo[6]\n\n\nclass ReadInfoGenome:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.chr = line[2]\n        self.loc = int(line[3])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\nclass ReadInfoJunc:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.chr = line[2].split(\"|\")[0]\n        self.loc_left = int(line[2].replace(\":\", \"|\").split(\"|\")[2])\n        self.loc_right = int(line[2].replace(\":\", \"|\").split(\"|\")[4])\n        self.strand = line[2][-1]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\n# =========================================\n# start here\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name of file to generate report\")\n#parser.add_argument(\"-c\", \"--circReads\", required=True, help=\"path to circReads Dir\")\n#parser.add_argument(\"-i\", \"--origDir\", required=True, help=\"path to orig dir containing genome reads\")\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-ris1\", \"--regularIndelsSAM1\", nargs='+', required=True, help=\"unaligned reads 1 from KNIFE aligned to regular indels\")\nparser.add_argument(\"-ris2\", \"--regularIndelsSAM2\", nargs='+', required=True, help=\"unaligned reads 2 from KNIFE aligned to regular indels\")\n\nparser.add_argument(\"-gens1\", \"--genomeSAM1\", required=True, help=\"read1 to genome\")\nparser.add_argument(\"-gens2\", \"--genomeSAM2\", required=True, help=\"read2 to genome\")\nparser.add_argument(\"-regs1\", \"--regularSAM1\", required=True, help=\"read1 to regular junction\")\nparser.add_argument(\"-regs2\", \"--regularSAM2\", required=True, help=\"read2 to regular junction\")\nparser.add_argument(\"-scrs1\", \"--scrambledSAM1\", required=True, help=\"read1 to ribosomal junction\")\nparser.add_argument(\"-scrs2\", \"--scrambledSAM2\", required=True, help=\"read2 to ribosomal junction\")\n\nargs = parser.parse_args()\nwindow = int(args.window)\n\n# f1 = open(\"/Users/Gillian/Desktop/sherlock/unaligned_ENCFF000HOC1_1.sam\", mode =\"rU\")\n# f2 = open(\"/Users/Gillian/Desktop/sherlock/20000_ENCFF000HOC2_1_genome_output.sam\", mode =\"rU\")\n\n\n\n#if args.origDir[-1] != \"/\":\n#    args.origDir += \"/\"\n#if args.circReads[-1] != \"/\":\n#    args.circReads += \"/\"\n\n#stem = args.stem\n\nregIndelfiles = []\nregfiles = []\ngenomefiles = []\njunctionfiles = []\n\n#for name in glob.glob(args.origDir + \"RegIndelAlignments/\" + stem + \"/*.sam\"):\n#    print name\n#    if \"All_\" not in name:\n#        regIndelfiles.append(name)\n        # Regfiles contains indel alignments for _1 and _2 files to indels 1-5\n\n#for name in glob.glob(os.path.join(args.origDir, \"genome/*\" + stem + \"*.sam\")):\n#    print name\n#    if \"sorted\" not in name:\n#        genomefiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"reg/*\" + stem + \"*.sam\")):\n#    print name\n#    if \"sorted\" not in name:\n#        regfiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"junction/*\" + stem + \"*.sam\")):\n#    print name\n#    if \"sorted\" not in name:\n#        junctionfiles.append(name)\n\n\n        # opening all files for a particular stem\n# print sorted(regIndelfiles)\n# print sorted(genomefiles)\n# print sorted(regfiles)\n# print sorted(junctionfiles)\n\n\n## concatenate all reg indels files into a single big indels file\n\n#regIndel1_list = sorted(regIndelfiles)[0:len(regIndelfiles) / 2]\n#regIndel2_list = sorted(regIndelfiles)[len(regIndelfiles) / 2:]\n\nregIndel1_list = args.regularIndelsSAM1\nregIndel2_list = args.regularIndelsSAM2\n\n\nIndelsReadIDs = {}\n\nfor name in regIndel1_list:\n    print \"reg1 indels\"\n    print name\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoRI(line)\n        # if the read overlaps the junction\n        if read.offset <= (150 - int(args.window) + read.indel) and read.offset + read.NumOfBases >= (\n                150 + int(args.window) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoRI(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\nfout_regIndel1 = open(\"All_\" + args.sample + \"_1_Regindels.sam\", mode=\"w\")\n\nfor key in IndelsReadIDs:\n    fout_regIndel1.write(IndelsReadIDs[key].strip() + \"\\n\")\n\nfout_regIndel1.close()\n\n## CLEAR Read IDs dictionary and do the same with FJ2 list\nIndelsReadIDs = {}\n\nfor name in regIndel2_list:\n    print \"regIndel2 indels\"\n    print name\n\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoRI(line)\n        # if the read overlaps the junction\n        if read.offset <= (150 - int(args.window) + read.indel) and read.offset + read.NumOfBases >= (\n                150 + int(args.window) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoRI(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\nfout_regIndel2 = open(\"All_\" + args.sample + \"_2_Regindels.sam\", mode=\"w\")\n\nfor key in IndelsReadIDs:\n    fout_regIndel2.write(IndelsReadIDs[key].strip() + \"\\n\")\nfout_regIndel2.close()\n\n## open big indels files\n\nf1_regIndel = open(\"All_\" + args.sample + \"_1_Regindels.sam\", mode=\"rB\")\nf2_regIndel = open(\"All_\" + args.sample + \"_2_Regindels.sam\", mode=\"rB\")\n\n# ID file ReadID and different buckets.\n# [0] = readID\n# [1] = R2 in genome\n# [2] = R2 in genome anomaly\n# [3] = reg\n# [4] = reg anom\n# [5] = junc\n# [6] = junc anom\n\n\n\nIDfile = open(args.sample + \"_temp_output_RegIndel.txt\", mode=\"w\")\nIDfile.write(\n    \"ID\\tclass\\tR1_offset\\tR1_MAPQ\\tR1_adjAS\\tR1_NumN\\tR1_Readlength\\tR1_JuncName\\tR1_strand\\tR2_offset\\tR2_MAPQ\\tR2_adjAS\\tR2_NumN\\tR2_Readlength\\tR2_JuncName\\tR2_strand\\n\")\n\n# populate all reads and junctions into separate dictionaries\nAllRegIndelRead1 = {}\nAllRegIndelRead2 = {}\n\n# AllJunctions = {}\n# genomeDict = {}  # for all these dictionaries, [0] = reg, [1] = anom\n# regDict = {}        # [2] = sum of AS, [3] = read length\n# juncDict = {}\n# unmappedDict= {} # start with all readIDs.  if a partner is seen, then remove from list.\n\n\n# populate AllFJRead1 dictionary - all read 1's from FarJunction alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening All_regIndels_1 file\"\n\nfor line_raw in f1_regIndel:\n    if line_raw[0] == \"@\":\n        continue\n\n    RegIndel1read = ReadInfoRI(line_raw)\n\n    if RegIndel1read.offset <= (150 + RegIndel1read.indel - window) and (\n        RegIndel1read.offset + RegIndel1read.NumOfBases) >= 150 + RegIndel1read.indel + window:\n        AllRegIndelRead1[RegIndel1read.ID] = [line_raw, 0]\n# if FJ1read.junction not in AllJunctions:\n#            AllJunctions[FJ1read.junction]=0\n#        AllJunctions[FJ1read.junction] +=1\n#        unmappedDict[AllRegRead1.ID] = AllRegRead1.junction\n\nf1_regIndel.close()\nIDfile.flush()\n\n# populate AllFJRead2 dictionary - all read 2's from FarJunc alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening All_regIndels _2 file\"\nfor line_raw in f2_regIndel:\n    if line_raw[0] == \"@\":\n        continue\n\n    RegIndel2read = ReadInfoRI(line_raw)\n\n    #    if FJ1read.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 409\"\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if RegIndel2read.ID in AllRegIndelRead1:\n        # print \"found FJ read\"\n        # AllFJRead1[FJ2read.ID][1]=\"FJ\"\n        if RegIndel2read.offset <= (150 + RegIndel2read.indel - window) and (\n            RegIndel2read.offset + RegIndel2read.NumOfBases) >= 150 + RegIndel2read.indel + window and \\\n                        AllRegIndelRead1[RegIndel2read.ID][1] == 0:\n            AddToDict(\"RI\", line_raw, AllRegIndelRead1[RegIndel2read.ID][0])\n            AllRegIndelRead1[RegIndel2read.ID][1] = \"RI\"\n            #            if FJ2read.ID in unmappedDict:\n            #               del unmappedDict[FJ2read.ID]\n            # otherwise add to F2 read\n    else:\n        AllRegIndelRead2[RegIndel2read.ID] = [line_raw, 0]\n# unmappedDict[FJ2read.ID] = FJ2read.junction\n\n#    if RegIndel2read.junction not in AllJunctions:\n#        AllJunctions[FJ2read.junction]=0\n\n#    AllJunctions[FJ2read.junction]+=1\nf2_regIndel.close()\nIDfile.flush()\n\n#f2_genome = open(sorted(genomefiles)[1], mode=\"rB\")\nf2_genome = open(args.genomeSAM2, mode = \"rB\")\n\n# compare FJ read 1 to genome read 2\nprint \"comparing Indels to genome_2\"\nfor line_raw in f2_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g2read = ReadInfoGenome(line_raw)\n\n    if g2read.ID in AllRegIndelRead1 and AllRegIndelRead1[g2read.ID][1] == 0:\n        # print \"found genome R2\"+ g2read.ID\n        #        if g2read.ID in unmappedDict:\n        #            del unmappedDict[g2read.ID]\n        AddToDict(\"genome\", line_raw, AllRegIndelRead1[g2read.ID][0])\n        AllRegIndelRead1[g2read.ID][1] = \"genome\"\n\nf2_genome.close()\nIDfile.flush()\n\n#f1_genome = open(sorted(genomefiles)[0], mode=\"rB\")\nf1_genome = open(args.genomeSAM1, mode = \"rB\")\n\n# compare FJ read 2 to genome read 1\nprint \"comparing Indels to genome_1\"\n\nfor line_raw in f1_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g1read = ReadInfoGenome(line_raw)\n\n    if g1read.ID in AllRegIndelRead2 and AllRegIndelRead2[g1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        #        if g1read.ID in unmappedDict:\n        #            del unmappedDict[g1read.ID]\n        AddToDict(\"genome\", line_raw, AllRegIndelRead2[g1read.ID][0])\n        AllRegIndelRead2[g1read.ID][1] = \"genome\"\nf1_genome.close()\nIDfile.flush()\n#\n\n\n#f2_reg = open(sorted(regfiles)[1], mode=\"rB\")\nf2_reg = open(args.regularSAM2, mode = \"rB\")\n\n# compare FJ read 1 to reg read 2\nprint \"comparing Indels to reg_2\"\n\nfor line_raw in f2_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg2read = ReadInfoJunc(line_raw)\n\n    if reg2read.offset <= (150 - window) and (reg2read.offset + reg2read.NumOfBases) >= (150 + window):\n        if reg2read.ID in AllRegIndelRead1 and AllRegIndelRead1[reg2read.ID][1] == 0:\n            # print \"found reg R2: \" + reg2read.ID\n            #            if reg2read.ID in unmappedDict:\n            #                del unmappedDict[reg2read.ID]\n            AddToDict(\"reg\", line_raw, AllRegIndelRead1[reg2read.ID][0])\n            AllRegIndelRead1[reg2read.ID][1] = \"reg\"\nf2_reg.close()\nIDfile.flush()\n\n#f1_reg = open(sorted(regfiles)[0], mode=\"rB\")\nf1_reg = open(args.regularSAM1, mode = \"rB\")\n\n# compare FJ read 2 to reg read 1\nprint \"comparing Indels to reg_1\"\n\nfor line_raw in f1_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg1read = ReadInfoJunc(line_raw)\n\n    if reg1read.offset <= (150 - window) and (reg1read.offset + reg1read.NumOfBases) >= (150 + window):\n        if reg1read.ID in AllRegIndelRead2 and AllRegIndelRead2[reg1read.ID][1] == 0:\n            # print \"found reg R1: \" + reg1read.ID\n            #            if reg1read.ID in unmappedDict:\n            #                del unmappedDict[reg1read.ID]\n            AddToDict(\"reg\", line_raw, AllRegIndelRead2[reg1read.ID][0])\n            AllRegIndelRead2[reg1read.ID][1] = \"reg\"\nf1_reg.close()\nIDfile.flush()\n\n#f2_junc = open(sorted(junctionfiles)[1], mode=\"rB\")\nf2_junc = open(args.scrambledSAM2, mode = \"rB\")\n\n# compare FJ read 1 to junc read 2\nprint \"comparing Indels to junc_2\"\n\nfor line_raw in f2_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc2read = ReadInfoJunc(line_raw)\n\n    if junc2read.offset <= (150 - window) and (junc2read.offset + junc2read.NumOfBases) >= (150 + window):\n        if junc2read.ID in AllRegIndelRead1 and AllRegIndelRead1[junc2read.ID][1] == 0:\n            #            print \"found junc R2: \" + junc2read.ID\n            #            if junc2read.ID in unmappedDict:\n            #                del unmappedDict[junc2read.ID]\n            AddToDict(\"junc\", line_raw, AllRegIndelRead1[junc2read.ID][0])\n            AllRegIndelRead1[junc2read.ID][1] = \"junc\"\nf2_junc.close()\nIDfile.flush()\n\n#f1_junc = open(sorted(junctionfiles)[0], mode=\"rB\")\nf1_junc = open(args.scrambledSAM1, mode = \"rB\")\n\n# compare FJ read 2 to junc read 1\nprint \"comparing Indels to junc_1\"\n\nfor line_raw in f1_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc1read = ReadInfoJunc(line_raw)\n\n    if junc1read.offset <= (150 - window) and (junc1read.offset + junc1read.NumOfBases) >= (150 + window):\n        if junc1read.ID in AllRegIndelRead2 and AllRegIndelRead2[junc1read.ID][1] == 0:\n            #            print \"found junc R1: \" + junc1read.ID\n            #            if junc1read.ID in unmappedDict:\n            #                del unmappedDict[junc1read.ID]\n            AddToDict(\"junc\", line_raw, AllRegIndelRead2[junc1read.ID][0])\n            AllRegIndelRead2[junc1read.ID][1] = \"junc\"\nf1_junc.close()\nIDfile.flush()\n\nIDfile.close()\n\n#\n\n\n#############################################################################\n## This section of code takes the written ID file above (temp_IDs_STEM.txt) and\n## removes duplicate entries of genome and reg. The same readID may be found\n## in both libraries and would both be in the ID file.\n## The new ID file removes duplicates and only keeps the readID with the\n## best alignment score.\n#tempIDfile = open(args.circReads + \"ids/\" + stem + \"_temp_output_RegIndel.txt\", mode=\"rU\")\n#newIDfile = open(args.circReads + \"ids/\" + stem + \"_output_RegIndel.txt\", mode=\"w\")\n\ntempIDfile = open(args.sample + \"_temp_output_RegIndel.txt\", mode=\"rU\")\nnewIDfile = open(args.sample + \"__output_RegIndel.txt\", mode=\"w\")\n\n\n##grep col 2 for \"genom\", \"Regular\" or \"RegAnomaly\". if not found ,write to\n## new file immediately.\n## if found, feed into dictionary (key=readID, value= entire line from temp file)\n## if duplicate entry, then compare R2 AS. if AS larger, then replace\n## value with new value from new R2\n## at completion of file, write entire dictionary into new ID file.\n\nGenomeAndRegReadIDs = {}\n\nfor line in tempIDfile:\n    line = line.strip()\n    if \"unaligned\" in line:\n        continue\n\n    if \"Unmapped\" in line:\n        continue\n\n    readID = line.split(\"\\t\")[0]\n    classID = line.split(\"\\t\")[1]\n    AS_new = line.split(\"\\t\")[11]\n\n    if \"genom\" in classID:\n        ## if readID has been seen previously, then replace value in dictionary\n        ## only if AS is greater.\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"Regular\" in classID:\n        ## do the same if reg\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"RegAnomaly\" in classID:\n        ## do the same if reg anomaly\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    else:\n        ## if not genome/genome anomaly/ reg/ reg anomaly then\n        ## write line directly in new file.\n        newIDfile.write(line + \"\\n\")\n\nfor entry in GenomeAndRegReadIDs:\n    newIDfile.write(GenomeAndRegReadIDs[entry] + \"\\n\")\n\ntempIDfile.close()\nnewIDfile.close()",
                "filename": "RegIndels_ClassIDFile.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n"
            },
            "separate": true
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#scrambled_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "id": "#regular_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "sbg:altPrefix": "--regularIndelsSAM1",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-ris2",
              "separate": true,
              "itemSeparator": " "
            },
            "id": "#regularIndelsSAM2",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--regularIndelsSAM1",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-ris1",
              "separate": true,
              "itemSeparator": " "
            },
            "id": "#regularIndelsSAM1",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-w",
              "separate": true
            },
            "id": "#overlap",
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-m",
              "separate": true
            },
            "id": "#mode",
            "required": false,
            "type": [
              "null",
              {
                "name": "mode",
                "type": "enum",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "id": "#genome_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "regular_sam": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/regular_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/regular_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "scrambled_sam": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/scrambled_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/scrambled_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "overlap": 1,
            "genome_sam": [
              {
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/genome_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/genome_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "mode": "complete",
            "regularIndelsSAM1": [
              {
                "secondaryFiles": [],
                "path": "/path/to/regularIndelsSAM1-1.ext",
                "class": "File",
                "size": 0
              },
              {
                "secondaryFiles": [],
                "path": "/path/to/regularIndelsSAM1-2.ext",
                "class": "File",
                "size": 0
              }
            ],
            "regularIndelsSAM2": [
              {
                "secondaryFiles": [],
                "path": "/path/to/regularIndelsSAM2-1.ext",
                "class": "File",
                "size": 0
              },
              {
                "secondaryFiles": [],
                "path": "/path/to/regularIndelsSAM2-2.ext",
                "class": "File",
                "size": 0
              }
            ]
          }
        },
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/regindels-classidfile/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/regindels-classidfile/1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "y": -100.45483405542961,
        "sbg:cmdPreview": "python RegIndels_ClassIDFile.py  -s sample_name",
        "stdin": "",
        "label": "MACHETE RegIndels_ClassIDFile"
      },
      "inputs": [
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.scrambled_sam",
          "source": [
            "#getUnalignedReads_2.mate_scrambled_sam",
            "#getUnalignedReads_1.mate_scrambled_sam"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.regular_sam",
          "source": [
            "#getUnalignedReads_2.mate_regular_sam",
            "#getUnalignedReads_1.mate_regular_sam"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.regularIndelsSAM2",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.regularIndelsSAM1",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.genome_sam",
          "source": [
            "#getUnalignedReads_2.mate_genome_sam",
            "#getUnalignedReads_1.mate_genome_sam"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.temp_output_RegIndel"
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.output_RegIndel"
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.all_regindels_sam"
        }
      ],
      "sbg:x": 5916.355211788617,
      "sbg:y": -100.45483405542961
    },
    {
      "id": "#SPORK_split_large_fasta",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "revision 4 copied",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520433313,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 4 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520433346,
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "baseCommand": [
          "python",
          "split_large_fasta.py"
        ],
        "outputs": [
          {
            "id": "#splitted_by_chr",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#novel_junctions",
              "glob": "*FarJunctions.fa"
            }
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1520433346,
        "id": "milos_jordanski/spachete-salzman-collaboration/split-large-fasta/1",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 1,
        "temporaryFailCodes": [],
        "sbg:revision": 1,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520433313,
        "x": 2910.3336159123396,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import sys\nimport os\n\ndef split_big_fasta(big_fasta_name):\n    path_prefix = big_fasta_name.split(\"_novel_junctions.fasta\")[0]\n    name_prefix = path_prefix.split(\"/\")[-1]\n    name_suffix = \"FarJunctions.fa\"\n\n\n    #chroms = [ \"chr1\", \"chr2\", \"chr3\", \"chr4\", \"chr5\", \"chr6\", \"chr7\", \"chr8\", \"chr9\",\"chr10\",\n    #          \"chr11\",\"chr12\",\"chr13\",\"chr14\",\"chr15\",\"chr16\",\"chr17\",\"chr18\",\"chr19\",\"chr20\",\n    #          \"chr21\",\"chr22\", \"chrX\", \"chrY\"]\n    chroms = {}\n\n    #Open all the out files\n    out_files = {}\n    #for chrom in chroms:\n    #    out_files[chrom] = open(name_prefix+\"_\"+chrom+name_suffix,\"w\")\n\n    #Walk through the big fasta copying out the info\n    #to the individual chromosomes files\n    big_fasta = open(big_fasta_name,\"r\")\n    header_line = big_fasta.readline()\n    while header_line:\n        seq_line = big_fasta.readline()\n        chrom = header_line.split(\":\")[0][1:]\n        if chrom not in chroms:\n            chroms[chrom] = 0\n            out_files[chrom] = open(name_prefix + \"_\" + chrom + name_suffix, \"w\")\n        if chrom in out_files:\n            out_files[chrom].write(header_line)\n            out_files[chrom].write(seq_line)\n\n        #Advance to the next fasta\n        header_line = big_fasta.readline()\n\n    #Close all the out files\n    for chrom in chroms:\n        out_files[chrom].close()\n\nif __name__ == \"__main__\":\n    big_fasta_name = sys.argv[1]\n    split_big_fasta(big_fasta_name)",
                "filename": "split_large_fasta.py"
              }
            ]
          }
        ],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "arguments": [],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#novel_junctions",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "FASTA",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "required": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "novel_junctions": {
              "secondaryFiles": [],
              "path": "/path/to/novel_junctions.ext",
              "class": "File",
              "size": 0
            }
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/split-large-fasta/1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -168.31771076987945,
        "sbg:cmdPreview": "python split_large_fasta.py",
        "stdin": "",
        "label": "SPORK_split_large_fasta"
      },
      "inputs": [
        {
          "id": "#SPORK_split_large_fasta.novel_junctions",
          "source": [
            "#SPORK_BadFJ3.novel_fusions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_split_large_fasta.splitted_by_chr"
        }
      ],
      "sbg:x": 2910.3336159123396,
      "sbg:y": -168.31771076987945
    },
    {
      "id": "#SPORK_Bowtie2_Indexer_Junctions",
      "run": {
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
        "sbg:modifiedOn": 1520458480,
        "class": "CommandLineTool",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.tar",
              "streamable": false,
              "sbg:metadata": {
                "reference_genome": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  var ref_name = $job.inputs.reference_or_index.path.split(\"/\").pop().replace(/\\.[^/.]+$/, \"\")\n//  var inherited_name = $job.inputs.reference_or_index.metadata.reference_genome\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\" ||\n      $job.inputs.reference_or_index.metadata == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == \"\"){\n    return ref_name\n  } else{\n    return $job.inputs.reference_or_index.metadata.reference_genome\n  }\n}"
                },
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Bowtie index archive",
            "id": "#bowtie_index_archive",
            "type": [
              "File"
            ],
            "sbg:fileTypes": "TAR",
            "description": "Archived Bowtie2 index files."
          }
        ],
        "description": "Bowtie2 Indexer is a tool for indexing reference genomes of any size used in an alignment. It was built from `bowtie2-build` script and used for reference genome indexing aimed at assisting Bowtie2 in fast and memory-efficient alignment. It outputs an archive which consists of 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2. This archive constitutes the index and should be provided when aligning the reads (either with [Bowtie2 Aligner](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-aligner) or [TopHat2](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/tophat2)). \n\n###Common issues###\nNo issues have been reported.",
        "cwlVersion": "sbg:draft-2",
        "sbg:cmdPreview": "echo 'Archive provided on the input, no indexing.'",
        "successCodes": [],
        "arguments": [
          {
            "position": 101,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  index_prefix = $job.inputs.reference_or_index.path.split('.').slice(0, $job.inputs.reference_or_index.path.split('.').length-1).join('.').replace(/^.*[\\\\\\/]/, '')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"./\".concat(index_prefix)\n  }\n}"
            },
            "separate": false
          },
          {
            "position": 102,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var bt = \"bowtie2-2.3.4.1\"\n  var suffix_glob = \"\"\n  var ref = $job.inputs.reference_or_index.path\n  var ref_name = ref.split('/').pop(0).replace(/\\.[^/.]+$/, \"\")\n  var tar_name = ref_name.concat(\"_\", bt, '.tar')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  \n  if ($job.inputs.large_index) {\n    suffix_glob = \" ./*.bt2l*\"\n  } else {\n    suffix_glob = \" ./*.bt2*\"\n  }\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \" && tar -vcf \".concat(tar_name, suffix_glob)\n  }\n}"
            },
            "separate": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "sbg:validationErrors": [],
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 2,
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          }
        ],
        "sbg:revision": 2,
        "sbg:modifiedBy": "milos_jordanski",
        "baseCommand": [
          {
            "engine": "#cwl-js-engine",
            "class": "Expression",
            "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"bowtie2-build -f\"\n  } else {\n    return \"echo 'Archive provided on the input, no indexing.'\"\n  }\n}"
          }
        ],
        "stdout": "",
        "temporaryFailCodes": [],
        "sbg:createdOn": 1520444443,
        "x": 2919.0001159906406,
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdin": "",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520444443,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520444463,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1520458480,
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "inputs": [
          {
            "id": "#threads",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--threads",
              "separate": true
            },
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ],
            "label": "Number of threads"
          },
          {
            "sbg:toolDefaultValue": "4",
            "label": "Suffixes as fraction",
            "sbg:category": "Advanced Options",
            "id": "#suffixes_as_fraction",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes_as_fraction\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes_as_fraction) {\n      return \"--bmaxdivn \".concat($job.inputs.suffixes_as_fraction)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "The maximum number of suffixes allowed in a block, expressed as a fraction of the length of the reference. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". This is configured automatically by default; use \"Disable default parameters\" to configure manually."
          },
          {
            "sbg:toolDefaultValue": "-",
            "label": "Suffixes",
            "sbg:category": "Advanced Options",
            "id": "#suffixes",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes) {\n      return \"--bmax \".concat($job.inputs.suffixes)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "The maximum number of suffixes allowed in a block. Allowing more suffixes per block makes indexing faster, but increases peak memory usage. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". Default (in terms of the \"Suffixes (as fraction)\" parameter) is 4. This is configured automatically by default; use \"Disable default parameters\" to configure manually."
          },
          {
            "sbg:toolDefaultValue": "-",
            "label": "Seed",
            "sbg:category": "Basic Options",
            "id": "#seed",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.seed\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--seed\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Set the seed for pseudo-random number generator."
          },
          {
            "sbg:toolDefaultValue": "5",
            "label": "Rows to mark",
            "sbg:category": "Basic Options",
            "id": "#rows_to_mark",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.rows_to_mark\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--offrate\"\n  }\n}"
              },
              "separate": false
            },
            "description": "To map alignments back to positions on the reference sequences, it is necessary to annotate (\"mark\") some or all of the Burrows-Wheeler rows with their corresponding location on the genome. \"Rows to mark\" governs how many rows get marked: the indexer will mark every 2^(given number) rows. Marking more rows makes reference-position lookups faster, but requires more memory to hold the annotations at runtime. The default is 5 (every 32nd row is marked; for human genome, annotations occupy about 340 megabytes)."
          },
          {
            "type": [
              "File"
            ],
            "sbg:fileTypes": "FASTA, FA, TAR",
            "label": "Reference/Index files",
            "sbg:category": "Input files",
            "id": "#reference_or_index",
            "required": true,
            "sbg:stageInput": "link",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "streamable": false,
              "position": 100,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return $job.inputs.reference_or_index.path\n  }\n}"
              },
              "separate": false
            },
            "description": "Reference sequence to which to align the reads. If tar bundle with indexes provided, this file would just be passed to the output."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Packed representation",
            "sbg:category": "Advanced Options",
            "id": "#packed_representation",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.packed_representation\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.packed_representation){\n      return \"--packed \".concat($job.inputs.packed_representation)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "Use a packed (2-bits-per-nucleotide) representation for DNA strings. This saves memory but makes indexing 2-3 times slower. This is configured automatically by default; set \"Disable default parameters\" to configure manually."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Only bitpacked files",
            "sbg:category": "Basic Options",
            "id": "#only_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.only_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--justref\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Build only the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Large index",
            "sbg:category": "Basic Options",
            "id": "#large_index",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.large_index\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--large-index\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Force indexer to build a large index, even if the reference is less than ~ 4 billion nucleotides inlong."
          },
          {
            "sbg:toolDefaultValue": "10",
            "label": "Ftab lookup table size",
            "sbg:category": "Basic Options",
            "id": "#ftab_lookup_table_size",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.ftab_lookup_table_size\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--ftabchars\"\n  }\n}"
              },
              "separate": false
            },
            "description": "The ftab is the lookup table used to calculate an initial Burrows-Wheeler range with respect to the first given number of characters of the query. A larger number yields a larger lookup table but faster query times. The ftab has size 4^(given number + 1) bytes. The default setting is 10 (ftab is 4MB)."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Discard bitpacked files",
            "sbg:category": "Basic Options",
            "id": "#discard_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.discard_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noref\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Do not build the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable diff-cover sample",
            "sbg:category": "Basic Options",
            "id": "#disable_diff_cover_sample",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_diff_cover_sample\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--nodc\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Disable use of the difference-cover sample. Suffix sorting becomes quadratic-time in the worst case (where the worst case is an extremely repetitive reference)."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable default parameters",
            "sbg:category": "Basic Options",
            "id": "#disable_default_parameters",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_default_parameters\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noauto\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Disable the default behavior whereby indexer automatically selects values for the parameters under \"Advanced Options\" according to available memory. Instead, user may specify values for those parameters. If memory is exhausted during indexing, an error message will be printed; it is up to the user to try new parameters."
          },
          {
            "sbg:toolDefaultValue": "1024",
            "label": "Difference-cover period",
            "sbg:category": "Advanced Options",
            "id": "#difference_cover_period",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.difference_cover_period\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.difference_cover_period) {\n      return \"--dcv \".concat($job.inputs.difference_cover_period)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "Set the period for the difference-cover sample. A larger period yields less memory overhead, but may make suffix sorting slower, especially if repeats are present. Must be a power of 2 no greater than 4096. This is configured automatically by default; use \"Disable default parameters\" to configure manually."
          }
        ],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:image_url": null,
        "sbg:job": {
          "allocatedResources": {
            "mem": 60000,
            "cpu": 1
          },
          "inputs": {
            "threads": 10,
            "difference_cover_period": 6,
            "disable_default_parameters": true,
            "large_index": false,
            "reference_or_index": {
              "metadata": {
                "reference_genome": "test"
              },
              "path": "/test/human_g1k_v37_decoy_bowtie2-2.2.6.tar",
              "secondaryFiles": []
            }
          }
        },
        "hints": [
          {
            "diskSize": null,
            "dockerImageId": "029d3a264215",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "diskSize": null,
            "value": 60000,
            "class": "sbg:MemRequirement"
          },
          {
            "value": "r3.8xlarge",
            "class": "sbg:AWSInstanceType"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": 13.348957936589924,
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:toolkit": "Bowtie2",
        "label": "SPORK Bowtie2-2.3.4.1 Indexer Junctions"
      },
      "inputs": [
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.threads",
          "default": 32
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.suffixes_as_fraction"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.suffixes"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.seed"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.rows_to_mark"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.reference_or_index",
          "source": [
            "#SPORK_BadFJ3.novel_fusions"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.packed_representation"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.only_bitpacked_files"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.large_index"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.ftab_lookup_table_size"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.discard_bitpacked_files"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.disable_diff_cover_sample"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.disable_default_parameters"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.difference_cover_period"
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_Bowtie2_Indexer_Junctions.bowtie_index_archive"
        }
      ],
      "sbg:x": 2919.0001159906406,
      "sbg:y": 13.348957936589924
    },
    {
      "id": "#parse_to_remove_FJ",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "revision 7 copied",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520433484,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 7 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520433510,
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "baseCommand": [
          "python",
          "parse_to_remove_FJ.py"
        ],
        "outputs": [
          {
            "id": "#chr_filtered_fusion_junction",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#chr_fusion_junctions",
              "glob": "*.fa"
            }
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1520433510,
        "id": "milos_jordanski/spachete-salzman-collaboration/parse-to-remove-fj/1",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 1,
        "temporaryFailCodes": [],
        "sbg:revision": 1,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520433484,
        "x": 3419.6668026844677,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import re\nimport os\nimport subprocess\nimport csv\n\n# to call this:\n# cmd=\"python {INSTALLDIR}/parse_to_remove_FJ.py --stem {STEM} --outputdir {OUTPUT_DIR}\".format(INSTALLDIR=INSTALLDIR, STEM=STEM, OUTPUT_DIR=OUTPUT_DIR)\n\n\n# python parse_to_remove_FJ.py --stem\nimport argparse\n\nparser = argparse.ArgumentParser()\n#parser.add_argument(\"--stem\", help=\"STEM string\")\n#parser.add_argument(\"--outputdir\", help=\"OUTPUT_DIR\")\n\nparser.add_argument(\"-nr\", \"--naive_report\", help=\"Naive Report\", required = True)\nparser.add_argument(\"-fj\", \"--far_junctions\", nargs='+', help=\"Far junctions per chromosome\", required = True)\n\nargs = parser.parse_args()\n\n# first get STEM, assume it is passed from run.py\n#STEM = args.stem\n#outputdir = args.outputdir\n\n#naive_report = os.path.join(outputdir, \"reports\", STEM + \"_naive_report.txt\")\n\n#fastadir = os.path.join(outputdir, \"fasta\")\n\n\nrawcsv = csv.reader(open(args.naive_report), delimiter='\\t')\nfirst_column = []\nfor row in rawcsv:\n    first_column.append(row[0])\n# drop first element as it's from the header:\nfirst_column.pop(0)\n\nfirst_col_with_arrow = [(\">\" + x) for x in first_column]\n\n#fasta_stem_dir = os.path.join(fastadir, STEM)\n\n#posschrfjfiles = os.listdir(fasta_stem_dir)\n\n#chrfjfiles = [os.path.join(fasta_stem_dir, x) for x in posschrfjfiles if (re.search(pattern='chr.*FarJunctions.fa', string=x))]\n\nchrfjfiles = args.far_junctions\n\nnewfile = \"temp211.txt\"\nfor thisfile in chrfjfiles:\n    # clear newfile in case already used\n    open(newfile, 'w').close()\n\n    with open(thisfile, 'r') as ff:\n        lines = ff.read().splitlines()\n    for index, thisline in enumerate(lines):\n        if (thisline in first_col_with_arrow):\n            with open(newfile, 'a') as nn:\n                nn.write(thisline + \"\\n\")\n                if (index < len(lines)):\n                    nn.write(lines[(index + 1)] + \"\\n\")\n    # then write new file over the current file\n    cmd = \"mv -f \" + newfile + \" \" + thisfile\n    print(cmd)\n    subprocess.call(cmd, shell=True)",
                "filename": "parse_to_remove_FJ.py"
              }
            ]
          }
        ],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "arguments": [],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#naive_report",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-nr",
              "separate": true
            },
            "required": false
          },
          {
            "id": "#chr_fusion_junctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fj",
              "separate": true,
              "itemSeparator": " "
            },
            "sbg:stageInput": "link",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "chr_fusion_junctions": {
              "secondaryFiles": [],
              "path": "/path/to/chr_fusion_junctions.ext",
              "class": "File",
              "size": 0
            },
            "naive_report": {
              "secondaryFiles": [],
              "path": "/path/to/naive_report.ext",
              "class": "File",
              "size": 0
            }
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "value": "r3.8xlarge",
            "class": "sbg:AWSInstanceType"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/parse-to-remove-fj/1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -216.3177122268827,
        "sbg:cmdPreview": "python parse_to_remove_FJ.py",
        "stdin": "",
        "label": "SPORK_parse_to_remove_FJ"
      },
      "inputs": [
        {
          "id": "#parse_to_remove_FJ.naive_report",
          "source": [
            "#SPORK_FarJuncJustNaiveReport.just_naive_report"
          ]
        },
        {
          "id": "#parse_to_remove_FJ.chr_fusion_junctions",
          "source": [
            "#SPORK_split_large_fasta.splitted_by_chr"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#parse_to_remove_FJ.chr_filtered_fusion_junction"
        }
      ],
      "sbg:x": 3419.6668026844677,
      "sbg:y": -216.3177122268827,
      "scatter": "#parse_to_remove_FJ.chr_fusion_junctions"
    },
    {
      "id": "#SPORK_linkfastafiles",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "revision 5 copied",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520433574,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 5 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520433599,
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "baseCommand": [
          "cat"
        ],
        "outputs": [
          {
            "id": "#concat_far_junctions",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*FarJunctions.fa",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.input_far_junctions)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n"
                }
              }
            }
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1520433599,
        "id": "milos_jordanski/spachete-salzman-collaboration/linkfastafiles/1",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 1,
        "temporaryFailCodes": [],
        "sbg:revision": 1,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": {
          "engine": "#cwl-js-engine",
          "class": "Expression",
          "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.input_far_junctions)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  return common_prefix.slice(0, common_prefix.length - 3) + \"FarJunctions.fa\"\n}"
        },
        "sbg:createdOn": 1520433574,
        "x": 3546.804326049656,
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "arguments": [],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#input_far_junctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "separate": true
            },
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "input_far_junctions": [
              {
                "metadata": {
                  "sample_id": "sample_name"
                },
                "size": 0,
                "path": "/path/to/input_far_junctions-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "secondaryFiles": [],
                "path": "/path/to/input_far_junctions-2.ext",
                "class": "File",
                "size": 0
              }
            ]
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "ubuntu"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/linkfastafiles/1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -124.27849663410603,
        "sbg:cmdPreview": "cat  > input_far_junctioFarJunctions.fa",
        "stdin": "",
        "label": "SPORK linkfastafiles"
      },
      "inputs": [
        {
          "id": "#SPORK_linkfastafiles.input_far_junctions",
          "source": [
            "#parse_to_remove_FJ.chr_filtered_fusion_junction"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_linkfastafiles.concat_far_junctions"
        }
      ],
      "sbg:x": 3546.804326049656,
      "sbg:y": -124.27849663410603
    },
    {
      "id": "#SPORK_Bowtie2_Indexer_NovelJunctions",
      "run": {
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
        "sbg:modifiedOn": 1520458480,
        "class": "CommandLineTool",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.tar",
              "streamable": false,
              "sbg:metadata": {
                "reference_genome": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  var ref_name = $job.inputs.reference_or_index.path.split(\"/\").pop().replace(/\\.[^/.]+$/, \"\")\n//  var inherited_name = $job.inputs.reference_or_index.metadata.reference_genome\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\" ||\n      $job.inputs.reference_or_index.metadata == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == \"\"){\n    return ref_name\n  } else{\n    return $job.inputs.reference_or_index.metadata.reference_genome\n  }\n}"
                },
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Bowtie index archive",
            "id": "#bowtie_index_archive",
            "type": [
              "File"
            ],
            "sbg:fileTypes": "TAR",
            "description": "Archived Bowtie2 index files."
          }
        ],
        "description": "Bowtie2 Indexer is a tool for indexing reference genomes of any size used in an alignment. It was built from `bowtie2-build` script and used for reference genome indexing aimed at assisting Bowtie2 in fast and memory-efficient alignment. It outputs an archive which consists of 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2. This archive constitutes the index and should be provided when aligning the reads (either with [Bowtie2 Aligner](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-aligner) or [TopHat2](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/tophat2)). \n\n###Common issues###\nNo issues have been reported.",
        "cwlVersion": "sbg:draft-2",
        "sbg:cmdPreview": "echo 'Archive provided on the input, no indexing.'",
        "successCodes": [],
        "arguments": [
          {
            "position": 101,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  index_prefix = $job.inputs.reference_or_index.path.split('.').slice(0, $job.inputs.reference_or_index.path.split('.').length-1).join('.').replace(/^.*[\\\\\\/]/, '')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"./\".concat(index_prefix)\n  }\n}"
            },
            "separate": false
          },
          {
            "position": 102,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var bt = \"bowtie2-2.3.4.1\"\n  var suffix_glob = \"\"\n  var ref = $job.inputs.reference_or_index.path\n  var ref_name = ref.split('/').pop(0).replace(/\\.[^/.]+$/, \"\")\n  var tar_name = ref_name.concat(\"_\", bt, '.tar')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  \n  if ($job.inputs.large_index) {\n    suffix_glob = \" ./*.bt2l*\"\n  } else {\n    suffix_glob = \" ./*.bt2*\"\n  }\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \" && tar -vcf \".concat(tar_name, suffix_glob)\n  }\n}"
            },
            "separate": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "sbg:validationErrors": [],
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 2,
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          }
        ],
        "sbg:revision": 2,
        "sbg:modifiedBy": "milos_jordanski",
        "baseCommand": [
          {
            "engine": "#cwl-js-engine",
            "class": "Expression",
            "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"bowtie2-build -f\"\n  } else {\n    return \"echo 'Archive provided on the input, no indexing.'\"\n  }\n}"
          }
        ],
        "stdout": "",
        "temporaryFailCodes": [],
        "sbg:createdOn": 1520444443,
        "x": 3759.843329873743,
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdin": "",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520444443,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520444463,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1520458480,
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "inputs": [
          {
            "id": "#threads",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--threads",
              "separate": true
            },
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ],
            "label": "Number of threads"
          },
          {
            "sbg:toolDefaultValue": "4",
            "label": "Suffixes as fraction",
            "sbg:category": "Advanced Options",
            "id": "#suffixes_as_fraction",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes_as_fraction\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes_as_fraction) {\n      return \"--bmaxdivn \".concat($job.inputs.suffixes_as_fraction)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "The maximum number of suffixes allowed in a block, expressed as a fraction of the length of the reference. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". This is configured automatically by default; use \"Disable default parameters\" to configure manually."
          },
          {
            "sbg:toolDefaultValue": "-",
            "label": "Suffixes",
            "sbg:category": "Advanced Options",
            "id": "#suffixes",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes) {\n      return \"--bmax \".concat($job.inputs.suffixes)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "The maximum number of suffixes allowed in a block. Allowing more suffixes per block makes indexing faster, but increases peak memory usage. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". Default (in terms of the \"Suffixes (as fraction)\" parameter) is 4. This is configured automatically by default; use \"Disable default parameters\" to configure manually."
          },
          {
            "sbg:toolDefaultValue": "-",
            "label": "Seed",
            "sbg:category": "Basic Options",
            "id": "#seed",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.seed\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--seed\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Set the seed for pseudo-random number generator."
          },
          {
            "sbg:toolDefaultValue": "5",
            "label": "Rows to mark",
            "sbg:category": "Basic Options",
            "id": "#rows_to_mark",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.rows_to_mark\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--offrate\"\n  }\n}"
              },
              "separate": false
            },
            "description": "To map alignments back to positions on the reference sequences, it is necessary to annotate (\"mark\") some or all of the Burrows-Wheeler rows with their corresponding location on the genome. \"Rows to mark\" governs how many rows get marked: the indexer will mark every 2^(given number) rows. Marking more rows makes reference-position lookups faster, but requires more memory to hold the annotations at runtime. The default is 5 (every 32nd row is marked; for human genome, annotations occupy about 340 megabytes)."
          },
          {
            "type": [
              "File"
            ],
            "sbg:fileTypes": "FASTA, FA, TAR",
            "label": "Reference/Index files",
            "sbg:category": "Input files",
            "id": "#reference_or_index",
            "required": true,
            "sbg:stageInput": "link",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "streamable": false,
              "position": 100,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return $job.inputs.reference_or_index.path\n  }\n}"
              },
              "separate": false
            },
            "description": "Reference sequence to which to align the reads. If tar bundle with indexes provided, this file would just be passed to the output."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Packed representation",
            "sbg:category": "Advanced Options",
            "id": "#packed_representation",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.packed_representation\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.packed_representation){\n      return \"--packed \".concat($job.inputs.packed_representation)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "Use a packed (2-bits-per-nucleotide) representation for DNA strings. This saves memory but makes indexing 2-3 times slower. This is configured automatically by default; set \"Disable default parameters\" to configure manually."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Only bitpacked files",
            "sbg:category": "Basic Options",
            "id": "#only_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.only_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--justref\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Build only the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Large index",
            "sbg:category": "Basic Options",
            "id": "#large_index",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.large_index\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--large-index\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Force indexer to build a large index, even if the reference is less than ~ 4 billion nucleotides inlong."
          },
          {
            "sbg:toolDefaultValue": "10",
            "label": "Ftab lookup table size",
            "sbg:category": "Basic Options",
            "id": "#ftab_lookup_table_size",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.ftab_lookup_table_size\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--ftabchars\"\n  }\n}"
              },
              "separate": false
            },
            "description": "The ftab is the lookup table used to calculate an initial Burrows-Wheeler range with respect to the first given number of characters of the query. A larger number yields a larger lookup table but faster query times. The ftab has size 4^(given number + 1) bytes. The default setting is 10 (ftab is 4MB)."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Discard bitpacked files",
            "sbg:category": "Basic Options",
            "id": "#discard_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.discard_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noref\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Do not build the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable diff-cover sample",
            "sbg:category": "Basic Options",
            "id": "#disable_diff_cover_sample",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_diff_cover_sample\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--nodc\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Disable use of the difference-cover sample. Suffix sorting becomes quadratic-time in the worst case (where the worst case is an extremely repetitive reference)."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable default parameters",
            "sbg:category": "Basic Options",
            "id": "#disable_default_parameters",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_default_parameters\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noauto\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Disable the default behavior whereby indexer automatically selects values for the parameters under \"Advanced Options\" according to available memory. Instead, user may specify values for those parameters. If memory is exhausted during indexing, an error message will be printed; it is up to the user to try new parameters."
          },
          {
            "sbg:toolDefaultValue": "1024",
            "label": "Difference-cover period",
            "sbg:category": "Advanced Options",
            "id": "#difference_cover_period",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.difference_cover_period\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.difference_cover_period) {\n      return \"--dcv \".concat($job.inputs.difference_cover_period)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "Set the period for the difference-cover sample. A larger period yields less memory overhead, but may make suffix sorting slower, especially if repeats are present. Must be a power of 2 no greater than 4096. This is configured automatically by default; use \"Disable default parameters\" to configure manually."
          }
        ],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:image_url": null,
        "sbg:job": {
          "allocatedResources": {
            "mem": 60000,
            "cpu": 1
          },
          "inputs": {
            "threads": 10,
            "difference_cover_period": 6,
            "disable_default_parameters": true,
            "large_index": false,
            "reference_or_index": {
              "metadata": {
                "reference_genome": "test"
              },
              "path": "/test/human_g1k_v37_decoy_bowtie2-2.2.6.tar",
              "secondaryFiles": []
            }
          }
        },
        "hints": [
          {
            "diskSize": null,
            "dockerImageId": "029d3a264215",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "diskSize": null,
            "value": 60000,
            "class": "sbg:MemRequirement"
          },
          {
            "value": "r3.8xlarge",
            "class": "sbg:AWSInstanceType"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -105.33732240745704,
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:toolkit": "Bowtie2",
        "label": "SPORK Bowtie2-2.3.4.1 Indexer Novel Junctions"
      },
      "inputs": [
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.threads",
          "default": 32
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.suffixes_as_fraction"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.suffixes"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.seed"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.rows_to_mark"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.reference_or_index",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.packed_representation"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.only_bitpacked_files"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.large_index"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.ftab_lookup_table_size"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.discard_bitpacked_files"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.disable_diff_cover_sample"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.disable_default_parameters"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.difference_cover_period"
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_Bowtie2_Indexer_NovelJunctions.bowtie_index_archive"
        }
      ],
      "sbg:x": 3759.843329873743,
      "sbg:y": -105.33732240745704
    },
    {
      "id": "#SPORK_SplitFastaforBadFJ",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "revision 3 copied",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520433714,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 3 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520433735,
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "baseCommand": [
          "python",
          "SplitFastaforBadFJ.py"
        ],
        "outputs": [
          {
            "id": "#fusion_junction_fq2",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_2.fa",
              "sbg:metadata": {
                "paired_end": "2"
              }
            }
          },
          {
            "id": "#fusion_junction_fq1",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_1.fa",
              "sbg:metadata": {
                "paired_end": "1"
              }
            }
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1520433735,
        "id": "milos_jordanski/spachete-salzman-collaboration/splitfastaforbadfj/1",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 1,
        "temporaryFailCodes": [],
        "sbg:revision": 1,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520433714,
        "x": 4389.000671625159,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Apr 15 11:32:18 2016\n\n@author: Gillian\n\"\"\"\n\nimport argparse\nimport os\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-i\", \"--inputFasta\", required=True, help=\"fasta file for processing\")\nparser.add_argument(\"-l\", \"--ReadLength\", required=True, help=\"length of R1 and R2\")\n#parser.add_argument(\"-o\", \"--outputDir\", required=True, help=\"directory for output\")\nargs = parser.parse_args()\n\n#if args.outputDir[-1] != \"/\":\n#    args.outputDir += \"/\"\n\nbasename = os.path.basename(args.inputFasta)\n\nif basename[-3:] == \".fa\":\n    basename = basename[:-3]\nif basename[-6:] == \".fasta\":\n    basename = basename[:-6]\n\nFastaOut_R1 = open(basename + \"_1.fa\", mode=\"w\")\nFastaOut_R2 = open(basename + \"_2.fa\", mode=\"w\")\n\nFastaFile = open(args.inputFasta, mode=\"rU\")\nfor line in FastaFile:\n    if line[0] == \">\":\n        FastaOut_R1.write(line.strip() + \"\\n\")\n        FastaOut_R2.write(line.strip() + \"\\n\")\n        continue\n\n    line = line.strip().replace(\"N\", \"\")\n    FastaOut_R1.write(line[0:int(args.ReadLength)] + \"\\n\")\n    FastaOut_R2.write(line[-int(args.ReadLength):] + \"\\n\")\n\nFastaFile.close()\nFastaOut_R1.close\nFastaOut_R2.close()",
                "filename": "SplitFastaforBadFJ.py"
              }
            ]
          }
        ],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "arguments": [],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "sbg:altPrefix": "--ReadLength",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "40",
            "label": "Read length",
            "sbg:category": "Input",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-l",
              "separate": true
            },
            "id": "#read_length",
            "required": false,
            "description": "Length of each contig in the output fasta files."
          },
          {
            "sbg:altPrefix": "--inputFasta",
            "type": [
              "null",
              "File"
            ],
            "description": "Input fasta file which is going to be devided into two fasta files. First fasta file contains first read_length bases, while the second one contains last read_length bases of each FusionJunction",
            "sbg:category": "Input",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-i",
              "separate": true
            },
            "id": "#input_fasta",
            "required": false,
            "sbg:fileTypes": "FA, FASTA",
            "label": "Input fasta file"
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "input_fasta": {
              "secondaryFiles": [],
              "path": "/path/to/input_fasta.ext",
              "class": "File",
              "size": 0
            },
            "read_length": 4
          }
        },
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/splitfastaforbadfj/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/splitfastaforbadfj/1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "y": -96.98437927766776,
        "sbg:cmdPreview": "python SplitFastaforBadFJ.py",
        "stdin": "",
        "label": "SPORK SplitFastaforBadFJ"
      },
      "inputs": [
        {
          "id": "#SPORK_SplitFastaforBadFJ.read_length",
          "default": 36
        },
        {
          "id": "#SPORK_SplitFastaforBadFJ.input_fasta",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_SplitFastaforBadFJ.fusion_junction_fq2"
        },
        {
          "id": "#SPORK_SplitFastaforBadFJ.fusion_junction_fq1"
        }
      ],
      "sbg:x": 4389.000671625159,
      "sbg:y": -96.98437927766776
    },
    {
      "id": "#SPORK_Bowtie2_Indexer_Indels",
      "run": {
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
        "sbg:modifiedOn": 1520458480,
        "class": "CommandLineTool",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.tar",
              "streamable": false,
              "sbg:metadata": {
                "reference_genome": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  var ref_name = $job.inputs.reference_or_index.path.split(\"/\").pop().replace(/\\.[^/.]+$/, \"\")\n//  var inherited_name = $job.inputs.reference_or_index.metadata.reference_genome\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\" ||\n      $job.inputs.reference_or_index.metadata == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == \"\"){\n    return ref_name\n  } else{\n    return $job.inputs.reference_or_index.metadata.reference_genome\n  }\n}"
                },
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Bowtie index archive",
            "id": "#bowtie_index_archive",
            "type": [
              "File"
            ],
            "sbg:fileTypes": "TAR",
            "description": "Archived Bowtie2 index files."
          }
        ],
        "description": "Bowtie2 Indexer is a tool for indexing reference genomes of any size used in an alignment. It was built from `bowtie2-build` script and used for reference genome indexing aimed at assisting Bowtie2 in fast and memory-efficient alignment. It outputs an archive which consists of 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2. This archive constitutes the index and should be provided when aligning the reads (either with [Bowtie2 Aligner](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-aligner) or [TopHat2](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/tophat2)). \n\n###Common issues###\nNo issues have been reported.",
        "cwlVersion": "sbg:draft-2",
        "sbg:cmdPreview": "echo 'Archive provided on the input, no indexing.'",
        "successCodes": [],
        "arguments": [
          {
            "position": 101,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  index_prefix = $job.inputs.reference_or_index.path.split('.').slice(0, $job.inputs.reference_or_index.path.split('.').length-1).join('.').replace(/^.*[\\\\\\/]/, '')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"./\".concat(index_prefix)\n  }\n}"
            },
            "separate": false
          },
          {
            "position": 102,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var bt = \"bowtie2-2.3.4.1\"\n  var suffix_glob = \"\"\n  var ref = $job.inputs.reference_or_index.path\n  var ref_name = ref.split('/').pop(0).replace(/\\.[^/.]+$/, \"\")\n  var tar_name = ref_name.concat(\"_\", bt, '.tar')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  \n  if ($job.inputs.large_index) {\n    suffix_glob = \" ./*.bt2l*\"\n  } else {\n    suffix_glob = \" ./*.bt2*\"\n  }\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \" && tar -vcf \".concat(tar_name, suffix_glob)\n  }\n}"
            },
            "separate": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "sbg:validationErrors": [],
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 2,
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          }
        ],
        "sbg:revision": 2,
        "sbg:modifiedBy": "milos_jordanski",
        "baseCommand": [
          {
            "engine": "#cwl-js-engine",
            "class": "Expression",
            "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"bowtie2-build -f\"\n  } else {\n    return \"echo 'Archive provided on the input, no indexing.'\"\n  }\n}"
          }
        ],
        "stdout": "",
        "temporaryFailCodes": [],
        "sbg:createdOn": 1520444443,
        "x": 4939.667190061691,
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdin": "",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520444443,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520444463,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1520458480,
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "inputs": [
          {
            "id": "#threads",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--threads",
              "separate": true
            },
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ],
            "label": "Number of threads"
          },
          {
            "sbg:toolDefaultValue": "4",
            "label": "Suffixes as fraction",
            "sbg:category": "Advanced Options",
            "id": "#suffixes_as_fraction",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes_as_fraction\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes_as_fraction) {\n      return \"--bmaxdivn \".concat($job.inputs.suffixes_as_fraction)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "The maximum number of suffixes allowed in a block, expressed as a fraction of the length of the reference. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". This is configured automatically by default; use \"Disable default parameters\" to configure manually."
          },
          {
            "sbg:toolDefaultValue": "-",
            "label": "Suffixes",
            "sbg:category": "Advanced Options",
            "id": "#suffixes",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes) {\n      return \"--bmax \".concat($job.inputs.suffixes)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "The maximum number of suffixes allowed in a block. Allowing more suffixes per block makes indexing faster, but increases peak memory usage. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". Default (in terms of the \"Suffixes (as fraction)\" parameter) is 4. This is configured automatically by default; use \"Disable default parameters\" to configure manually."
          },
          {
            "sbg:toolDefaultValue": "-",
            "label": "Seed",
            "sbg:category": "Basic Options",
            "id": "#seed",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.seed\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--seed\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Set the seed for pseudo-random number generator."
          },
          {
            "sbg:toolDefaultValue": "5",
            "label": "Rows to mark",
            "sbg:category": "Basic Options",
            "id": "#rows_to_mark",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.rows_to_mark\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--offrate\"\n  }\n}"
              },
              "separate": false
            },
            "description": "To map alignments back to positions on the reference sequences, it is necessary to annotate (\"mark\") some or all of the Burrows-Wheeler rows with their corresponding location on the genome. \"Rows to mark\" governs how many rows get marked: the indexer will mark every 2^(given number) rows. Marking more rows makes reference-position lookups faster, but requires more memory to hold the annotations at runtime. The default is 5 (every 32nd row is marked; for human genome, annotations occupy about 340 megabytes)."
          },
          {
            "type": [
              "File"
            ],
            "sbg:fileTypes": "FASTA, FA, TAR",
            "label": "Reference/Index files",
            "sbg:category": "Input files",
            "id": "#reference_or_index",
            "required": true,
            "sbg:stageInput": "link",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "streamable": false,
              "position": 100,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return $job.inputs.reference_or_index.path\n  }\n}"
              },
              "separate": false
            },
            "description": "Reference sequence to which to align the reads. If tar bundle with indexes provided, this file would just be passed to the output."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Packed representation",
            "sbg:category": "Advanced Options",
            "id": "#packed_representation",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.packed_representation\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.packed_representation){\n      return \"--packed \".concat($job.inputs.packed_representation)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "Use a packed (2-bits-per-nucleotide) representation for DNA strings. This saves memory but makes indexing 2-3 times slower. This is configured automatically by default; set \"Disable default parameters\" to configure manually."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Only bitpacked files",
            "sbg:category": "Basic Options",
            "id": "#only_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.only_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--justref\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Build only the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Large index",
            "sbg:category": "Basic Options",
            "id": "#large_index",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.large_index\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--large-index\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Force indexer to build a large index, even if the reference is less than ~ 4 billion nucleotides inlong."
          },
          {
            "sbg:toolDefaultValue": "10",
            "label": "Ftab lookup table size",
            "sbg:category": "Basic Options",
            "id": "#ftab_lookup_table_size",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.ftab_lookup_table_size\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--ftabchars\"\n  }\n}"
              },
              "separate": false
            },
            "description": "The ftab is the lookup table used to calculate an initial Burrows-Wheeler range with respect to the first given number of characters of the query. A larger number yields a larger lookup table but faster query times. The ftab has size 4^(given number + 1) bytes. The default setting is 10 (ftab is 4MB)."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Discard bitpacked files",
            "sbg:category": "Basic Options",
            "id": "#discard_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.discard_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noref\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Do not build the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable diff-cover sample",
            "sbg:category": "Basic Options",
            "id": "#disable_diff_cover_sample",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_diff_cover_sample\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--nodc\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Disable use of the difference-cover sample. Suffix sorting becomes quadratic-time in the worst case (where the worst case is an extremely repetitive reference)."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable default parameters",
            "sbg:category": "Basic Options",
            "id": "#disable_default_parameters",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_default_parameters\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noauto\"\n  }\n}"
              },
              "separate": false
            },
            "description": "Disable the default behavior whereby indexer automatically selects values for the parameters under \"Advanced Options\" according to available memory. Instead, user may specify values for those parameters. If memory is exhausted during indexing, an error message will be printed; it is up to the user to try new parameters."
          },
          {
            "sbg:toolDefaultValue": "1024",
            "label": "Difference-cover period",
            "sbg:category": "Advanced Options",
            "id": "#difference_cover_period",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.difference_cover_period\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.difference_cover_period) {\n      return \"--dcv \".concat($job.inputs.difference_cover_period)\n    }\n  }\n}"
              },
              "separate": false
            },
            "description": "Set the period for the difference-cover sample. A larger period yields less memory overhead, but may make suffix sorting slower, especially if repeats are present. Must be a power of 2 no greater than 4096. This is configured automatically by default; use \"Disable default parameters\" to configure manually."
          }
        ],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:image_url": null,
        "sbg:job": {
          "allocatedResources": {
            "mem": 60000,
            "cpu": 1
          },
          "inputs": {
            "threads": 10,
            "difference_cover_period": 6,
            "disable_default_parameters": true,
            "large_index": false,
            "reference_or_index": {
              "metadata": {
                "reference_genome": "test"
              },
              "path": "/test/human_g1k_v37_decoy_bowtie2-2.2.6.tar",
              "secondaryFiles": []
            }
          }
        },
        "hints": [
          {
            "diskSize": null,
            "dockerImageId": "029d3a264215",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "diskSize": null,
            "value": 60000,
            "class": "sbg:MemRequirement"
          },
          {
            "value": "r3.8xlarge",
            "class": "sbg:AWSInstanceType"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -103.98440354338169,
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:toolkit": "Bowtie2",
        "label": "SPORK Bowtie2-2.3.4.1 Indexer Indels"
      },
      "inputs": [
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.threads",
          "default": 32
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.suffixes_as_fraction"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.suffixes"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.seed"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.rows_to_mark"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.reference_or_index",
          "source": [
            "#SPORK_AddIndelsToFasta_1.filtered_fusion_junction_indels"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.packed_representation"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.only_bitpacked_files"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.large_index"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.ftab_lookup_table_size"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.discard_bitpacked_files"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.disable_diff_cover_sample"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.disable_default_parameters"
        },
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.difference_cover_period"
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_Bowtie2_Indexer_Indels.bowtie_index_archive"
        }
      ],
      "sbg:x": 4939.667190061691,
      "sbg:y": -103.98440354338169,
      "scatter": "#SPORK_Bowtie2_Indexer_Indels.reference_or_index"
    },
    {
      "id": "#SPORK_Split_Fastq_Files",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "revision 6 copied",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520433867,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 6 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520433882,
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "baseCommand": [
          "python",
          "split_fastq_files.py"
        ],
        "outputs": [
          {
            "id": "#fastq_file_2",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "id": "#fastq_file_1",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1520433882,
        "id": "milos_jordanski/spachete-salzman-collaboration/split-fastq-files/1",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 1,
        "temporaryFailCodes": [],
        "sbg:revision": 1,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520433867,
        "x": 5092,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import json\nimport subprocess\nimport sys\n\njob = \"\"\nwith open('job.json') as data_file:\n    job = json.load(data_file)\n\nif \"inputs\" in job and \"fastq_files\" in job[\"inputs\"]:\n    fastq_files = job[\"inputs\"][\"fastq_files\"]\nelse:\n    fastq_files = []\n\nif len(fastq_files)!=2:\n    fastq_files = []\n\noutput_files = []\nfor f in fastq_files:\n\n    f = f[0]\n    d = {'class': 'File'}\n\n    d['path'] = f[\"path\"]\n\n    if \"size\" in f:\n        d['size'] = f[\"size\"]\n\n    if \"contents\" in f:\n        d['contents'] = f[\"contents\"]\n\n    if \"name\" in f:\n        d['name'] = f[\"name\"]\n\n    if \"checksum\" in f:\n        d['checksum'] = f[\"checksum\"]\n\n    if \"location\" in f:\n        d['location'] = f[\"location\"]\n\n    if \"metadata\" in f:\n        d['metadata'] = f[\"metadata\"]\n\n    if \"secondaryFiles\" in f:\n        d['secondaryFiles'] = f[\"secondaryFiles\"]\n\n    output_files.append(d)\n\ndata = {}\nif output_files:\n    if \"metadata\" in output_files[0] and \"paired_end\" in output_files[0][\"metadata\"] and output_files[0][\"metadata\"][\"paired_end\"]==\"1\":\n        data['fastq_file_1'] = output_files[0]\n        data['fastq_file_2'] = output_files[1]\n    else:\n        data['fastq_file_1'] = output_files[1]\n        data['fastq_file_2'] = output_files[0]\n\nwith open('cwl.output.json', 'w') as w:\n    json.dump(data, w)",
                "filename": "split_fastq_files.py"
              }
            ]
          }
        ],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "arguments": [],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#fastq_files",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false,
            "sbg:stageInput": null
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "fastq_files": [
              {
                "secondaryFiles": [],
                "path": "/path/to/fastq_files-1.ext",
                "class": "File",
                "size": 0
              },
              {
                "secondaryFiles": [],
                "path": "/path/to/fastq_files-2.ext",
                "class": "File",
                "size": 0
              }
            ]
          }
        },
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/split-fastq-files/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/split-fastq-files/1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "y": -101.984375,
        "sbg:cmdPreview": "python split_fastq_files.py",
        "stdin": "",
        "label": "SPORK Split Fastq Files"
      },
      "inputs": [
        {
          "id": "#SPORK_Split_Fastq_Files.fastq_files",
          "source": [
            "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.unaligned_reads_only"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_Split_Fastq_Files.fastq_file_2"
        },
        {
          "id": "#SPORK_Split_Fastq_Files.fastq_file_1"
        }
      ],
      "sbg:x": 5092,
      "sbg:y": -101.984375
    },
    {
      "id": "#SPORK_AddIndelsToFasta_1",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:createdBy": "jordanski.milos",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1531175690,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 1,
            "sbg:modifiedOn": 1531175826,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "baseCommand": [
          "python",
          "AddIndelsToFasta.py"
        ],
        "outputs": [
          {
            "id": "#filtered_fusion_junction_indels",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#filtered_fusion_junction",
              "glob": "*_FJ_Indels_*"
            }
          }
        ],
        "description": "",
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.filtered_fusion_junction.metadata && $job.inputs.filtered_fusion_junction.metadata.sample_id)\n   \t\tcmd = \"-s \" + $job.inputs.filtered_fusion_junction.metadata.sample_id\n\treturn cmd\n}\n\n"
            },
            "separate": true
          }
        ],
        "successCodes": [],
        "sbg:modifiedOn": 1531175826,
        "id": "milos_jordanski/spachete-salzman-collaboration/spork-addindelstofasta/1",
        "class": "CommandLineTool",
        "sbg:validationErrors": [],
        "sbg:latestRevision": 1,
        "temporaryFailCodes": [],
        "sbg:revision": 1,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1531175690,
        "x": 4795.000515924575,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Oct 21 15:17:27 2015\n\n@author: Gillian\n\"\"\"\n\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-i\", \"--infile\", required=True, help=\"input file\")\n#parser.add_argument(\"-o\", \"--outDir\", required=True, help=\"output directory\")\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\nparser.add_argument(\"-n\", \"--MaxInDel\", required=True, help=\"# of indels on each side to test\")\n\n\nargs = parser.parse_args()\n\n#if args.outDir[-1] != \"/\":\n#    args.outDir += \"/\"\n\n# indels are inserted into the FarJunction.fa file\n# insertions are SEQUENCEANNNNNSEQUENCEB where 2N is the number of indels given in the argument parser\n# deletions are SEQA-AAAAA[AAABBB]BBBSEQB where N*AAA and N*BBB are removed from the junction interface.\n# x,..,5, 4, 3, 2, 1 deletions on each side, then 2, 4, 6, 8, 10,.., 2X N's inserted into junction\n\n\ncounter = 0\nf1 = open(args.infile, mode=\"rU\")\n\nfor i in range(1, int(args.MaxInDel) + 1):\n    f1.seek(0)\n\n    fout = open(args.sample + \"_FJ_Indels_\" + str(i) + \".fa\", mode=\"w\")\n    print \"writing indels\" + str(i) + \".fa\"\n\n    for line_raw in f1:\n\n        counter += 1\n\n        if line_raw[0] == \">\":\n            JunctionName = line_raw.strip()\n            JunctionSeq = \"\"\n\n        else:\n            JunctionSeq += line_raw.strip()\n\n        if len(JunctionSeq) > 290:\n            break_point = int(JunctionName.split(\"break-point=\")[1].split(\",\")[0])\n            leftN = len(JunctionSeq) - len(JunctionSeq.lstrip(\"N\"))\n            LeftExon = JunctionSeq[0:leftN + break_point]\n            RightExon = JunctionSeq[leftN + break_point:300]\n            #        print JunctionName\n            # print JunctionSeq\n\n            fout.write(JunctionName + \"|DEL\" + str(i) + \"\\n\")\n            fout.write(LeftExon[0:-i] + RightExon[i:] + \"\\n\")\n            InsertN = \"N\" * (i * 2)\n            fout.write(JunctionName + \"|INS\" + str(i) + \"\\n\")\n            fout.write(LeftExon + InsertN + RightExon + \"\\n\")\n\n        if counter == 5000:\n            fout.flush()\n    fout.close()\n\nf1.close()",
                "filename": "AddIndelsToFasta.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "stdin": "",
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#max_indel",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-n",
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "id": "#filtered_fusion_junction",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-i",
              "separate": true
            },
            "required": false
          }
        ],
        "sbg:publisher": "sbg",
        "sbg:image_url": null,
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "max_indel": 10,
            "filtered_fusion_junction": {
              "metadata": {
                "sample_id": "sample_name"
              },
              "size": 0,
              "path": "/path/to/filtered_fusion_junction.ext",
              "class": "File",
              "secondaryFiles": []
            }
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/spork-addindelstofasta/1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -98.33338060644117,
        "label": "SPORK_AddIndelsToFasta",
        "sbg:cmdPreview": "python AddIndelsToFasta.py  -s sample_name"
      },
      "inputs": [
        {
          "id": "#SPORK_AddIndelsToFasta_1.max_indel",
          "default": 5
        },
        {
          "id": "#SPORK_AddIndelsToFasta_1.filtered_fusion_junction",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_AddIndelsToFasta_1.filtered_fusion_junction_indels"
        }
      ],
      "sbg:x": 4795.000515924575,
      "sbg:y": -98.33338060644117
    },
    {
      "id": "#SPORK_FarJuncJustNaiveReport",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "junction_length parameter added",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520433383,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 5 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520433411,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1532512528,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "baseCommand": [
          "python",
          "FarJuncJustNaiveReport.py"
        ],
        "outputs": [
          {
            "id": "#just_naive_report",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*naive_report.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n"
                }
              }
            }
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1532512528,
        "id": "milos_jordanski/spachete-salzman-collaboration/farjuncjustnaivereport/2",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 2,
        "temporaryFailCodes": [],
        "sbg:revision": 2,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520433383,
        "x": 3251,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import argparse\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\"-fusj1\", \"--fusionJuncSAM1\", required=True, help=\"unaligned reads1 to fusion junctions\")\nparser.add_argument(\"-fusj2\", \"--fusionJuncSAM2\", required=True, help=\"unaligned reads2 to fusion junctions\")\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\n\nargs = parser.parse_args()\n\nwindow = int(args.window)\njunction_length = int(args.farJunctionLength)\n\nf1_FarJunc = open(args.fusionJuncSAM1, mode = \"rB\")\nf2_FarJunc = open(args.fusionJuncSAM2, mode = \"rB\")\n\n\nprint \"opening FarJunc _1 file\"\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\nAllJunctions = {}\nAllFJRead1 = {}\n\nfor line_raw in f1_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n\n    FJ1read = ReadInfoFJ(line_raw)\n    if FJ1read.offset <= (junction_length/2 - window) and (FJ1read.offset + FJ1read.NumOfBases) >= junction_length/2 + window:\n        goodlinecounter += 1\n\n        AllFJRead1[FJ1read.ID] = 0\n        if FJ1read.junction not in AllJunctions:\n            AllJunctions[FJ1read.junction] = 0\n            newjunccounter += 1\n\n\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\noverlapwithFJ1 = 0\n\nfor line_raw in f2_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n    FJ2read = ReadInfoFJ(line_raw)\n\n    #    if FJ1read.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 409\"\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if FJ2read.ID in AllFJRead1:\n        overlapwithFJ1 += 1\n\n    else:\n        if FJ2read.offset <= (junction_length/2 - window) and (FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + window:\n            goodlinecounter += 1\n\n            if FJ2read.junction not in AllJunctions:\n                newjunccounter += 1\n                AllJunctions[FJ2read.junction] = 0\nf2_FarJunc.close()\n\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\nprint \"overlapping with FJ1 \" + str(overlapwithFJ1)\n\nfout = open(args.sample + \"_naive_report.txt\", mode=\"w\")\nfout.write(\"@Junction\\n\")\n\nfor key in AllJunctions:\n    fout.write(key + \"\\n\")",
                "filename": "FarJuncJustNaiveReport.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n"
            },
            "separate": true
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-w",
              "separate": true
            },
            "id": "#window",
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-m",
              "separate": true
            },
            "id": "#mode",
            "required": false,
            "type": [
              "null",
              {
                "name": "mode",
                "type": "enum",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--farJunctionLength",
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fjl",
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "id": "#fusion_junction_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -fusj1 \" + inputs[i].path\n        else\n          cmd += \" -fusj2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "fusion_junction_sam": [
              {
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/fusion_junction_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/fusion_junction_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "mode": "complete",
            "window": 4,
            "junction_length": 7
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/farjuncjustnaivereport/2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -106.98437499999999,
        "sbg:cmdPreview": "python FarJuncJustNaiveReport.py  -s sample_name",
        "stdin": "",
        "label": "SPORK FarJuncJustNaiveReport"
      },
      "inputs": [
        {
          "id": "#SPORK_FarJuncJustNaiveReport.window",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#SPORK_FarJuncJustNaiveReport.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#SPORK_FarJuncJustNaiveReport.junction_length",
          "default": 300
        },
        {
          "id": "#SPORK_FarJuncJustNaiveReport.fusion_junction_sam",
          "source": [
            "#SPORK_Bowtie2_2_3_4_1_Aligner.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_FarJuncJustNaiveReport.just_naive_report"
        }
      ],
      "sbg:x": 3251,
      "sbg:y": -106.98437499999999
    },
    {
      "id": "#SPORK_FarJuncNaiveReport",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "junction_length parameter added",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520433633,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 12 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520433651,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1532513542,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 3,
            "sbg:modifiedOn": 1532515924,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "baseCommand": [
          "python",
          "FarJuncNaiveReport.py"
        ],
        "outputs": [
          {
            "id": "#naive_report",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*naive_report.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n"
                }
              }
            }
          },
          {
            "id": "#IDs",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "IDs*.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n"
                }
              }
            }
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1532515924,
        "id": "milos_jordanski/spachete-salzman-collaboration/farjuncnaivereport/3",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 3,
        "temporaryFailCodes": [],
        "sbg:revision": 3,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520433633,
        "x": 4060.0816131200336,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 16:12:27 2015\n\n@author: Gillian\n\"\"\"\n# takes alignments from Far Junctions and finds read partner.\n# all Far Junction and Scrambled junction reads where the alignment does not overlap the\n# Junction by args.window bp will be thrown out.\n\n## Also creates class input files for Far Junctions (R1 = FJ, R2 = something else)\n\n# This program then tells if read partners \"makes sense\" or not\n# final Output categories -- [0] R1 junc name\n#   [1] genome - R2 location < 100mill bp away\n#   [2] genome anomaly - R2 location > 100mill bp away\n#   [3] genome p value\n#   [4] reg - R2 closest location <100mill bp away\n#   [5] reg anomaly - R2 closest location > 100 mill bp away\n#   [6] reg p value\n#   [7] junc / scrambled - R2 closest location <100mill bp away\n#   [8] junc anomaly - R2 closest location > 100mill bp away\n#   [9] junc p value\n#   [10] FarJunc - R2 aligned to same FarJunc\n#   [11] FarJunc anomaly - R2 aligned to diff FarJunc\n#   [12] FarJunc p value\n#   [13] unaligned - R2 didn't align\n#   [14] unmapped - R2 missing in action\n#   [15] P val for all non-anomaly classes\n\n\n\n################\n# Current categories\n# FJgood -- genome, reg, FJ\n# FJbad -- genome anomaly, reg anomaly, junc, junc anomaly, FJ anomaly\n#################\n\n\n\nimport argparse\nimport os\nimport glob\nfrom math import ceil\nfrom scipy.stats import poisson\nfrom collections import Counter\n\n\ndef AddToDict(inputtype, TargetDict, line_raw_comparison, line_raw_FJ):\n    lineFJ = ReadInfoFJ(line_raw_FJ)\n    #    if lineFJ.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 42\"\n    #        print inputtype\n    #        print line_raw_comparison\n    #        print line_raw_FJ\n    #\n\n    if lineFJ.junction not in TargetDict:  # add junction to target dictionary if it doesn't exist\n        TargetDict[lineFJ.junction] = [0, 0, 0.0, 0.0]\n\n    if inputtype == \"FJ\":  # if comparing Far Junc to Far Junc, they have to be identical\n        line2 = ReadInfoFJ(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        addAS = lineFJ.AS + line2.AS\n        addNumofBases = lineFJ.NumOfBases + line2.NumOfBases\n\n        if lineFJ.junction == line2.junction and lineFJ.refstrand != line2.refstrand:\n            TargetDict[lineFJ.junction][0] += 1\n            IDfiletype = \"FJgood,FarJunction\"\n        else:\n            TargetDict[lineFJ.junction][1] += 1\n            IDfiletype = \"FJbad,FarJuncAnom\"\n            addAS = 0.0\n            addNumofBases = 0.0\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"reg\" or inputtype == \"junc\":  # if reg or junc read, then one side has to be within 100KB, and meets refstrand criteria below\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if inputtype == \"junc\":\n            IDfiletype = \"FJbad,Junction\"\n            addAS = 0.0\n            addNumofBases = 0.0\n\n        if inputtype == \"reg\":\n            IDfiletype = \"FJbad,RegAnomaly\"\n            addAS = 0.0\n            addNumofBases = 0.0\n\n            if lineFJ.chr_left == line2.chr:\n                if lineFJ.strand_left == line2.strand:\n                    if lineFJ.strand_left == \"-\":\n                        if lineFJ.refstrand == line2.refstrand:\n                            if int(lineFJ.loc_left) <= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular\"\n                    elif lineFJ.strand_left == \"+\":\n                        if lineFJ.refstrand != line2.refstrand:\n                            if int(lineFJ.loc_left) >= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular\"\n            if IDfiletype == \"FJbad,RegAnomaly\":\n                if lineFJ.chr_right == line2.chr:\n                    if lineFJ.strand_right == line2.strand:\n                        if lineFJ.strand_right == \"-\":\n                            if lineFJ.refstrand == line2.refstrand:\n                                if int(lineFJ.loc_right) >= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular\"\n                        elif lineFJ.strand_right == \"+\":\n                            if lineFJ.refstrand != line2.refstrand:\n                                if int(lineFJ.loc_right) <= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular\"\n\n        if IDfiletype == \"FJgood,Regular\":\n            TargetDict[lineFJ.junction][0] += 1\n            addAS = lineFJ.AS + line2.AS\n            addNumofBases = lineFJ.NumOfBases + line2.NumOfBases\n        else:\n            TargetDict[lineFJ.junction][1] += 1\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"genome\":  # comparing FJ to genome, meet ref strand criteria (opp refstrand if + read, same refstrand if - read)\n\n        line2 = ReadInfoGenome(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.loc) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(line2.NumOfBases) + \"\\t\" + line2.chr + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"FJbad,genomAnomaly\"\n        addAS = 0.0\n        addNumofBases = 0.0\n\n        if lineFJ.chr_left == line2.chr:\n            # print \"checking left\"\n            if lineFJ.strand_left == \"-\":\n                # print \"left exon neg\"\n                if lineFJ.refstrand == line2.refstrand:\n                    # print \"left strand reference good\"\n                    if int(lineFJ.loc_left) <= int(line2.loc):\n                        # print \"left exon in expected location\"\n                        IDfiletype = \"FJgood,genome\"\n            elif lineFJ.strand_left == \"+\":\n                # print \"left exon pos\"\n                if lineFJ.refstrand != line2.refstrand:\n                    # print \"left strand good\"\n                    if int(lineFJ.loc_left) >= int(line2.loc):\n                        # print \"left strand location good\"\n                        IDfiletype = \"FJgood,genome\"\n        ## if left not the same, then compare right\n        if IDfiletype == \"FJbad,genomAnomaly\":\n            if lineFJ.chr_right == line2.chr:\n                # print \"right chromosome correct\"\n                if lineFJ.strand_right == \"-\":\n                    # print \"right exon neg\"\n                    if lineFJ.refstrand == line2.refstrand:\n                        # print \"right reference strand correct\"\n                        if int(lineFJ.loc_right) >= int(line2.loc):\n                            # print \"location correct\"\n                            IDfiletype = \"FJgood,genome\"\n                elif lineFJ.strand_right == \"+\":\n                    # print \" right strand pos\"\n                    if lineFJ.refstrand != line2.refstrand:\n                        # print \"right ref strand correct\"\n                        if int(lineFJ.loc_right) <= int(line2.loc):\n                            # print \"right exon location correct\"\n                            IDfiletype = \"FJgood,genome\"\n\n        if IDfiletype == \"FJgood,genome\":\n            TargetDict[lineFJ.junction][0] += 1\n            addAS = lineFJ.AS + line2.AS\n            addNumofBases = lineFJ.NumOfBases + line2.NumOfBases\n        else:\n            TargetDict[lineFJ.junction][1] += 1\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n        IDfile.write(line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"unaligned\":\n        if lineFJ.ID not in FJDict:\n            try:\n                TargetDict[lineFJ.junction][0] += 1\n            except:\n                print lineFJ.junction\n                print TargetDict[lineFJ.junction]\n                print line_raw_comparison\n\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        IDfiletype = \"unaligned\"\n        IDfile.write(line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\n\")\n\n    return TargetDict\n\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\n## actual MM - round up to nearest integer = X\n## expected MM  - no need to round = lambda\n## return 1- poisson.cdf(X, lambda)\n\ndef Pvalue(AS, NumBases):\n    ExpectedMMrate = 0.01\n    ExpectedMM = ExpectedMMrate * float(NumBases)\n    if NumBases == 0.0:\n        return \"-\"\n    ActualMM = int(ceil(float(AS) / (-6.0)))\n    prob = 1 - poisson.cdf(ActualMM, ExpectedMM)\n    return prob\n\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\n\nclass ReadInfoGenome:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.chr = line[2]\n        self.loc = line[3]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\nclass ReadInfoJunc:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.chr = line[2].split(\"|\")[0]\n        self.loc_1 = line[2].replace(\":\", \"|\").split(\"|\")[2]\n        self.loc_2 = line[2].replace(\":\", \"|\").split(\"|\")[4]\n        self.strand = line[2][-1]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\n# =========================================\n# start here\n\nparser = argparse.ArgumentParser()\n#parser.add_argument(\"-s\", \"--stem\", required=True, help=\"stem name of file to generate report\")\n#parser.add_argument(\"-f\", \"--FJDir\", required=True, help=\"path to aligned junction reads\")\n#parser.add_argument(\"-i\", \"--origDir\", required=True, help=\"path to orig dir containing genome reads\")\n\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-gens1\", \"--genomeSAM1\", required=True, help=\"read1 to genome\")\nparser.add_argument(\"-gens2\", \"--genomeSAM2\", required=True, help=\"read2 to genome\")\nparser.add_argument(\"-regs1\", \"--regularSAM1\", required=True, help=\"read1 to regular junction\")\nparser.add_argument(\"-regs2\", \"--regularSAM2\", required=True, help=\"read2 to regular junction\")\nparser.add_argument(\"-scrs1\", \"--scrambledSAM1\", required=True, help=\"read1 to ribosomal junction\")\nparser.add_argument(\"-scrs2\", \"--scrambledSAM2\", required=True, help=\"read2 to ribosomal junction\")\nparser.add_argument(\"-fusj1\", \"--fusionJuncSAM1\", required=True, help=\"unaligned reads1 to fusion junctions\")\nparser.add_argument(\"-fusj2\", \"--fusionJuncSAM2\", required=True, help=\"unaligned reads2 to fusion junctions\")\n\nparser.add_argument(\"-unfq1\", \"--unalignedFQ1\", required=True, help=\"unaligned reads 1\")\nparser.add_argument(\"-unfq2\", \"--unalignedFQ2\", required=True, help=\"unaligned reads 2\")\n\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\n\n\nargs = parser.parse_args()\nwindow = int(args.window)\n\njunction_length = int(args.farJunctionLength)\n\nf1_FarJunc = open(args.fusionJuncSAM1, mode = \"rB\")\nf2_FarJunc = open(args.fusionJuncSAM2, mode = \"rB\")\n\nf1_genome = open(args.genomeSAM1, mode = \"rB\")\nf2_genome = open(args.genomeSAM2, mode = \"rB\")\n\nf1_reg = open(args.regularSAM1, mode = \"rB\")\nf2_reg = open(args.regularSAM2, mode = \"rB\")\n\nf1_junc = open(args.scrambledSAM1, mode = \"rB\")\nf2_junc = open(args.scrambledSAM2, mode = \"rB\")\n\nf1_unaligned = open(args.unalignedFQ1, mode = \"rB\")\nf2_unaligned = open(args.unalignedFQ2, mode = \"rB\")\n\n\n\n\n# ID file ReadID and different buckets.\n# [0] = readID\n# [1] = R2 in genome\n# [2] = R2 in genome anomaly\n# [3] = reg\n# [4] = reg anom\n# [5] = junc\n# [6] = junc anom\n# [7] = FarJunc\n# [8] = FarJunc anom\n# [9] = unaligned\n# [10] = unmapped\n\n\n#IDfile = open(args.FJDir + \"reports/temp_IDs_\" + stem + \".txt\", mode=\"w\")\nIDfile = open(\"temp_IDs_\" + args.sample + \".txt\", mode=\"w\")\n\nIDfile.write(\n    \"ID\\tclass\\tR1_offset\\tR1_MAPQ\\tR1_adjAS\\tR1_NumN\\tR1_Readlength\\tR1_JuncName\\tR1_strand\\tR2_offset\\tR2_MAPQ\\tR2_adjAS\\tR2_NumN\\tR2_Readlength\\tR2_JuncName\\tR2_strand\\n\")\n\n# populate all reads and junctions into separate dictionaries\nAllFJRead1 = {}\nAllFJRead2 = {}\nAllJunctions = {}\ngenomeDict = {}  # for all these dictionaries, [0] = reg, [1] = anom\nregDict = {}  # [2] = sum of AS, [3] = read length\njuncDict = {}\nFJDict = {}\nunalignedDict = {}\nunmappedDict = {}  # start with all readIDs.  if a partner is seen, then remove from list.\n\n# populate AllFJRead1 dictionary - all read 1's from FarJunction alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening FarJunc _1 file\"\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\n\nfor line_raw in f1_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n\n    FJ1read = ReadInfoFJ(line_raw)\n    if FJ1read.offset <= (junction_length/2 - window) and (FJ1read.offset + FJ1read.NumOfBases) >= junction_length/2 + window:\n        goodlinecounter += 1\n        # Dict AllFJRead1 contains key = read ID of all FJ R1\n        # Value = [ FJ read info, indicator of which library the R2 is in]\n        # indicator = 0 if no R2 detected\n        # indicator = FJ if R2 in FJ, genome if R2 in genome, reg if r2 in reg, etc...\n        AllFJRead1[FJ1read.ID] = [line_raw, 0]\n        if FJ1read.junction not in AllJunctions:\n            AllJunctions[FJ1read.junction] = 0\n            newjunccounter += 1\n        AllJunctions[FJ1read.junction] += 1\n        unmappedDict[FJ1read.ID] = FJ1read.junction\n\nf1_FarJunc.close()\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\n\nIDfile.flush()\n\n# populate AllFJRead2 dictionary - all read 2's from FarJunc alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening farJunc _2 file\"\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\noverlapwithFJ1 = 0\n\nfor line_raw in f2_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n    FJ2read = ReadInfoFJ(line_raw)\n\n    #    if FJ1read.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 409\"\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if FJ2read.ID in AllFJRead1:\n        overlapwithFJ1 += 1\n        # print \"found FJ read\"\n        # AllFJRead1[FJ2read.ID][1]=\"FJ\"\n        if FJ2read.offset <= (junction_length/2 - window) and (FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + window and \\\n                        AllFJRead1[FJ2read.ID][1] == 0:\n            FJDict = AddToDict(\"FJ\", FJDict, line_raw, AllFJRead1[FJ2read.ID][0])\n\n            AllFJRead1[FJ2read.ID][1] = \"FJ\"\n            if FJ2read.ID in unmappedDict:\n                del unmappedDict[FJ2read.ID]\n                # otherwise add to F2 read\n    else:\n        if FJ2read.offset <= (junction_length/2 - window) and (FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + window:\n            goodlinecounter += 1\n            AllFJRead2[FJ2read.ID] = [line_raw, 0]\n            unmappedDict[FJ2read.ID] = FJ2read.junction\n            if FJ2read.junction not in AllJunctions:\n                newjunccounter += 1\n                AllJunctions[FJ2read.junction] = 0\n\n            AllJunctions[FJ2read.junction] += 1\nf2_FarJunc.close()\n\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\nprint \"overlapping with FJ1 \" + str(overlapwithFJ1)\nIDfile.flush()\n\n# compare FJ read 1 to genome read 2\nfor line_raw in f2_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g2read = ReadInfoGenome(line_raw)\n\n    if g2read.ID in AllFJRead1 and AllFJRead1[g2read.ID][1] == 0:\n        # print \"found genome R2\"+ g2read.ID\n        if g2read.ID in unmappedDict:\n            del unmappedDict[g2read.ID]\n        genomeDict = AddToDict(\"genome\", genomeDict, line_raw, AllFJRead1[g2read.ID][0])\n        AllFJRead1[g2read.ID][1] = \"genome\"\n\nf2_genome.close()\nIDfile.flush()\n\n# compare FJ read 2 to genome read 1\n\nfor line_raw in f1_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g1read = ReadInfoGenome(line_raw)\n\n    if g1read.ID in AllFJRead2 and AllFJRead2[g1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        if g1read.ID in unmappedDict:\n            del unmappedDict[g1read.ID]\n        genomeDict = AddToDict(\"genome\", genomeDict, line_raw, AllFJRead2[g1read.ID][0])\n        AllFJRead2[g1read.ID][1] = \"genome\"\nf1_genome.close()\nIDfile.flush()\n\n# compare FJ read 1 to reg read 2\nfor line_raw in f2_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg2read = ReadInfoJunc(line_raw)\n\n    if reg2read.offset <= (junction_length/2 - window) and (reg2read.offset + reg2read.NumOfBases) >= (junction_length/2 + window):\n        if reg2read.ID in AllFJRead1:\n            if AllFJRead1[reg2read.ID][1] == 0 or AllFJRead1[reg2read.ID][1] == \"genome\":\n                # print \"found reg R2\" + reg2read.ID\n                if reg2read.ID in unmappedDict:\n                    del unmappedDict[reg2read.ID]\n                regDict = AddToDict(\"reg\", regDict, line_raw, AllFJRead1[reg2read.ID][0])\n                AllFJRead1[reg2read.ID][1] = \"reg\"\nf2_reg.close()\nIDfile.flush()\n\n# compare FJ read 2 to reg read 1\n\nfor line_raw in f1_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg1read = ReadInfoJunc(line_raw)\n\n    if reg1read.offset <= (junction_length/2 - window) and (reg1read.offset + reg1read.NumOfBases) >= (junction_length/2 + window):\n        if reg1read.ID in AllFJRead2:\n            if AllFJRead2[reg1read.ID][1] == 0 or AllFJRead2[reg1read.ID][1] == \"genome\":\n                # print \"found reg R1: \" + reg1read.ID\n                if reg1read.ID in unmappedDict:\n                    del unmappedDict[reg1read.ID]\n                regDict = AddToDict(\"reg\", regDict, line_raw, AllFJRead2[reg1read.ID][0])\n                AllFJRead2[reg1read.ID][1] = \"reg\"\nf1_reg.close()\nIDfile.flush()\n\n# compare FJ read 1 to junc read 2\nfor line_raw in f2_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc2read = ReadInfoJunc(line_raw)\n\n    if junc2read.offset <= (junction_length/2 - window) and (junc2read.offset + junc2read.NumOfBases) >= (junction_length/2 + window):\n        if junc2read.ID in AllFJRead1 and AllFJRead1[junc2read.ID][1] == 0:\n            # print \"found junc R2 \" + junc2read.ID\n            if junc2read.ID in unmappedDict:\n                del unmappedDict[junc2read.ID]\n            juncDict = AddToDict(\"junc\", juncDict, line_raw, AllFJRead1[junc2read.ID][0])\n            AllFJRead1[junc2read.ID][1] = \"junc\"\nf2_junc.close()\nIDfile.flush()\n\n# compare FJ read 2 to junc read 1\nfor line_raw in f1_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc1read = ReadInfoJunc(line_raw)\n\n    if junc1read.offset <= (junction_length/2 - window) and (junc1read.offset + junc1read.NumOfBases) >= (junction_length/2 + window):\n        if junc1read.ID in AllFJRead2 and AllFJRead2[junc1read.ID][1] == 0:\n            # print \"found junc R1: \" + junc1read.ID\n            if junc1read.ID in unmappedDict:\n                del unmappedDict[junc1read.ID]\n            juncDict = AddToDict(\"junc\", juncDict, line_raw, AllFJRead2[junc1read.ID][0])\n            AllFJRead2[junc1read.ID][1] = \"junc\"\nf1_junc.close()\nIDfile.flush()\n\n# compare FJ read 1 to unaligned read 2\n\nfor line_raw in f2_unaligned:\n    if line_raw[0] == \"@\":\n        readID = line_raw.strip().split(\" \")[0][1:]\n        readID = ID(readID)\n        if readID in AllFJRead1 and AllFJRead1[readID][1] == 0:\n            if readID in unmappedDict:\n                del unmappedDict[readID]\n            unalignedDict = AddToDict(\"unaligned\", unalignedDict, line_raw, AllFJRead1[readID][0])\n            AllFJRead1[readID][1] = \"unaligned\"\nf2_unaligned.close()\nIDfile.flush()\n\n# compare FJ read 2 to unaligned read 1\n\nfor line_raw in f1_unaligned:\n    if line_raw[0] == \"@\":\n        readID = line_raw.strip().split(\" \")[0][1:]\n        readID = ID(readID)\n        if readID in AllFJRead2 and AllFJRead2[readID][1] == 0:\n            if readID in unmappedDict:\n                del unmappedDict[readID]\n            unalignedDict = AddToDict(\"unaligned\", unalignedDict, line_raw, AllFJRead2[readID][0])\n            AllFJRead2[readID][1] = \"unaligned\"\nf1_unaligned.close()\nIDfile.flush()\n\n# output header\n#outputfile = \"reports/\" + stem + \"_naive_report.txt\"\n#fout = open(args.FJDir + outputfile, mode=\"w\")\n#print \"fout: \" + args.FJDir + outputfile\n\nfout = open(args.sample + \"_naive_report.txt\", mode=\"w\")\n\nfout.write(\"@Junction\\tgenome\\tgenome-anomaly\\tgenome-pval\\treg\\treg-anomaly\\treg-pval\\tjunc\\tjunc-anom\\tjunc-pval\\tFarJunc\\tFarJunc-anom\\tFarJunc-pval\\tunaligned\\tNoPartner\\tNetPValue\\n\")\n\nfor key in unmappedDict:\n    IDfile.write(key + \"\\t\" + unmappedDict[key] + \"\\tUnmapped\\n\")\nIDfile.close()\n#\n#\n### TESTING MODE - SEE WHAT ALLFJREAD1 and 2 FILE SHOW\n# AllReadOutfile=open(\"AllJuncDict.txt\", mode=\"w\")\n#\n# AllReadOutfile.write(\"AllFJRead1:\\n\")\n#\n# for key in AllFJRead1:\n#    AllReadOutfile.write(key+\"\\t\"+str(AllFJRead1[key][1])+\"\\n\")\n#\n#\n# AllReadOutfile.write(\"AllFJRead2:\\n\")\n#\n# for key in AllFJRead2:\n#    AllReadOutfile.write(key+\"\\t\"+str(AllFJRead2[key][1])+\"\\n\")\n#\n# AllReadOutfile.close()\n#\n\n\n## WRITE ALL JUNCTIONS\nfor key in AllJunctions:\n\n    for dict in [genomeDict, regDict, juncDict, FJDict, unalignedDict]:\n        if key not in dict:\n            dict[key] = [0, 0, 0.0, 0.0]\n\n    NumUnmapped = Counter(unmappedDict.values())[key]\n    # calculates P value for all genome/reg/junc/FJ dicts combined, excluding all anomalous reads\n    NetAS = genomeDict[key][2] + regDict[key][2] + juncDict[key][2] + FJDict[key][2]\n    NetNumBases = genomeDict[key][3] + regDict[key][3] + juncDict[key][3] + FJDict[key][3]\n    NetP = Pvalue(NetAS, NetNumBases)\n\n    # writing to output file\n    fout.write(key + \"\\t\")  # write junction [0]\n    fout.write(str(genomeDict[key][0]) + \"\\t\")  # [1]  number of make-sense maps in genome\n    fout.write(str(genomeDict[key][1]) + \"\\t\")  # [2]  nonsense maps in genome\n    fout.write(str(Pvalue(genomeDict[key][2], genomeDict[key][3])) + \"\\t\")  # [3] p value for genome reads\n    fout.write(str(regDict[key][0]) + \"\\t\")  # [4]  number of make-sense maps in reg\n    fout.write(str(regDict[key][1]) + \"\\t\")  # [5]  nonsense maps in reg\n    fout.write(str(Pvalue(regDict[key][2], regDict[key][3])) + \"\\t\")  # [6] p value for reg reads\n    fout.write(str(juncDict[key][0]) + \"\\t\")  # [7]  number of make-sense maps in junc\n    fout.write(str(juncDict[key][1]) + \"\\t\")  # [8]  nonsense maps in junc\n    fout.write(str(Pvalue(juncDict[key][2], juncDict[key][3])) + \"\\t\")  # [9] p value for junc reads\n    fout.write(str(FJDict[key][0]) + \"\\t\")  # [10]  number of make-sense maps in FJ\n    fout.write(str(FJDict[key][1]) + \"\\t\")  # [11]  nonsense maps in FJ\n    fout.write(str(Pvalue(FJDict[key][2], FJDict[key][3])) + \"\\t\")  # [12] p value for FJ reads\n    fout.write(str(unalignedDict[key][0]) + \"\\t\")  # [13]  number junctions whose partner was unaligned\n    fout.write(str(NumUnmapped) + \"\\t\")  # [14] - no read partner in any of the files.\n    fout.write(str(NetP) + \"\\n\")  # [15] net P value of all non-anomalous reads\nfout.close()\n\n# takes alignments from Far Junctions and finds read partner.\n# tells if read partner makes sense or not\n# final Output categories -- [0] R1 junc name\n#   [1] genome - R2 location < 100mill bp away\n#   [2] genome anomaly - R2 location > 100mill bp away\n#   [3] genome p value\n#   [4] reg - R2 closest location <100mill bp away\n#   [5] reg anomaly - R2 closest location > 100mill bp away\n#   [6] reg p value\n#   [7] junc / scrambled - R2 closest location <100mill bp away\n#   [8] junc anomaly - R2 closest location > 100mill bp away\n#   [9] junc p value\n#   [10] FarJunc - R2 aligned to same FarJunc\n#   [11] FarJunc anomaly - R2 aligned to diff FarJunc\n#   [12] FarJunc p value\n#   [13] unaligned - R2 didn't align\n#   [14] unmapped - R2 missing\n#  [15] P value for all non-anomaly classes\n\n\n\n\n#############################################################################\n## This section of code takes the written ID file above (temp_IDs_STEM.txt) and\n## removes duplicate entries of genome and reg. The same readID may be found\n## in both libraries and would both be in the ID file.\n## The new ID file removes duplicates and only keeps the readID with the\n## best alignment score.\ntempIDfile = open(\"temp_IDs_\" + args.sample + \".txt\", mode=\"rU\")\nnewIDfile = open(\"IDs_\" + args.sample + \".txt\", mode=\"w\")\n\n##grep col 2 for \"genom\", \"Regular\" or \"RegAnomaly\". if not found ,write to\n## new file immediately.\n## if found, feed into dictionary (key=readID, value= entire line from temp file)\n## if duplicate entry, then compare R2 AS. if AS larger, then replace\n## value with new value from new R2\n## at completion of file, write entire dictionary into new ID file.\n\nGenomeAndRegReadIDs = {}\n\nfor line in tempIDfile:\n    line = line.strip()\n    if \"unaligned\" in line:\n        continue\n\n    if \"Unmapped\" in line:\n        continue\n\n    readID = line.split(\"\\t\")[0]\n    classID = line.split(\"\\t\")[1]\n    AS_new = line.split(\"\\t\")[11]\n\n    if \"genom\" in classID:\n        ## if readID has been seen previously, then replace value in dictionary\n        ## only if AS is greater.\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"Regular\" in classID:\n        ## do the same if reg\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"RegAnomaly\" in classID:\n        ## do the same if reg anomaly\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    else:\n        ## if not genome/genome anomaly/ reg/ reg anomaly then\n        ## write line directly in new file.\n        newIDfile.write(line + \"\\n\")\n\nfor entry in GenomeAndRegReadIDs:\n    newIDfile.write(GenomeAndRegReadIDs[entry] + \"\\n\")\n\ntempIDfile.close()\nnewIDfile.close()",
                "filename": "FarJuncNaiveReport.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n"
            },
            "separate": true
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-w",
              "separate": true
            },
            "id": "#window",
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "id": "#unaligned_fq",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.unaligned_fq)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -unfq1 \" + inputs[i].path\n        else\n          cmd += \" -unfq2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "id": "#scrambled_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "id": "#regular_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-m",
              "separate": true
            },
            "id": "#mode",
            "required": false,
            "type": [
              "null",
              {
                "name": "mode",
                "type": "enum",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--farJunctionLength",
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fjl",
              "separate": true
            },
            "sbg:stageInput": null,
            "required": false
          },
          {
            "id": "#genome_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "id": "#fusion_junction_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -fusj1 \" + inputs[i].path\n        else\n          cmd += \" -fusj2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "fusion_junction_sam": [
              {
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/fusion_junction_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/fusion_junction_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "regular_sam": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/regular_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/regular_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "scrambled_sam": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/scambled_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/scambled_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "genome_sam": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/genome_sam_files-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/genome_sam_files-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "unaligned_fq": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/unaligned_fq-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/unaligned_fq-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "mode": "complete",
            "window": 7,
            "junction_length": 0
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/farjuncnaivereport/3",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -101.02351288094121,
        "sbg:cmdPreview": "python FarJuncNaiveReport.py  -s sample_name",
        "stdin": "",
        "label": "SPORK FarJuncNaiveReport",
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/farjuncnaivereport/3"
      },
      "inputs": [
        {
          "id": "#SPORK_FarJuncNaiveReport.window",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#SPORK_FarJuncNaiveReport.unaligned_fq",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq",
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#SPORK_FarJuncNaiveReport.scrambled_sam",
          "source": [
            "#getUnalignedReads_2.mate_scrambled_sam",
            "#getUnalignedReads_1.mate_scrambled_sam"
          ]
        },
        {
          "id": "#SPORK_FarJuncNaiveReport.regular_sam",
          "source": [
            "#getUnalignedReads_2.mate_regular_sam",
            "#getUnalignedReads_1.mate_regular_sam"
          ]
        },
        {
          "id": "#SPORK_FarJuncNaiveReport.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#SPORK_FarJuncNaiveReport.junction_length",
          "default": 300
        },
        {
          "id": "#SPORK_FarJuncNaiveReport.genome_sam",
          "source": [
            "#getUnalignedReads_1.mate_genome_sam",
            "#getUnalignedReads_2.mate_genome_sam"
          ]
        },
        {
          "id": "#SPORK_FarJuncNaiveReport.fusion_junction_sam",
          "source": [
            "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_FarJuncNaiveReport.naive_report"
        },
        {
          "id": "#SPORK_FarJuncNaiveReport.IDs"
        }
      ],
      "sbg:x": 4060.0816131200336,
      "sbg:y": -101.02351288094121
    },
    {
      "id": "#SPORK_MakeIndelsHisto",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "junction_length parameter added",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520433939,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 5 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520433966,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1532513116,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "baseCommand": [
          "python",
          "MakeIndelsHisto.py"
        ],
        "outputs": [
          {
            "id": "#indels_txt",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "outputBinding": {
              "glob": "indels*.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n"
                }
              }
            }
          },
          {
            "id": "#all_indels_sam_2",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "All*_2_indels.sam",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n"
                }
              }
            }
          },
          {
            "id": "#all_indels_sam_1",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "All*_1_indels.sam",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n"
                }
              }
            }
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1532513116,
        "id": "milos_jordanski/spachete-salzman-collaboration/makeindelshisto/2",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 2,
        "temporaryFailCodes": [],
        "sbg:revision": 2,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520433939,
        "x": 5385.058974939235,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Mar 25 15:25:42 2016\n\n@author: Gillian\n\"\"\"\n\nimport argparse\nimport glob\n\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        if self.junction[-4:-1] == \"DEL\":\n            self.indel = -int(self.junction[-1:])\n        elif self.junction[-4:-1] == \"INS\":\n            self.indel = int(self.junction[-1:])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n        else:\n            self.NumN = line[12][5:]\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"file sample name\")\n#parser.add_argument(\"-f\", \"--FJDir\", required=True, help=\"FJ directory\")\nparser.add_argument(\"-w\", \"--overlap\", required=True, help=\"required overlapping nt on each side of junction, including # indels\")\nparser.add_argument(\"-x\", \"--NumIndels\", required=True, help=\"number of indels allowed from previous file\")\nparser.add_argument(\"-ufj1\", \"--unaligned_to_FJ_1\", required=True, help=\"unaligned read1 from KNIFE aligned to FJ\")\nparser.add_argument(\"-ufj2\", \"--unaligned_to_FJ_2\", required=True, help=\"unaligned read2 from KNIFE aligned to FJ\")\nparser.add_argument(\"-sufji1\", \"--still_unaligned_to_FJIndels_1\", nargs='+', required=True, help=\"still unaligned read1 aligned to FJIndels1\")\nparser.add_argument(\"-sufji2\", \"--still_unaligned_to_FJIndels_2\", nargs='+', required=True, help=\"still unaligned read2 aligned to FJIndels2\")\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\n\njunction_length = int(args.farJunctionLength)\n\n#if args.FJDir[-1] != \"/\":\n#    args.FJDir += \"/\"\n\n#\n### make a concatenated list of all the far junction alignment files\n\n#\n# input_lines=fileinput.input(FJ1_list)\n# fout_FJ1.writelines(input_lines)\n# input_lines=fileinput.input(FJ2_list)\n# fout_FJ2.writelines(input_lines)\n#\n# fout_FJ1.close()\n# fout_FJ2.close()\n\n\n## now go through all primary alignments and make a dictionary of possible far juncs:\n\nFJDict_1 = {}  ## key = junc name, Val = # [0,0,0,0,X,0,0,0,0]  0's # of indels\nFJDict_2 = {}\n\n#FJFile1 = sorted(glob.glob(args.FJDir + \"FarJunctionAlignments/\" + args.stem + \"/*.sam\"))[0]\n#FJFile2 = sorted(glob.glob(args.FJDir + \"FarJunctionAlignments/\" + args.stem + \"/*.sam\"))[1]\n\nFJFile1 = args.unaligned_to_FJ_1\nFJFile2 = args.unaligned_to_FJ_2\n\nf1 = open(FJFile1, mode=\"rU\")\nprint \"opening\" + FJFile1\n\nlinecount = 0\ngoodlinecount = 0\nnewjunc = 0\nfor line_raw in f1:\n    if line_raw[0] == \"@\":\n        continue\n    linecount += 1\n    FJread = ReadInfoFJ(line_raw)\n    if FJread.offset <= (junction_length/2 - int(args.overlap)) and FJread.offset + FJread.NumOfBases >= (junction_length/2 + int(args.overlap)):\n        if FJread.junction not in FJDict_1:\n            FJDict_1[FJread.junction] = [0] * (2 * int(args.NumIndels) + 1)\n            newjunc += 1\n        FJDict_1[FJread.junction][int(args.NumIndels)] += 1\n        goodlinecount += 1\nf1.close()\nprint \"new junc added\" + str(newjunc)\nprint linecount\nprint goodlinecount\n\nlinecount = 0\ngoodlinecount = 0\nnewjunc = 0\n\nf2 = open(FJFile2, mode=\"rU\")\nprint \"opening\" + FJFile2\nfor line_raw in f2:\n    if line_raw[0] == \"@\":\n        continue\n    FJread = ReadInfoFJ(line_raw)\n    linecount += 1\n    if FJread.offset <= (junction_length/2 - int(args.overlap)) and FJread.offset + FJread.NumOfBases >= (junction_length/2 + int(args.overlap)):\n        if FJread.junction not in FJDict_2:\n            FJDict_2[FJread.junction] = [0] * (2 * int(args.NumIndels) + 1)\n            newjunc += 1\n\n        FJDict_2[FJread.junction][int(args.NumIndels)] += 1\n        goodlinecount += 1\nf2.close()\nprint \"new junc added\" + str(newjunc)\nprint linecount\nprint goodlinecount\n\n## make a dictionary of readIDs that aligned to any FJ indel\n\n\n\nAlignedFJFiles = []\n\n#for name in glob.glob(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/*.sam\"):\n#    if \"All_\" not in name:\n#        AlignedFJFiles.append(name)\n\n\n#FJ1_list = sorted(AlignedFJFiles)[0:len(AlignedFJFiles) / 2]\n#FJ2_list = sorted(AlignedFJFiles)[len(AlignedFJFiles) / 2:]\n\nFJ1_list = args.still_unaligned_to_FJIndels_1\nFJ2_list = args.still_unaligned_to_FJIndels_2\n\n#\n# print \"FJ1 indels list\"\n# print FJ1_list\n# print \"FJ2 indels list\"\n# print FJ2_list\n\nIndelsReadIDs = {}\n\nfor name in FJ1_list:\n    print \"FJ1 indels\"\n    print name\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoFJ(line)\n        # if the read overlaps the junction\n        if read.offset <= (junction_length/2 - int(args.overlap) + read.indel) and read.offset + read.NumOfBases >= (junction_length/2 + int(args.overlap) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoFJ(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\n#fout_FJ1 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_1_indels.sam\", mode=\"w\")\nfout_FJ1 = open(\"All_\" + args.sample + \"_1_indels.sam\", mode = \"w\")\n\nfor key in IndelsReadIDs:\n    fout_FJ1.write(IndelsReadIDs[key].strip() + \"\\n\")\nfout_FJ1.close()\n\n## CLEAR Read IDs dictionary and do the same with FJ2 list\nIndelsReadIDs = {}\n\nfor name in FJ2_list:\n    print \"FJ2 indels\"\n    print name\n\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoFJ(line)\n        # if the read overlaps the junction\n        if read.offset <= (junction_length/2 - int(args.overlap) + read.indel) and read.offset + read.NumOfBases >= (junction_length/2 + int(args.overlap) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoFJ(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\n#fout_FJ2 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_2_indels.sam\", mode=\"w\")\nfout_FJ2 = open(\"All_\" + args.sample + \"_2_indels.sam\", mode = \"w\")\n\nfor key in IndelsReadIDs:\n    fout_FJ2.write(IndelsReadIDs[key].strip() + \"\\n\")\nfout_FJ2.close()\n\n## parse AllIndels_1 and AllIndels_2 files to see if they aligned to the same juncs with indels as an FJ\n## if yes, then add to junction \"dictionary\"\n\n#Indels1 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_1_indels.sam\", mode=\"rU\")\nIndels1 = open(\"All_\" + args.sample + \"_1_indels.sam\", mode=\"rU\")\n\nfor line in Indels1:\n    read = ReadInfoFJ(line)\n    if read.junction[:-5] in FJDict_1:\n        FJDict_1[read.junction[:-5]][int(args.NumIndels) + read.indel] += 1\nIndels1.close()\n\n#Indels2 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_2_indels.sam\", mode=\"rU\")\nIndels2 = open(\"All_\" + args.sample + \"_2_indels.sam\", mode=\"rU\")\n\nfor line in Indels2:\n    read = ReadInfoFJ(line)\n    if read.junction[:-5] in FJDict_2:\n        FJDict_2[read.junction[:-5]][int(args.NumIndels) + read.indel] += 1\nIndels2.close()\n\n## output indels histo\n\n#Outfile1 = open(args.FJDir + \"IndelsHistogram/indels_\" + args.stem + \"_1.txt\", mode=\"w\")\nOutfile1 = open(\"indels_\" + args.sample + \"_1.txt\", mode=\"w\")\n\nfor key in FJDict_1:\n    Outfile1.write(key + \"\\t\" + str(FJDict_1[key]) + \"\\n\")\nOutfile1.close()\n\n#Outfile2 = open(args.FJDir + \"IndelsHistogram/indels_\" + args.stem + \"_2.txt\", mode=\"w\")\nOutfile2 = open(\"indels_\" + args.sample + \"_2.txt\", mode=\"w\")\n\nfor key in FJDict_2:\n    Outfile2.write(key + \"\\t\" + str(FJDict_2[key]) + \"\\n\")\nOutfile2.close()",
                "filename": "MakeIndelsHisto.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n"
            },
            "separate": true
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#unaligned_to_FJ",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -ufj1 \" + inputs[i].path\n        else\n          cmd += \" -ufj2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "id": "#still_unaligned_to_FJIndels_2",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-sufji2",
              "separate": true,
              "itemSeparator": " "
            },
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "id": "#still_unaligned_to_FJIndels_1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-sufji1",
              "separate": true,
              "itemSeparator": " "
            },
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-w",
              "separate": true
            },
            "id": "#overlap",
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "id": "#num_indels",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-x",
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-m",
              "separate": true
            },
            "id": "#mode",
            "required": false,
            "type": [
              "null",
              {
                "name": "mode",
                "type": "enum",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--farJunctionLength",
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fjl",
              "separate": true
            },
            "sbg:stageInput": null
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "still_unaligned_to_FJIndels_1": [
              {
                "secondaryFiles": [],
                "path": "/path/to/still_unaligned_to_FJIndels_1-1.ext",
                "class": "File",
                "size": 0
              },
              {
                "secondaryFiles": [],
                "path": "/path/to/still_unaligned_to_FJIndels_1-2.ext",
                "class": "File",
                "size": 0
              }
            ],
            "num_indels": 10,
            "still_unaligned_to_FJIndels_2": [
              {
                "secondaryFiles": [],
                "path": "/path/to/still_unaligned_to_FJIndels_2-1.ext",
                "class": "File",
                "size": 0
              },
              {
                "secondaryFiles": [],
                "path": "/path/to/still_unaligned_to_FJIndels_2-2.ext",
                "class": "File",
                "size": 0
              }
            ],
            "unaligned_to_FJ": [
              {
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/unaligned_to_FJ-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/unaligned_to_FJ-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "overlap": 2,
            "mode": "complete",
            "junction_length": 6
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/makeindelshisto/2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -101.16084839272149,
        "sbg:cmdPreview": "python MakeIndelsHisto.py  -s sample_name",
        "stdin": "",
        "label": "SPORK MakeIndelsHisto"
      },
      "inputs": [
        {
          "id": "#SPORK_MakeIndelsHisto.unaligned_to_FJ",
          "source": [
            "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.result_sam_file"
          ]
        },
        {
          "id": "#SPORK_MakeIndelsHisto.still_unaligned_to_FJIndels_2",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.result_sam_file"
          ]
        },
        {
          "id": "#SPORK_MakeIndelsHisto.still_unaligned_to_FJIndels_1",
          "source": [
            "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.result_sam_file"
          ]
        },
        {
          "id": "#SPORK_MakeIndelsHisto.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#SPORK_MakeIndelsHisto.num_indels",
          "default": 5
        },
        {
          "id": "#SPORK_MakeIndelsHisto.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#SPORK_MakeIndelsHisto.junction_length",
          "default": 300
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_MakeIndelsHisto.indels_txt"
        },
        {
          "id": "#SPORK_MakeIndelsHisto.all_indels_sam_2"
        },
        {
          "id": "#SPORK_MakeIndelsHisto.all_indels_sam_1"
        }
      ],
      "sbg:x": 5385.058974939235,
      "sbg:y": -101.16084839272149
    },
    {
      "id": "#SPORK_FJIndels_ClassIDFile",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "junction_length parameter added",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520434004,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 7 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520434028,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1532513049,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "baseCommand": [
          "python",
          "FJIndels_ClassIDFile.py"
        ],
        "outputs": [
          {
            "id": "#temp_output_FJIndels",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_temp_output_FJIndels.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n"
                }
              }
            }
          },
          {
            "id": "#output_FJIndels",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*__output_FJIndels.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n"
                }
              }
            }
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1532513049,
        "id": "milos_jordanski/spachete-salzman-collaboration/fjindels-classidfile/2",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 2,
        "temporaryFailCodes": [],
        "sbg:revision": 2,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520434004,
        "x": 5537.158913022628,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 16:12:27 2015\n\n@author: Gillian\n\"\"\"\n# takes alignments from Indels and finds read partner.\n# all Far Junction and Scrambled junction reads where the alignment does not overlap the\n# Junction by args.window bp will be thrown out.\n\n# This program then tells if read partners \"makes sense\" or not\n# final Output categories -- [0] R1 junc name\n#   [1] genome - R2 location < 100mill bp away\n#   [2] genome anomaly - R2 location > 100mill bp away\n#   [3] genome p value\n#   [4] reg - R2 closest location <100mill bp away\n#   [5] reg anomaly - R2 closest location > 100 mill bp away\n#   [6] reg p value\n#   [7] junc / scrambled - R2 closest location <100mill bp away\n#   [8] junc anomaly - R2 closest location > 100mill bp away\n#   [9] junc p value\n#   [10] FarJunc - R2 aligned to same FarJunc\n#   [11] FarJunc anomaly - R2 aligned to diff FarJunc\n#   [12] FarJunc p value\n#   [13] unaligned - R2 didn't align\n#   [14] unmapped - R2 missing in action\n#   [15] P val for all non-anomaly classes\n\n\n\n################\n# Current categories\n# FJgood -- genome, reg, FJ\n# FJbad -- genome anomaly, reg anomaly, junc, junc anomaly, FJ anomaly\n#################\n\n\n\nimport argparse\nimport os\nimport glob\n\n\ndef AddToDict(inputtype, line_raw_comparison, line_raw_FJ):\n    lineFJ = ReadInfoFJ(line_raw_FJ)\n\n    if inputtype == \"FJ\":  # if comparing Far Junc to Far Junc, they have to be identical\n        line2 = ReadInfoFJ(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction[\n                                                                                        :-5] + \"\\t\" + lineFJ.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if lineFJ.junction == line2.junction and lineFJ.refstrand in [\"0\", \"16\"] and line2.refstrand in [\"0\",\n                                                                                                         \"16\"] and lineFJ.refstrand != line2.refstrand:\n            #            TargetDict[lineFJ.junction][0] +=1\n            IDfiletype = \"FJgood,FarJunction,\" + lineFJ.junction[-4:]\n        else:\n            #            TargetDict[lineFJ.junction][1]+=1\n            IDfiletype = \"FJbad,FarJuncAnom,\" + lineFJ.junction[-4:]\n        # addAS = 0.0\n        #            addNumofBases = 0.0\n        #\n        #        TargetDict[lineFJ.junction][2] += addAS\n        #        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"reg\" or inputtype == \"junc\":  # if reg or junc read and meets refstrand criteria below\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction[\n                                                                                        :-5] + \"\\t\" + lineFJ.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if inputtype == \"junc\":\n            IDfiletype = \"FJbad,Junction,\" + lineFJ.junction[-4:]\n\n        if inputtype == \"reg\":\n            IDfiletype = \"FJbad,RegAnomaly,\" + lineFJ.junction[-4:]\n\n            if lineFJ.chr_left == line2.chr:\n                if lineFJ.strand_left == line2.strand:\n                    if lineFJ.strand_left == \"-\":\n                        if lineFJ.refstrand == line2.refstrand:\n                            if int(lineFJ.loc_left) <= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n                    elif lineFJ.strand_left == \"+\":\n                        if lineFJ.refstrand != line2.refstrand:\n                            if int(lineFJ.loc_left) >= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n            if IDfiletype == \"FJbad,RegAnomaly,\" + lineFJ.junction[-4:]:\n                if lineFJ.chr_right == line2.chr:\n                    if lineFJ.strand_right == line2.strand:\n                        if lineFJ.strand_right == \"-\":\n                            if lineFJ.refstrand == line2.refstrand:\n                                if int(lineFJ.loc_right) >= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n                        elif lineFJ.strand_right == \"+\":\n                            if lineFJ.refstrand != line2.refstrand:\n                                if int(lineFJ.loc_right) <= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n        IDfile.flush()\n\n    if inputtype == \"genome\":  # comparing FJ to genome, has to be within 100Kbp, meet ref strand criteria (opp refstrand if + read, same refstrand if - read)\n\n        line2 = ReadInfoGenome(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction[\n                                                                                        :-5] + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.loc) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(line2.NumOfBases) + \"\\t\" + line2.chr + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"FJbad,genomAnomaly,\" + lineFJ.junction[-4:]\n        # compare left\n        if lineFJ.chr_left == line2.chr:\n            if lineFJ.strand_left == \"-\":\n                if lineFJ.refstrand == line2.refstrand:\n                    if int(lineFJ.loc_left) <= int(line2.loc):\n                        IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n            elif lineFJ.strand_left == \"+\":\n                if lineFJ.refstrand != line2.refstrand:\n                    if int(lineFJ.loc_left) >= int(line2.loc):\n                        IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n                        ## if left not the same, then compare right\n        if IDfiletype == \"FJbad,genomAnomaly,\" + lineFJ.junction[-4:]:\n            if lineFJ.chr_right == line2.chr:\n                if lineFJ.strand_right == \"-\":\n                    if lineFJ.refstrand == line2.refstrand:\n                        if int(lineFJ.loc_right) >= int(line2.loc):\n                            IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n                elif lineFJ.strand_right == \"+\":\n                    if lineFJ.refstrand != line2.refstrand:\n                        if int(lineFJ.loc_right) <= int(line2.loc):\n                            IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n\n#\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        if self.junction[-4:-1] == \"DEL\":\n            self.indel = -int(self.junction[-1:])\n        elif self.junction[-4:-1] == \"INS\":\n            self.indel = int(self.junction[-1:])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\n\nclass ReadInfoGenome:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.chr = line[2]\n        self.loc = line[3]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\nclass ReadInfoJunc:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.chr = line[2].split(\"|\")[0]\n        self.loc_1 = line[2].replace(\":\", \"|\").split(\"|\")[2]\n        self.loc_2 = line[2].replace(\":\", \"|\").split(\"|\")[4]\n        self.strand = line[2][-1]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\n# =========================================\n# start here\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name of file to generate report\")\n#parser.add_argument(\"-c\", \"--circReads\", required=True, help=\"path to circReads Dir\")\n#parser.add_argument(\"-f\", \"--FJDir\", required=True, help=\"path to aligned junction reads\")\n#parser.add_argument(\"-i\", \"--origDir\", required=True, help=\"path to orig dir containing genome reads\")\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\n\nparser.add_argument(\"-fusj1\", \"--fusionJuncSAM1\", required=True, help=\"unaligned reads1 to fusion junctions\")\nparser.add_argument(\"-fusj2\", \"--fusionJuncSAM2\", required=True, help=\"unaligned reads2 to fusion junctions\")\n\nparser.add_argument(\"-asufji1\", \"--allStillUnalignedFusionJuncSAM1\", required=True, help=\"All still unaligned reads1 to fusion junction indels\")\nparser.add_argument(\"-asufji2\", \"--allStillUnalignedFusionJuncSAM2\", required=True, help=\"All still unaligned reads2 to fusion junction indels\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-gens1\", \"--genomeSAM1\", required=True, help=\"read1 to genome\")\nparser.add_argument(\"-gens2\", \"--genomeSAM2\", required=True, help=\"read2 to genome\")\nparser.add_argument(\"-regs1\", \"--regularSAM1\", required=True, help=\"read1 to regular junction\")\nparser.add_argument(\"-regs2\", \"--regularSAM2\", required=True, help=\"read2 to regular junction\")\nparser.add_argument(\"-scrs1\", \"--scrambledSAM1\", required=True, help=\"read1 to ribosomal junction\")\nparser.add_argument(\"-scrs2\", \"--scrambledSAM2\", required=True, help=\"read2 to ribosomal junction\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\nwindow = int(args.window)\njunction_length = int(args.farJunctionLength)\n\n# f1 = open(\"/Users/Gillian/Desktop/sherlock/unaligned_ENCFF000HOC1_1.sam\", mode =\"rU\")\n# f2 = open(\"/Users/Gillian/Desktop/sherlock/20000_ENCFF000HOC2_1_genome_output.sam\", mode =\"rU\")\n\n#if args.FJDir[-1] != \"/\":\n#    args.FJDir += \"/\"\n#if args.origDir[-1] != \"/\":\n#    args.origDir += \"/\"\n#if args.circReads[-1] != \"/\":\n#    args.circReads += \"/\"\n\n#stem = args.stem\n\n#FarJunctionfiles = []\nFarJunction_noIndelfiles = []\ngenomefiles = []\nregfiles = []\njunctionfiles = []\n\n#for name in glob.glob(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + stem + \"/*.sam\"):\n#    print name\n#    if \"All_\" not in name:\n#        FarJunctionfiles.append(name)\n        # FarJunctionFiles contains indel alignments for _1 and _2 files to indels 1-5\n\n\n\n#for name in glob.glob(args.FJDir + \"FarJunctionAlignments/\" + stem + \"/*.sam\"):\n#    FarJunction_noIndelfiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"genome/*\" + stem + \"*.sam\")):\n#    #    print name\n#    if \"sorted\" not in name:\n#        genomefiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"reg/*\" + stem + \"*.sam\")):\n    #    print name\n#    if \"sorted\" not in name:\n#        regfiles.append(name)\n#for name in glob.glob(os.path.join(args.origDir, \"junction/*\" + stem + \"*.sam\")):\n#    #    print name\n#    if \"sorted\" not in name:\n#        junctionfiles.append(name)\n        # for name in glob.glob(os.path.join(args.origDir,\"unaligned/*\" + stem + \"*.fq\")):\n##    print name\n#    if \"sorted\" not in name:\n#        unalignedfiles.append(name)\n\n\n# opening all files for a particular stem\n#print sorted(FarJunction_noIndelfiles)\n#print sorted(genomefiles)\n#print sorted(regfiles)\n#print sorted(junctionfiles)\n\n## open big indels files\n\n#f1_FarJunc = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + stem + \"/All_\" + stem + \"_1_indels.sam\", mode=\"rB\")\n#f2_FarJunc = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + stem + \"/All_\" + stem + \"_2_indels.sam\", mode=\"rB\")\n\nf1_FarJunc = open(args.allStillUnalignedFusionJuncSAM1, mode = \"rB\")\nf2_FarJunc = open(args.allStillUnalignedFusionJuncSAM2, mode = \"rB\")\n\n#f1_FJ_noIndel = open(sorted(FarJunction_noIndelfiles)[0], mode=\"rB\")\n#f2_FJ_noIndel = open(sorted(FarJunction_noIndelfiles)[1], mode=\"rB\")\n\nf1_FJ_noIndel = open(args.fusionJuncSAM1, mode = \"rB\")\nf2_FJ_noIndel = open(args.fusionJuncSAM2, mode = \"rB\")\n\nIDfile = open(args.sample + \"_temp_output_FJIndels.txt\", mode=\"w\")\nIDfile.write(\"ID\\tclass\\tR1_offset\\tR1_MAPQ\\tR1_AS\\tR1_NumN\\tR1_Readlength\\tR1_JuncName\\tR1_strand\\tR2_offset\\tR2_MAPQ\\tR2_AS\\tR2_NumN\\tR2_Readlength\\tR2_JuncName\\tR2_strand\\n\")\n\n# populate all reads and junctions into separate dictionaries\nAllFJRead1 = {}\nAllFJRead2 = {}\n\n# populate AllFJRead1 dictionary - all read 1's from FarJunction alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening FarJunc _1 file\"\n\nfor line_raw in f1_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n\n    FJ1read = ReadInfoFJ(line_raw)\n\n    if FJ1read.offset <= (junction_length/2 + FJ1read.indel - window) and (\n        FJ1read.offset + FJ1read.NumOfBases) >= junction_length/2 + FJ1read.indel + window:\n        AllFJRead1[FJ1read.ID] = [line_raw, 0]\n\nf1_FarJunc.close()\nIDfile.flush()\n\n# populate AllFJRead2 dictionary - all read 2's from FarJunc alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening farJunc _2 file\"\nfor line_raw in f2_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n\n    FJ2read = ReadInfoFJ(line_raw)\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if FJ2read.ID in AllFJRead1:\n        if FJ2read.offset <= (junction_length/2 + FJ2read.indel - window) and (\n            FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + FJ2read.indel + window and AllFJRead1[FJ2read.ID][1] == 0:\n            AddToDict(\"FJ\", line_raw, AllFJRead1[FJ2read.ID][0])\n            AllFJRead1[FJ2read.ID][1] = \"FJ\"\n    else:\n        AllFJRead2[FJ2read.ID] = [line_raw, 0]\n\n# if FJ2read.junction not in AllJunctions:\n#        AllJunctions[FJ2read.junction]=0\n#\n#    AllJunctions[FJ2read.junction]+=1\nf2_FarJunc.close()\nIDfile.flush()\n\n# compare FJ with indels_1 to FJ with no indels _ 2\nprint \"comparing indels with FJ _2\"\nfor line_raw in f2_FJ_noIndel:\n    if line_raw[0] == \"@\":\n        continue\n    FJ2read = ReadInfoFJ(line_raw)\n\n    if FJ2read.ID in AllFJRead1 and AllFJRead1[FJ2read.ID][1] == 0:\n        AddToDict(\"FJ\", line_raw, AllFJRead1[FJ2read.ID][0])\n        AllFJRead1[FJ2read.ID][1] = \"FJ\"\n\nf2_FJ_noIndel.close()\nIDfile.flush()\n\n# compare FJ with indels _2 to FJ with no indels _1\n\nprint \"comparing indels with FJ _1\"\n\nfor line_raw in f1_FJ_noIndel:\n    if line_raw[0] == \"@\":\n        continue\n    FJ1read = ReadInfoFJ(line_raw)\n\n    if FJ1read.ID in AllFJRead2 and AllFJRead2[FJ1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        #        if g1read.ID in unmappedDict:\n        #            del unmappedDict[g1read.ID]\n        AddToDict(\"FJ\", line_raw, AllFJRead2[FJ1read.ID][0])\n        AllFJRead2[FJ1read.ID][1] = \"FJ\"\nf1_FJ_noIndel.close()\nIDfile.flush()\n\n#f2_genome = open(sorted(genomefiles)[1], mode=\"rB\")\nf2_genome = open(args.genomeSAM2, mode = \"rB\")\n\n# compare FJ read 1 to genome read 2\nprint \"comparing indels with genome_2\"\n\nfor line_raw in f2_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g2read = ReadInfoGenome(line_raw)\n\n    if g2read.ID in AllFJRead1 and AllFJRead1[g2read.ID][1] == 0:\n        AddToDict(\"genome\", line_raw, AllFJRead1[g2read.ID][0])\n        AllFJRead1[g2read.ID][1] = \"genome\"\n\nf2_genome.close()\n\nIDfile.flush()\n\n#f1_genome = open(sorted(genomefiles)[0], mode=\"rB\")\nf1_genome = open(args.genomeSAM1, mode = \"rB\")\n\n# compare FJ read 2 to genome read 1\nprint \"comparing indels with genome _1\"\nfor line_raw in f1_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g1read = ReadInfoGenome(line_raw)\n\n    if g1read.ID in AllFJRead2 and AllFJRead2[g1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        #        if g1read.ID in unmappedDict:\n        #            del unmappedDict[g1read.ID]\n        AddToDict(\"genome\", line_raw, AllFJRead2[g1read.ID][0])\n        AllFJRead2[g1read.ID][1] = \"genome\"\nf1_genome.close()\n\nIDfile.flush()\n\n#f2_reg = open(sorted(regfiles)[1], mode=\"rB\")\nf2_reg = open(args.regularSAM2, mode=\"rB\")\n\n# compare FJ read 1 to reg read 2\nprint \"comparing indels with reg _2\"\n\nfor line_raw in f2_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg2read = ReadInfoJunc(line_raw)\n\n    if reg2read.offset <= (junction_length/2 - window) and (reg2read.offset + reg2read.NumOfBases) >= (junction_length/2 + window):\n        if reg2read.ID in AllFJRead1 and AllFJRead1[reg2read.ID][1] == 0:\n            #            print \"found reg R2:\" + reg2read.ID\n            #            if reg2read.ID in unmappedDict:\n            #                del unmappedDict[reg2read.ID]\n            AddToDict(\"reg\", line_raw, AllFJRead1[reg2read.ID][0])\n            AllFJRead1[reg2read.ID][1] = \"reg\"\nf2_reg.close()\nIDfile.flush()\n\n#f1_reg = open(sorted(regfiles)[0], mode=\"rB\")\nf1_reg = open(args.regularSAM1, mode=\"rB\")\n\n# compare FJ read 2 to reg read 1\nprint \"comparing indels with reg _1\"\n\nfor line_raw in f1_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg1read = ReadInfoJunc(line_raw)\n\n    if reg1read.offset <= (junction_length/2 - window) and (reg1read.offset + reg1read.NumOfBases) >= (junction_length/2 + window):\n        if reg1read.ID in AllFJRead2 and AllFJRead2[reg1read.ID][1] == 0:\n            #            print \"found reg R1: \" + reg1read.ID\n            #            if reg1read.ID in unmappedDict:\n            #                del unmappedDict[reg1read.ID]\n            AddToDict(\"reg\", line_raw, AllFJRead2[reg1read.ID][0])\n            AllFJRead2[reg1read.ID][1] = \"reg\"\nf1_reg.close()\nIDfile.flush()\n\n#f2_junc = open(sorted(junctionfiles)[1], mode=\"rB\")\nf2_junc = open(args.scrambledSAM2, mode=\"rB\")\n\n# compare FJ read 1 to junc read 2\nprint \"comparing indels with junc _2\"\n\nfor line_raw in f2_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc2read = ReadInfoJunc(line_raw)\n\n    if junc2read.offset <= (junction_length/2 - window) and (junc2read.offset + junc2read.NumOfBases) >= (junction_length/2 + window):\n        if junc2read.ID in AllFJRead1 and AllFJRead1[junc2read.ID][1] == 0:\n            # print \"found junc R2 \" + junc2read.ID\n            #            if junc2read.ID in unmappedDict:\n            #                del unmappedDict[junc2read.ID]\n            AddToDict(\"junc\", line_raw, AllFJRead1[junc2read.ID][0])\n            AllFJRead1[junc2read.ID][1] = \"junc\"\nf2_junc.close()\nIDfile.flush()\n\n#f1_junc = open(sorted(junctionfiles)[0], mode=\"rB\")\nf1_junc = open(args.scrambledSAM1, mode=\"rB\")\n\n# compare FJ read 2 to junc read 1\nprint \"comparing indels with junc _1\"\n\nfor line_raw in f1_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc1read = ReadInfoJunc(line_raw)\n\n    if junc1read.offset <= (junction_length/2 - window) and (junc1read.offset + junc1read.NumOfBases) >= (junction_length/2 + window):\n        if junc1read.ID in AllFJRead2 and AllFJRead2[junc1read.ID][1] == 0:\n            # print \"found junc R1: \" + junc1read.ID\n            #            if junc1read.ID in unmappedDict:\n            #                del unmappedDict[junc1read.ID]\n            AddToDict(\"junc\", line_raw, AllFJRead2[junc1read.ID][0])\n            AllFJRead2[junc1read.ID][1] = \"junc\"\nf1_junc.close()\nIDfile.flush()\n\nIDfile.close()\n\n#############################################################################\n## This section of code takes the written ID file above (temp_IDs_STEM.txt) and\n## removes duplicate entries of genome and reg. The same readID may be found\n## in both libraries and would both be in the ID file.\n## The new ID file removes duplicates and only keeps the readID with the\n## best alignment score.\n#tempIDfile = open(args.FJDir + \"GLM_classInput/\" + args.stem + \"_temp_output_FJIndels.txt\", mode=\"rU\")\n#newIDfile = open(args.FJDir + \"GLM_classInput/\" + args.stem + \"_output_FJIndels.txt\", mode=\"w\")\n\ntempIDfile = open(args.sample + \"_temp_output_FJIndels.txt\", mode=\"rU\")\nnewIDfile = open(args.sample + \"__output_FJIndels.txt\", mode=\"w\")\n\n##grep col 2 for \"genom\", \"Regular\" or \"RegAnomaly\". if not found ,write to\n## new file immediately.\n## if found, feed into dictionary (key=readID, value= entire line from temp file)\n## if duplicate entry, then compare R2 AS. if AS larger, then replace\n## value with new value from new R2\n## at completion of file, write entire dictionary into new ID file.\n\nGenomeAndRegReadIDs = {}\n\nfor line in tempIDfile:\n    line = line.strip()\n    if \"unaligned\" in line:\n        continue\n\n    if \"Unmapped\" in line:\n        continue\n\n    readID = line.split(\"\\t\")[0]\n    classID = line.split(\"\\t\")[1]\n    AS_new = line.split(\"\\t\")[11]\n\n    if \"genom\" in classID:\n        ## if readID has been seen previously, then replace value in dictionary\n        ## only if AS is greater.\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"Regular\" in classID:\n        ## do the same if reg\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"RegAnomaly\" in classID:\n        ## do the same if reg anomaly\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    else:\n        ## if not genome/genome anomaly/ reg/ reg anomaly then\n        ## write line directly in new file.\n        newIDfile.write(line + \"\\n\")\n\nfor entry in GenomeAndRegReadIDs:\n    newIDfile.write(GenomeAndRegReadIDs[entry] + \"\\n\")\n\ntempIDfile.close()\nnewIDfile.close()",
                "filename": "FJIndels_ClassIDFile.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n"
            },
            "separate": true
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#scrambled_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "id": "#regular_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n\tif($job.inputs.overlap)\n    {\n    \treturn \" -w \" + $job.inputs.overlap + \" \"\n    }\n  \telse\n    {\n    \treturn \" -w 8 \"\n    }\n}"
              },
              "separate": true
            },
            "id": "#overlap",
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-m",
              "separate": true
            },
            "id": "#mode",
            "required": false,
            "type": [
              "null",
              {
                "name": "mode",
                "type": "enum",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--farJunctionLength",
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fjl",
              "separate": true
            },
            "sbg:stageInput": null,
            "required": false
          },
          {
            "id": "#genome_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "id": "#fusion_junction_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -fusj1 \" + inputs[i].path\n        else\n          cmd += \" -fusj2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              },
              "separate": true
            },
            "required": false
          },
          {
            "sbg:altPrefix": "--allStillUnalignedFusionJuncSAM2",
            "id": "#allStillUnalignedFusionJuncSAM2",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-asufji2",
              "separate": true
            },
            "required": false
          },
          {
            "sbg:altPrefix": "--allStillUnalignedFusionJuncSAM1",
            "id": "#allStillUnalignedFusionJuncSAM1",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-asufji1",
              "separate": true
            },
            "required": false
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "fusion_junction_sam": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/fusion_junction_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/fusion_junction_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "regular_sam": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/regular_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/regular_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "allStillUnalignedFusionJuncSAM1": {
              "secondaryFiles": [],
              "path": "/path/to/allStillUnalignedFusionJuncSAM1.ext",
              "class": "File",
              "size": 0
            },
            "overlap": 4,
            "genome_sam": [
              {
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/genome_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/genome_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "mode": "complete",
            "scrambled_sam": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/path/to/scrambled_sam-1.ext",
                "class": "File",
                "secondaryFiles": []
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "path": "/path/to/scrambled_sam-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ],
            "junction_length": 9,
            "allStillUnalignedFusionJuncSAM2": {
              "secondaryFiles": [],
              "path": "/path/to/allStillUnalignedFusionJuncSAM2.ext",
              "class": "File",
              "size": 0
            }
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/fjindels-classidfile/2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -93.27833927783716,
        "sbg:cmdPreview": "python FJIndels_ClassIDFile.py  -s sample_name",
        "stdin": "",
        "label": "SPORK FJIndels_ClassIDFile",
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/fjindels-classidfile/2"
      },
      "inputs": [
        {
          "id": "#SPORK_FJIndels_ClassIDFile.scrambled_sam",
          "source": [
            "#getUnalignedReads_1.mate_scrambled_sam",
            "#getUnalignedReads_2.mate_scrambled_sam"
          ]
        },
        {
          "id": "#SPORK_FJIndels_ClassIDFile.regular_sam",
          "source": [
            "#getUnalignedReads_2.mate_regular_sam",
            "#getUnalignedReads_1.mate_regular_sam"
          ]
        },
        {
          "id": "#SPORK_FJIndels_ClassIDFile.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#SPORK_FJIndels_ClassIDFile.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#SPORK_FJIndels_ClassIDFile.junction_length",
          "default": 300
        },
        {
          "id": "#SPORK_FJIndels_ClassIDFile.genome_sam",
          "source": [
            "#getUnalignedReads_2.mate_genome_sam",
            "#getUnalignedReads_1.mate_genome_sam"
          ]
        },
        {
          "id": "#SPORK_FJIndels_ClassIDFile.fusion_junction_sam",
          "source": [
            "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.result_sam_file"
          ]
        },
        {
          "id": "#SPORK_FJIndels_ClassIDFile.allStillUnalignedFusionJuncSAM2",
          "source": [
            "#SPORK_MakeIndelsHisto.all_indels_sam_2"
          ]
        },
        {
          "id": "#SPORK_FJIndels_ClassIDFile.allStillUnalignedFusionJuncSAM1",
          "source": [
            "#SPORK_MakeIndelsHisto.all_indels_sam_1"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_FJIndels_ClassIDFile.temp_output_FJIndels"
        },
        {
          "id": "#SPORK_FJIndels_ClassIDFile.output_FJIndels"
        }
      ],
      "sbg:x": 5537.158913022628,
      "sbg:y": -93.27833927783716
    },
    {
      "id": "#SPORK_Bowtie2_2_3_4_1_Aligner",
      "run": {
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:revisionNotes": "&& instead of &",
        "sbg:modifiedOn": 1533223927,
        "class": "CommandLineTool",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false,
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Unaligned reads only",
            "id": "#unaligned_reads_only",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align."
          },
          {
            "outputBinding": {
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false,
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Result SAM file",
            "id": "#result_sam_file",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads."
          },
          {
            "outputBinding": {
              "glob": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false,
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Aligned reads only",
            "id": "#aligned_reads_only",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once."
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "cwlVersion": "sbg:draft-2",
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "successCodes": [],
        "arguments": [
          {
            "prefix": "",
            "position": 100,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}"
            },
            "separate": true
          },
          {
            "prefix": "-S",
            "position": 101,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}"
            },
            "separate": true
          },
          {
            "prefix": "-x",
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "prefix": "",
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}"
            },
            "separate": true
          },
          {
            "prefix": "",
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "position": 103,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}"
            },
            "separate": true
          },
          {
            "position": 102,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}"
            },
            "separate": true
          },
          {
            "position": 104,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}"
            },
            "separate": true
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "sbg:validationErrors": [],
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 4,
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:revision": 4,
        "sbg:modifiedBy": "jordanski.milos",
        "baseCommand": [
          {
            "engine": "#cwl-js-engine",
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}"
          },
          "bowtie2"
        ],
        "stdout": "",
        "temporaryFailCodes": [],
        "sbg:createdOn": 1520434786,
        "x": 3067.5885063643627,
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdin": "",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520434786,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520434814,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1525306849,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:revision": 3,
            "sbg:modifiedOn": 1533171459,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:revisionNotes": "&& instead of &",
            "sbg:revision": 4,
            "sbg:modifiedOn": 1533223927,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:categories": [
          "Alignment"
        ],
        "inputs": [
          {
            "sbg:toolDefaultValue": "None",
            "label": "Unpaired unaligned reads",
            "id": "#unpaired_unaligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "sbg:toolDefaultValue": "None",
            "label": "Unpaired aligned reads",
            "id": "#unpaired_aligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "sbg:altPrefix": "-5",
            "sbg:toolDefaultValue": "0",
            "label": "Trim from 5'",
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--trim5",
              "separate": true
            },
            "description": "Trim given number of bases from 5' (left) end of each read before alignment."
          },
          {
            "sbg:altPrefix": "-3",
            "sbg:toolDefaultValue": "0",
            "label": "Trim from 3'",
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--trim3",
              "separate": true
            },
            "description": "Trim given number of bases from 3' (right) end of each read before alignment."
          },
          {
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}"
              },
              "separate": true
            }
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Suppress SQ header lines",
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-sq",
              "separate": true
            },
            "description": "Suppress @SQ SAM header lines."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Suppress SAM records for unaligned reads",
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-unal",
              "separate": true
            },
            "description": "Suppress SAM records for reads that failed to align."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Suppress header lines",
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-hd",
              "separate": true
            },
            "description": "Suppress SAM header lines (starting with @)."
          },
          {
            "id": "#sort_sam",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "-s",
            "sbg:toolDefaultValue": "-",
            "label": "Skip reads",
            "sbg:category": "Input",
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--skip",
              "separate": true
            },
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input."
          },
          {
            "sbg:toolDefaultValue": "0",
            "label": "Set seed",
            "sbg:category": "Other",
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--seed",
              "separate": true
            },
            "description": "Set the seed for pseudo-random number generator."
          },
          {
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "label": "Set match bonus",
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--ma",
              "separate": true
            },
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match."
          },
          {
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "label": "Seed substring length",
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-L",
              "separate": true
            },
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode."
          },
          {
            "sbg:toolDefaultValue": "15",
            "label": "Seed extension attempts",
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-D",
              "separate": true
            },
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment."
          },
          {
            "sbg:toolDefaultValue": "-",
            "label": "Report k alignments",
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-k",
              "separate": true
            },
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow."
          },
          {
            "sbg:altPrefix": "-a",
            "sbg:toolDefaultValue": "False",
            "label": "Report all alignments",
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--all",
              "separate": true
            },
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\"."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Reorder output",
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--reorder",
              "separate": true
            },
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory."
          },
          {
            "sbg:toolDefaultValue": "5,3",
            "label": "Reference gap penalties",
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "separate": true,
              "itemSeparator": ","
            },
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>."
          },
          {
            "label": "Read sequence",
            "required": true,
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "type": [
              {
                "name": "read_sequence",
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2."
          },
          {
            "sbg:toolDefaultValue": "5,3",
            "label": "Read gap penalties",
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "separate": true,
              "itemSeparator": ","
            },
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>."
          },
          {
            "sbg:toolDefaultValue": "Phred+33",
            "label": "Quality scale",
            "id": "#quality_scale",
            "sbg:category": "Input",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "type": "enum",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "description": "Set quality scale."
          },
          {
            "sbg:toolDefaultValue": "Sensitive",
            "label": "Preset",
            "sbg:category": "Presets",
            "id": "#preset_option",
            "type": [
              "null",
              {
                "name": "preset_option",
                "type": "enum",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}"
              },
              "separate": true
            },
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\"."
          },
          {
            "sbg:toolDefaultValue": "None",
            "label": "Paired unaligned reads",
            "id": "#paired_unaligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "sbg:toolDefaultValue": "None",
            "label": "Paired aligned reads",
            "id": "#paired_aligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "description": "Output Suffix String.",
            "label": "Output Suffix String"
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Omit SEQ and QUAL",
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq",
              "separate": true
            },
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead."
          },
          {
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "id": "#number_of_cpu",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Non deterministic",
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic",
              "separate": true
            },
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads."
          },
          {
            "sbg:altPrefix": "-I",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Paired-end",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--minins",
              "separate": true
            },
            "id": "#minimum_fragment_length",
            "label": "Minimum fragment length",
            "sbg:stageInput": null,
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient."
          },
          {
            "sbg:toolDefaultValue": "6",
            "label": "Maximum mismatch penalty",
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--mp",
              "separate": true
            },
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty."
          },
          {
            "sbg:altPrefix": "-X",
            "sbg:toolDefaultValue": "500",
            "label": "Maximum fragment length",
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--maxins",
              "separate": true
            },
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient."
          },
          {
            "sbg:toolDefaultValue": "2",
            "label": "Max number of re-seed",
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-R",
              "separate": true
            },
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300."
          },
          {
            "sbg:toolDefaultValue": "--fr",
            "label": "Mates alignment orientation",
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "type": "enum",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Integer qualities",
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--int-quals",
              "separate": true
            },
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I...."
          },
          {
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-f",
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Ignore qualities",
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals",
              "separate": true
            },
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads)."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Ignore paired_end metadata",
            "id": "#ignore_paired_end_metadata",
            "sbg:category": "Input",
            "type": [
              "null",
              "boolean"
            ],
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set"
          },
          {
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "label": "Function type",
            "id": "#function_score_min",
            "sbg:category": "Alignment score function",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "type": "enum",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively."
          },
          {
            "sbg:toolDefaultValue": "Linear",
            "label": "Function type",
            "id": "#function_n_ceil",
            "sbg:category": "Ambiguous chars function",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "type": "enum",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out."
          },
          {
            "sbg:toolDefaultValue": "Square-root",
            "label": "Function type",
            "id": "#function_i",
            "sbg:category": "Interval function",
            "type": [
              "null",
              {
                "name": "function_i",
                "type": "enum",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively."
          },
          {
            "sbg:toolDefaultValue": "15",
            "label": "Dynamic padding",
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--dpad",
              "separate": true
            },
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Don't align reverse complement",
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--norc",
              "separate": true
            },
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Don't align forward",
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--nofw",
              "separate": true
            },
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled."
          },
          {
            "sbg:toolDefaultValue": "4",
            "label": "Disallow gaps",
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--gbar",
              "separate": true
            },
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable unpaired alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed",
              "separate": true
            },
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable overlapping alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap",
              "separate": true
            },
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable dovetail alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail",
              "separate": true
            },
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable discordant alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant",
              "separate": true
            },
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable containing alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-contain",
              "separate": true
            },
            "description": "If one mate alignment contains the other, consider that to be non-concordant."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable 1 mismatch alignments",
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront",
              "separate": true
            },
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed."
          },
          {
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "label": "Constant A",
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null,
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode."
          },
          {
            "sbg:toolDefaultValue": "0",
            "label": "Constant A",
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null,
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out."
          },
          {
            "sbg:toolDefaultValue": "1",
            "label": "Constant A",
            "id": "#constant_i_a",
            "sbg:category": "Interval function",
            "type": [
              "null",
              "float"
            ],
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length."
          },
          {
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "label": "Coefficient B",
            "id": "#coefficient_scoremin_b",
            "sbg:category": "Alignment score function",
            "type": [
              "null",
              "float"
            ],
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode."
          },
          {
            "sbg:toolDefaultValue": "0.15",
            "label": "Coefficient B",
            "id": "#coefficient_nceil_b",
            "sbg:category": "Ambiguous chars function",
            "type": [
              "null",
              "int"
            ],
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out."
          },
          {
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "label": "Coefficient B",
            "id": "#coefficient_i_b",
            "sbg:category": "Interval function",
            "type": [
              "null",
              "float"
            ],
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode."
          },
          {
            "type": [
              "File"
            ],
            "sbg:fileTypes": "TAR",
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "required": true,
            "sbg:stageInput": "link",
            "description": "Archive file produced by Bowtie2 Indexer."
          },
          {
            "sbg:toolDefaultValue": "1",
            "label": "Ambiguous character penalty",
            "sbg:includeInPorts": true,
            "required": false,
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:category": "Scoring",
            "sbg:stageInput": null,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--np",
              "separate": true
            },
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N."
          },
          {
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "type": "enum",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "label": "Allowed mismatch number",
            "sbg:stageInput": null,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-N",
              "separate": true
            },
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity."
          },
          {
            "sbg:toolDefaultValue": "End-to-end",
            "label": "Alignment mode",
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "type": "enum",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}"
              },
              "separate": true
            },
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped."
          },
          {
            "sbg:altPrefix": "-u",
            "sbg:toolDefaultValue": "No limit",
            "label": "Align next n reads",
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--upto",
              "separate": true
            },
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop."
          }
        ],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:image_url": null,
        "sbg:job": {
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          },
          "inputs": {
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "paired_aligned_reads": "gzip compressed",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "disable_overlapping_alignments": false,
            "number_of_cpu": 7,
            "ignore_paired_end_metadata": false,
            "mates_alignment_orientation": "--rf",
            "disable_unpaired_alignments": false,
            "unpaired_unaligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "unpaired_aligned_reads": "gzip compressed",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "bowtie_index_archive": {
              "metadata": {
                "reference_genome": "chr20"
              },
              "size": 0,
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "secondaryFiles": []
            },
            "quality_scale": "Phred+33",
            "function_n_ceil": "Square-root",
            "alignment_mode": "Local",
            "threads": 7,
            "preset_option": "Very fast",
            "allowed_mismatch_number": "0",
            "read_gap_penalties": [
              0
            ],
            "constant_nceil_a": "0",
            "constant_scoremin_a": "0",
            "coefficient_nceil_b": 4,
            "reference_gap_penalties": [
              0
            ],
            "constant_i_a": 0,
            "coefficient_scoremin_b": 0,
            "coefficient_i_b": 0,
            "sort_sam": true,
            "output_file_suffix": "",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_sequence": [
              {
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "secondaryFiles": []
              }
            ]
          }
        },
        "hints": [
          {
            "dockerImageId": "029d3a264215",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "value": 6000,
            "class": "sbg:MemRequirement"
          },
          {
            "value": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}"
            },
            "class": "sbg:CPURequirement"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -109.8079062623948,
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:toolkit": "Bowtie2",
        "label": "SPORK Bowtie2-2.3.4.1 Aligner"
      },
      "inputs": [
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.unpaired_unaligned_reads",
          "default": "raw"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.unpaired_aligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.trim_from_5"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.trim_from_3"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.threads",
          "default": 16
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.suppress_sam_records",
          "default": true
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.suppress_header_lines"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.sort_sam"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.skip_reads"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.set_seed"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.set_match_bonus"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.seed_substring_length"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.seed_extension_attempts"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.report_k_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.report_all_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.reorder_output"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.read_sequence",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq",
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.quality_scale"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.preset_option"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.paired_unaligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.paired_aligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.output_file_suffix"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.omit_seq_and_qual"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.number_of_cpu",
          "default": 1
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.non_deterministic"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.minimum_fragment_length"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.maximum_mismatch_penalty"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.maximum_fragment_length"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.max_number_of_re_seed"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.mates_alignment_orientation"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.integer_qualities"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.input_fasta_files"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.ignore_qualities"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.function_i"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.dynamic_padding"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.dont_align_reverse_complement"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.dont_align_forward"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.disallow_gaps"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.disable_unpaired_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.disable_overlapping_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.disable_dovetail_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.disable_discordant_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.disable_containing_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.disable_1_mismatch_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.constant_i_a"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.coefficient_i_b"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.bowtie_index_archive",
          "source": [
            "#SPORK_Bowtie2_Indexer_Junctions.bowtie_index_archive"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.ambiguous_character_penalty",
          "default": "0",
          "source": [
            "#ambiguous_character_penalty"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.allowed_mismatch_number"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.alignment_mode"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.unaligned_reads_only"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.result_sam_file"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner.aligned_reads_only"
        }
      ],
      "sbg:x": 3067.5885063643627,
      "sbg:y": -109.8079062623948,
      "scatter": "#SPORK_Bowtie2_2_3_4_1_Aligner.read_sequence"
    },
    {
      "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions",
      "run": {
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:revisionNotes": "&& instead of &",
        "sbg:modifiedOn": 1533223927,
        "class": "CommandLineTool",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false,
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Unaligned reads only",
            "id": "#unaligned_reads_only",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align."
          },
          {
            "outputBinding": {
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false,
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Result SAM file",
            "id": "#result_sam_file",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads."
          },
          {
            "outputBinding": {
              "glob": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false,
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Aligned reads only",
            "id": "#aligned_reads_only",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once."
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "cwlVersion": "sbg:draft-2",
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "successCodes": [],
        "arguments": [
          {
            "prefix": "",
            "position": 100,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}"
            },
            "separate": true
          },
          {
            "prefix": "-S",
            "position": 101,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}"
            },
            "separate": true
          },
          {
            "prefix": "-x",
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "prefix": "",
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}"
            },
            "separate": true
          },
          {
            "prefix": "",
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "position": 103,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}"
            },
            "separate": true
          },
          {
            "position": 102,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}"
            },
            "separate": true
          },
          {
            "position": 104,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}"
            },
            "separate": true
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "sbg:validationErrors": [],
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 4,
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:revision": 4,
        "sbg:modifiedBy": "jordanski.milos",
        "baseCommand": [
          {
            "engine": "#cwl-js-engine",
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}"
          },
          "bowtie2"
        ],
        "stdout": "",
        "temporaryFailCodes": [],
        "sbg:createdOn": 1520434786,
        "x": 3923.002427842975,
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdin": "",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520434786,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520434814,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1525306849,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:revision": 3,
            "sbg:modifiedOn": 1533171459,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:revisionNotes": "&& instead of &",
            "sbg:revision": 4,
            "sbg:modifiedOn": 1533223927,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:categories": [
          "Alignment"
        ],
        "inputs": [
          {
            "sbg:toolDefaultValue": "None",
            "label": "Unpaired unaligned reads",
            "id": "#unpaired_unaligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "sbg:toolDefaultValue": "None",
            "label": "Unpaired aligned reads",
            "id": "#unpaired_aligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "sbg:altPrefix": "-5",
            "sbg:toolDefaultValue": "0",
            "label": "Trim from 5'",
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--trim5",
              "separate": true
            },
            "description": "Trim given number of bases from 5' (left) end of each read before alignment."
          },
          {
            "sbg:altPrefix": "-3",
            "sbg:toolDefaultValue": "0",
            "label": "Trim from 3'",
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--trim3",
              "separate": true
            },
            "description": "Trim given number of bases from 3' (right) end of each read before alignment."
          },
          {
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}"
              },
              "separate": true
            }
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Suppress SQ header lines",
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-sq",
              "separate": true
            },
            "description": "Suppress @SQ SAM header lines."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Suppress SAM records for unaligned reads",
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-unal",
              "separate": true
            },
            "description": "Suppress SAM records for reads that failed to align."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Suppress header lines",
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-hd",
              "separate": true
            },
            "description": "Suppress SAM header lines (starting with @)."
          },
          {
            "id": "#sort_sam",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "-s",
            "sbg:toolDefaultValue": "-",
            "label": "Skip reads",
            "sbg:category": "Input",
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--skip",
              "separate": true
            },
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input."
          },
          {
            "sbg:toolDefaultValue": "0",
            "label": "Set seed",
            "sbg:category": "Other",
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--seed",
              "separate": true
            },
            "description": "Set the seed for pseudo-random number generator."
          },
          {
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "label": "Set match bonus",
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--ma",
              "separate": true
            },
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match."
          },
          {
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "label": "Seed substring length",
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-L",
              "separate": true
            },
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode."
          },
          {
            "sbg:toolDefaultValue": "15",
            "label": "Seed extension attempts",
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-D",
              "separate": true
            },
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment."
          },
          {
            "sbg:toolDefaultValue": "-",
            "label": "Report k alignments",
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-k",
              "separate": true
            },
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow."
          },
          {
            "sbg:altPrefix": "-a",
            "sbg:toolDefaultValue": "False",
            "label": "Report all alignments",
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--all",
              "separate": true
            },
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\"."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Reorder output",
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--reorder",
              "separate": true
            },
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory."
          },
          {
            "sbg:toolDefaultValue": "5,3",
            "label": "Reference gap penalties",
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "separate": true,
              "itemSeparator": ","
            },
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>."
          },
          {
            "label": "Read sequence",
            "required": true,
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "type": [
              {
                "name": "read_sequence",
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2."
          },
          {
            "sbg:toolDefaultValue": "5,3",
            "label": "Read gap penalties",
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "separate": true,
              "itemSeparator": ","
            },
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>."
          },
          {
            "sbg:toolDefaultValue": "Phred+33",
            "label": "Quality scale",
            "id": "#quality_scale",
            "sbg:category": "Input",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "type": "enum",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "description": "Set quality scale."
          },
          {
            "sbg:toolDefaultValue": "Sensitive",
            "label": "Preset",
            "sbg:category": "Presets",
            "id": "#preset_option",
            "type": [
              "null",
              {
                "name": "preset_option",
                "type": "enum",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}"
              },
              "separate": true
            },
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\"."
          },
          {
            "sbg:toolDefaultValue": "None",
            "label": "Paired unaligned reads",
            "id": "#paired_unaligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "sbg:toolDefaultValue": "None",
            "label": "Paired aligned reads",
            "id": "#paired_aligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "description": "Output Suffix String.",
            "label": "Output Suffix String"
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Omit SEQ and QUAL",
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq",
              "separate": true
            },
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead."
          },
          {
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "id": "#number_of_cpu",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Non deterministic",
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic",
              "separate": true
            },
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads."
          },
          {
            "sbg:altPrefix": "-I",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Paired-end",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--minins",
              "separate": true
            },
            "id": "#minimum_fragment_length",
            "label": "Minimum fragment length",
            "sbg:stageInput": null,
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient."
          },
          {
            "sbg:toolDefaultValue": "6",
            "label": "Maximum mismatch penalty",
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--mp",
              "separate": true
            },
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty."
          },
          {
            "sbg:altPrefix": "-X",
            "sbg:toolDefaultValue": "500",
            "label": "Maximum fragment length",
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--maxins",
              "separate": true
            },
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient."
          },
          {
            "sbg:toolDefaultValue": "2",
            "label": "Max number of re-seed",
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-R",
              "separate": true
            },
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300."
          },
          {
            "sbg:toolDefaultValue": "--fr",
            "label": "Mates alignment orientation",
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "type": "enum",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Integer qualities",
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--int-quals",
              "separate": true
            },
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I...."
          },
          {
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-f",
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Ignore qualities",
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals",
              "separate": true
            },
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads)."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Ignore paired_end metadata",
            "id": "#ignore_paired_end_metadata",
            "sbg:category": "Input",
            "type": [
              "null",
              "boolean"
            ],
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set"
          },
          {
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "label": "Function type",
            "id": "#function_score_min",
            "sbg:category": "Alignment score function",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "type": "enum",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively."
          },
          {
            "sbg:toolDefaultValue": "Linear",
            "label": "Function type",
            "id": "#function_n_ceil",
            "sbg:category": "Ambiguous chars function",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "type": "enum",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out."
          },
          {
            "sbg:toolDefaultValue": "Square-root",
            "label": "Function type",
            "id": "#function_i",
            "sbg:category": "Interval function",
            "type": [
              "null",
              {
                "name": "function_i",
                "type": "enum",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively."
          },
          {
            "sbg:toolDefaultValue": "15",
            "label": "Dynamic padding",
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--dpad",
              "separate": true
            },
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Don't align reverse complement",
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--norc",
              "separate": true
            },
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Don't align forward",
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--nofw",
              "separate": true
            },
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled."
          },
          {
            "sbg:toolDefaultValue": "4",
            "label": "Disallow gaps",
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--gbar",
              "separate": true
            },
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable unpaired alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed",
              "separate": true
            },
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable overlapping alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap",
              "separate": true
            },
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable dovetail alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail",
              "separate": true
            },
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable discordant alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant",
              "separate": true
            },
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable containing alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-contain",
              "separate": true
            },
            "description": "If one mate alignment contains the other, consider that to be non-concordant."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable 1 mismatch alignments",
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront",
              "separate": true
            },
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed."
          },
          {
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "label": "Constant A",
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null,
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode."
          },
          {
            "sbg:toolDefaultValue": "0",
            "label": "Constant A",
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null,
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out."
          },
          {
            "sbg:toolDefaultValue": "1",
            "label": "Constant A",
            "id": "#constant_i_a",
            "sbg:category": "Interval function",
            "type": [
              "null",
              "float"
            ],
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length."
          },
          {
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "label": "Coefficient B",
            "id": "#coefficient_scoremin_b",
            "sbg:category": "Alignment score function",
            "type": [
              "null",
              "float"
            ],
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode."
          },
          {
            "sbg:toolDefaultValue": "0.15",
            "label": "Coefficient B",
            "id": "#coefficient_nceil_b",
            "sbg:category": "Ambiguous chars function",
            "type": [
              "null",
              "int"
            ],
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out."
          },
          {
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "label": "Coefficient B",
            "id": "#coefficient_i_b",
            "sbg:category": "Interval function",
            "type": [
              "null",
              "float"
            ],
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode."
          },
          {
            "type": [
              "File"
            ],
            "sbg:fileTypes": "TAR",
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "required": true,
            "sbg:stageInput": "link",
            "description": "Archive file produced by Bowtie2 Indexer."
          },
          {
            "sbg:toolDefaultValue": "1",
            "label": "Ambiguous character penalty",
            "sbg:includeInPorts": true,
            "required": false,
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:category": "Scoring",
            "sbg:stageInput": null,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--np",
              "separate": true
            },
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N."
          },
          {
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "type": "enum",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "label": "Allowed mismatch number",
            "sbg:stageInput": null,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-N",
              "separate": true
            },
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity."
          },
          {
            "sbg:toolDefaultValue": "End-to-end",
            "label": "Alignment mode",
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "type": "enum",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}"
              },
              "separate": true
            },
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped."
          },
          {
            "sbg:altPrefix": "-u",
            "sbg:toolDefaultValue": "No limit",
            "label": "Align next n reads",
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--upto",
              "separate": true
            },
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop."
          }
        ],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:image_url": null,
        "sbg:job": {
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          },
          "inputs": {
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "paired_aligned_reads": "gzip compressed",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "disable_overlapping_alignments": false,
            "number_of_cpu": 7,
            "ignore_paired_end_metadata": false,
            "mates_alignment_orientation": "--rf",
            "disable_unpaired_alignments": false,
            "unpaired_unaligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "unpaired_aligned_reads": "gzip compressed",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "bowtie_index_archive": {
              "metadata": {
                "reference_genome": "chr20"
              },
              "size": 0,
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "secondaryFiles": []
            },
            "quality_scale": "Phred+33",
            "function_n_ceil": "Square-root",
            "alignment_mode": "Local",
            "threads": 7,
            "preset_option": "Very fast",
            "allowed_mismatch_number": "0",
            "read_gap_penalties": [
              0
            ],
            "constant_nceil_a": "0",
            "constant_scoremin_a": "0",
            "coefficient_nceil_b": 4,
            "reference_gap_penalties": [
              0
            ],
            "constant_i_a": 0,
            "coefficient_scoremin_b": 0,
            "coefficient_i_b": 0,
            "sort_sam": true,
            "output_file_suffix": "",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_sequence": [
              {
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "secondaryFiles": []
              }
            ]
          }
        },
        "hints": [
          {
            "dockerImageId": "029d3a264215",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "value": 6000,
            "class": "sbg:MemRequirement"
          },
          {
            "value": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}"
            },
            "class": "sbg:CPURequirement"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -101.57236394242625,
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:toolkit": "Bowtie2",
        "label": "SPORK Bowtie2 Aligner To Novel Junctions"
      },
      "inputs": [
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.unpaired_unaligned_reads",
          "default": "raw"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.unpaired_aligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.trim_from_5"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.trim_from_3"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.threads",
          "default": 16
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.suppress_sam_records",
          "default": true
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.suppress_header_lines"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.sort_sam"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.skip_reads"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.set_seed"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.set_match_bonus"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.seed_substring_length"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.seed_extension_attempts"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.report_k_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.report_all_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.reorder_output"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.read_sequence",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq",
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.quality_scale"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.preset_option"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.paired_unaligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.paired_aligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.output_file_suffix"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.omit_seq_and_qual"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.number_of_cpu",
          "default": 1
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.non_deterministic"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.minimum_fragment_length"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.maximum_mismatch_penalty"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.maximum_fragment_length"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.max_number_of_re_seed"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.mates_alignment_orientation"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.integer_qualities"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.input_fasta_files"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.ignore_qualities"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.function_i"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.dynamic_padding"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.dont_align_reverse_complement"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.dont_align_forward"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.disallow_gaps"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.disable_unpaired_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.disable_overlapping_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.disable_dovetail_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.disable_discordant_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.disable_containing_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.disable_1_mismatch_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.constant_i_a"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.coefficient_i_b"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.bowtie_index_archive",
          "source": [
            "#SPORK_Bowtie2_Indexer_NovelJunctions.bowtie_index_archive"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.ambiguous_character_penalty",
          "default": "0",
          "source": [
            "#ambiguous_character_penalty"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.allowed_mismatch_number"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.alignment_mode"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.unaligned_reads_only"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.result_sam_file"
        },
        {
          "id": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.aligned_reads_only"
        }
      ],
      "sbg:x": 3923.002427842975,
      "sbg:y": -101.57236394242625,
      "scatter": "#SPORK_Bowtie2_Aligner_To_Novel_Junctions.read_sequence"
    },
    {
      "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1",
      "run": {
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:revisionNotes": "&& instead of &",
        "sbg:modifiedOn": 1533223927,
        "class": "CommandLineTool",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false,
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Unaligned reads only",
            "id": "#unaligned_reads_only",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align."
          },
          {
            "outputBinding": {
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false,
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Result SAM file",
            "id": "#result_sam_file",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads."
          },
          {
            "outputBinding": {
              "glob": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false,
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              }
            },
            "label": "Aligned reads only",
            "id": "#aligned_reads_only",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once."
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "cwlVersion": "sbg:draft-2",
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "successCodes": [],
        "arguments": [
          {
            "prefix": "",
            "position": 100,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}"
            },
            "separate": true
          },
          {
            "prefix": "-S",
            "position": 101,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}"
            },
            "separate": true
          },
          {
            "prefix": "-x",
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "prefix": "",
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}"
            },
            "separate": true
          },
          {
            "prefix": "",
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "position": 103,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}"
            },
            "separate": true
          },
          {
            "position": 102,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}"
            },
            "separate": true
          },
          {
            "position": 104,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}"
            },
            "separate": true
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "sbg:validationErrors": [],
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 4,
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:revision": 4,
        "sbg:modifiedBy": "jordanski.milos",
        "baseCommand": [
          {
            "engine": "#cwl-js-engine",
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}"
          },
          "bowtie2"
        ],
        "stdout": "",
        "temporaryFailCodes": [],
        "sbg:createdOn": 1520434786,
        "x": 5225.667199836853,
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdin": "",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520434786,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520434814,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1525306849,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:revision": 3,
            "sbg:modifiedOn": 1533171459,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:revisionNotes": "&& instead of &",
            "sbg:revision": 4,
            "sbg:modifiedOn": 1533223927,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:categories": [
          "Alignment"
        ],
        "inputs": [
          {
            "sbg:toolDefaultValue": "None",
            "label": "Unpaired unaligned reads",
            "id": "#unpaired_unaligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "sbg:toolDefaultValue": "None",
            "label": "Unpaired aligned reads",
            "id": "#unpaired_aligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "sbg:altPrefix": "-5",
            "sbg:toolDefaultValue": "0",
            "label": "Trim from 5'",
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--trim5",
              "separate": true
            },
            "description": "Trim given number of bases from 5' (left) end of each read before alignment."
          },
          {
            "sbg:altPrefix": "-3",
            "sbg:toolDefaultValue": "0",
            "label": "Trim from 3'",
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--trim3",
              "separate": true
            },
            "description": "Trim given number of bases from 3' (right) end of each read before alignment."
          },
          {
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}"
              },
              "separate": true
            }
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Suppress SQ header lines",
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-sq",
              "separate": true
            },
            "description": "Suppress @SQ SAM header lines."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Suppress SAM records for unaligned reads",
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-unal",
              "separate": true
            },
            "description": "Suppress SAM records for reads that failed to align."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Suppress header lines",
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-hd",
              "separate": true
            },
            "description": "Suppress SAM header lines (starting with @)."
          },
          {
            "id": "#sort_sam",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "-s",
            "sbg:toolDefaultValue": "-",
            "label": "Skip reads",
            "sbg:category": "Input",
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--skip",
              "separate": true
            },
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input."
          },
          {
            "sbg:toolDefaultValue": "0",
            "label": "Set seed",
            "sbg:category": "Other",
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--seed",
              "separate": true
            },
            "description": "Set the seed for pseudo-random number generator."
          },
          {
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "label": "Set match bonus",
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--ma",
              "separate": true
            },
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match."
          },
          {
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "label": "Seed substring length",
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-L",
              "separate": true
            },
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode."
          },
          {
            "sbg:toolDefaultValue": "15",
            "label": "Seed extension attempts",
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-D",
              "separate": true
            },
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment."
          },
          {
            "sbg:toolDefaultValue": "-",
            "label": "Report k alignments",
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-k",
              "separate": true
            },
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow."
          },
          {
            "sbg:altPrefix": "-a",
            "sbg:toolDefaultValue": "False",
            "label": "Report all alignments",
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--all",
              "separate": true
            },
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\"."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Reorder output",
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--reorder",
              "separate": true
            },
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory."
          },
          {
            "sbg:toolDefaultValue": "5,3",
            "label": "Reference gap penalties",
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "separate": true,
              "itemSeparator": ","
            },
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>."
          },
          {
            "label": "Read sequence",
            "required": true,
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "type": [
              {
                "name": "read_sequence",
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2."
          },
          {
            "sbg:toolDefaultValue": "5,3",
            "label": "Read gap penalties",
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "separate": true,
              "itemSeparator": ","
            },
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>."
          },
          {
            "sbg:toolDefaultValue": "Phred+33",
            "label": "Quality scale",
            "id": "#quality_scale",
            "sbg:category": "Input",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "type": "enum",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "description": "Set quality scale."
          },
          {
            "sbg:toolDefaultValue": "Sensitive",
            "label": "Preset",
            "sbg:category": "Presets",
            "id": "#preset_option",
            "type": [
              "null",
              {
                "name": "preset_option",
                "type": "enum",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}"
              },
              "separate": true
            },
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\"."
          },
          {
            "sbg:toolDefaultValue": "None",
            "label": "Paired unaligned reads",
            "id": "#paired_unaligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "sbg:toolDefaultValue": "None",
            "label": "Paired aligned reads",
            "id": "#paired_aligned_reads",
            "sbg:category": "Output",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "type": "enum",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input."
          },
          {
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "description": "Output Suffix String.",
            "label": "Output Suffix String"
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Omit SEQ and QUAL",
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq",
              "separate": true
            },
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead."
          },
          {
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "id": "#number_of_cpu",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Non deterministic",
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic",
              "separate": true
            },
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads."
          },
          {
            "sbg:altPrefix": "-I",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Paired-end",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--minins",
              "separate": true
            },
            "id": "#minimum_fragment_length",
            "label": "Minimum fragment length",
            "sbg:stageInput": null,
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient."
          },
          {
            "sbg:toolDefaultValue": "6",
            "label": "Maximum mismatch penalty",
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--mp",
              "separate": true
            },
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty."
          },
          {
            "sbg:altPrefix": "-X",
            "sbg:toolDefaultValue": "500",
            "label": "Maximum fragment length",
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--maxins",
              "separate": true
            },
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient."
          },
          {
            "sbg:toolDefaultValue": "2",
            "label": "Max number of re-seed",
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-R",
              "separate": true
            },
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300."
          },
          {
            "sbg:toolDefaultValue": "--fr",
            "label": "Mates alignment orientation",
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "type": "enum",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Integer qualities",
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--int-quals",
              "separate": true
            },
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I...."
          },
          {
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-f",
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Ignore qualities",
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals",
              "separate": true
            },
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads)."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Ignore paired_end metadata",
            "id": "#ignore_paired_end_metadata",
            "sbg:category": "Input",
            "type": [
              "null",
              "boolean"
            ],
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set"
          },
          {
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "label": "Function type",
            "id": "#function_score_min",
            "sbg:category": "Alignment score function",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "type": "enum",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively."
          },
          {
            "sbg:toolDefaultValue": "Linear",
            "label": "Function type",
            "id": "#function_n_ceil",
            "sbg:category": "Ambiguous chars function",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "type": "enum",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out."
          },
          {
            "sbg:toolDefaultValue": "Square-root",
            "label": "Function type",
            "id": "#function_i",
            "sbg:category": "Interval function",
            "type": [
              "null",
              {
                "name": "function_i",
                "type": "enum",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively."
          },
          {
            "sbg:toolDefaultValue": "15",
            "label": "Dynamic padding",
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--dpad",
              "separate": true
            },
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Don't align reverse complement",
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--norc",
              "separate": true
            },
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Don't align forward",
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--nofw",
              "separate": true
            },
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled."
          },
          {
            "sbg:toolDefaultValue": "4",
            "label": "Disallow gaps",
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--gbar",
              "separate": true
            },
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable unpaired alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed",
              "separate": true
            },
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable overlapping alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap",
              "separate": true
            },
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable dovetail alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail",
              "separate": true
            },
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable discordant alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant",
              "separate": true
            },
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable containing alignments",
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-contain",
              "separate": true
            },
            "description": "If one mate alignment contains the other, consider that to be non-concordant."
          },
          {
            "sbg:toolDefaultValue": "False",
            "label": "Disable 1 mismatch alignments",
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront",
              "separate": true
            },
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed."
          },
          {
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "label": "Constant A",
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null,
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode."
          },
          {
            "sbg:toolDefaultValue": "0",
            "label": "Constant A",
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null,
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out."
          },
          {
            "sbg:toolDefaultValue": "1",
            "label": "Constant A",
            "id": "#constant_i_a",
            "sbg:category": "Interval function",
            "type": [
              "null",
              "float"
            ],
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length."
          },
          {
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "label": "Coefficient B",
            "id": "#coefficient_scoremin_b",
            "sbg:category": "Alignment score function",
            "type": [
              "null",
              "float"
            ],
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode."
          },
          {
            "sbg:toolDefaultValue": "0.15",
            "label": "Coefficient B",
            "id": "#coefficient_nceil_b",
            "sbg:category": "Ambiguous chars function",
            "type": [
              "null",
              "int"
            ],
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out."
          },
          {
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "label": "Coefficient B",
            "id": "#coefficient_i_b",
            "sbg:category": "Interval function",
            "type": [
              "null",
              "float"
            ],
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode."
          },
          {
            "type": [
              "File"
            ],
            "sbg:fileTypes": "TAR",
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "required": true,
            "sbg:stageInput": "link",
            "description": "Archive file produced by Bowtie2 Indexer."
          },
          {
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "label": "Ambiguous character penalty",
            "sbg:stageInput": null,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--np",
              "separate": true
            },
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N."
          },
          {
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "type": "enum",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "label": "Allowed mismatch number",
            "sbg:stageInput": null,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-N",
              "separate": true
            },
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity."
          },
          {
            "sbg:toolDefaultValue": "End-to-end",
            "label": "Alignment mode",
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "type": "enum",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "valueFrom": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}"
              },
              "separate": true
            },
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped."
          },
          {
            "sbg:altPrefix": "-u",
            "sbg:toolDefaultValue": "No limit",
            "label": "Align next n reads",
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "--upto",
              "separate": true
            },
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop."
          }
        ],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:image_url": null,
        "sbg:job": {
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          },
          "inputs": {
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "paired_aligned_reads": "gzip compressed",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "disable_overlapping_alignments": false,
            "number_of_cpu": 7,
            "ignore_paired_end_metadata": false,
            "mates_alignment_orientation": "--rf",
            "disable_unpaired_alignments": false,
            "unpaired_unaligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "unpaired_aligned_reads": "gzip compressed",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "bowtie_index_archive": {
              "metadata": {
                "reference_genome": "chr20"
              },
              "size": 0,
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "secondaryFiles": []
            },
            "quality_scale": "Phred+33",
            "function_n_ceil": "Square-root",
            "alignment_mode": "Local",
            "threads": 7,
            "preset_option": "Very fast",
            "allowed_mismatch_number": "0",
            "read_gap_penalties": [
              0
            ],
            "constant_nceil_a": "0",
            "constant_scoremin_a": "0",
            "coefficient_nceil_b": 4,
            "reference_gap_penalties": [
              0
            ],
            "constant_i_a": 0,
            "coefficient_scoremin_b": 0,
            "coefficient_i_b": 0,
            "sort_sam": true,
            "output_file_suffix": "",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_sequence": [
              {
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                },
                "size": 0,
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "secondaryFiles": []
              }
            ]
          }
        },
        "hints": [
          {
            "dockerImageId": "029d3a264215",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "value": 6000,
            "class": "sbg:MemRequirement"
          },
          {
            "value": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}"
            },
            "class": "sbg:CPURequirement"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -228.98445068403527,
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:toolkit": "Bowtie2",
        "label": "SPORK Bowtie2-2.3.4.1 Aligner FJ Indels R1"
      },
      "inputs": [
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.unpaired_unaligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.unpaired_aligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.trim_from_5"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.trim_from_3"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.threads",
          "default": 16
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.suppress_sam_records",
          "default": true
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.suppress_header_lines"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.sort_sam"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.skip_reads"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.set_seed"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.set_match_bonus"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.seed_substring_length"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.seed_extension_attempts"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.report_k_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.report_all_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.reorder_output"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.read_sequence",
          "source": [
            "#SPORK_Split_Fastq_Files.fastq_file_1"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.quality_scale"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.preset_option"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.paired_unaligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.paired_aligned_reads"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.output_file_suffix",
          "default": "FJIndels1_SPORK"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.omit_seq_and_qual"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.number_of_cpu",
          "default": 2
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.non_deterministic"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.minimum_fragment_length"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.maximum_mismatch_penalty"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.maximum_fragment_length"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.max_number_of_re_seed"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.mates_alignment_orientation"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.integer_qualities",
          "default": false
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.input_fasta_files"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.ignore_qualities"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.function_n_ceil"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.function_i"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.dynamic_padding"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.dont_align_reverse_complement"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.dont_align_forward"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disallow_gaps"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_unpaired_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_overlapping_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_dovetail_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_discordant_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_containing_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_1_mismatch_alignments"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.constant_nceil_a"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.constant_i_a"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.coefficient_nceil_b"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.coefficient_i_b"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.bowtie_index_archive",
          "source": [
            "#SPORK_Bowtie2_Indexer_Indels.bowtie_index_archive"
          ]
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.ambiguous_character_penalty"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.allowed_mismatch_number"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.alignment_mode"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.unaligned_reads_only"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.result_sam_file"
        },
        {
          "id": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.aligned_reads_only"
        }
      ],
      "sbg:x": 5225.667199836853,
      "sbg:y": -228.98445068403527,
      "scatter": "#SPORK_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.bowtie_index_archive"
    },
    {
      "id": "#SPORK_combine_and_split_unaligned_reads",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:createdBy": "milos_jordanski",
        "cwlVersion": "sbg:draft-2",
        "baseCommand": [
          "python",
          "combine_and_split.py"
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.pickle"
            },
            "label": "Read numbers to read_ids",
            "id": "#read_num_to_read_id",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "PICKLE, pickle",
            "description": "Read numbers to read_ids."
          },
          {
            "outputBinding": {
              "glob": "*combined_reads.fq",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.read_1 && $job.inputs.read_1.metadata && $job.inputs.read_1.metadata.sample_id)\n      return $job.inputs.read_1.metadata.sample_id\n    return \"\"\n}"
                }
              }
            },
            "label": "Combined reads",
            "id": "#combined_reads",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "FQ, FASTQ",
            "description": "Combined unaligned reads from KNIFE for DenovoIndex"
          },
          {
            "outputBinding": {
              "glob": "5prime_*.fq",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.read_1 && $job.inputs.read_1.metadata && $job.inputs.read_1.metadata.sample_id)\n      return $job.inputs.read_1.metadata.sample_id\n    return \"\"\n}"
                }
              }
            },
            "label": "5prime",
            "id": "#5prime",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "FQ, FASTQ",
            "description": "5prime part of reads"
          },
          {
            "outputBinding": {
              "glob": "3prime*.fq",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.read_1 && $job.inputs.read_1.metadata && $job.inputs.read_1.metadata.sample_id)\n      return $job.inputs.read_1.metadata.sample_id\n    return \"\"\n}"
                }
              }
            },
            "label": "3prime",
            "id": "#3prime",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "FQ, FASTQ",
            "description": "3prime part of reads"
          }
        ],
        "class": "CommandLineTool",
        "successCodes": [],
        "sbg:modifiedOn": 1533818642,
        "id": "milos_jordanski/spachete-salzman-collaboration/combine-and-split-unaligned-reads/2",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 2,
        "temporaryFailCodes": [],
        "sbg:revision": 2,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520432928,
        "x": 1757,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import argparse\nimport pickle\nfrom SPORK_FastQEntry import FastQEntry\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('-r1', '--read1', help='unaligned_read_1 for DenovoIndex',required=True)\nparser.add_argument('-r2', '--read2', help='unaligned_read_2 for DenovoIndex',required=True)\n\nparser.add_argument('-s', '--sample', help='base name used in alignment output files', required=True)\nparser.add_argument('-fl', '--flank_len', help='5\\' and 3\\' flank length to use in SPACHETE, defaults to 25')\n\nargs = parser.parse_args()\n\n\ncombined_out_name = args.sample +\"_combined_reads.fq\"\nnum_total_reads = 0\n\nwith open(combined_out_name, \"w\") as combined_out:\n    with open(args.read1, \"r\") as R1_in_file:\n        header_line = R1_in_file.readline()\n        while header_line:\n            combined_out.write(header_line.strip() + \" R1\\n\")\n            combined_out.write(R1_in_file.readline())  # Write out the seq line\n            combined_out.write(R1_in_file.readline())  # Write out the + line\n            combined_out.write(R1_in_file.readline())  # Write out the quality line\n            header_line = R1_in_file.readline()\n            num_total_reads += 1\n\n\n    with open(args.read2, \"r\") as R2_in_file:\n        header_line = R2_in_file.readline()\n        while header_line:\n            combined_out.write(header_line.strip() + \" R2\\n\")\n            combined_out.write(R2_in_file.readline())  # Write out the seq line\n            combined_out.write(R2_in_file.readline())  # Write out the + line\n            combined_out.write(R2_in_file.readline())  # Write out the quality line\n            header_line = R2_in_file.readline()\n            num_total_reads += 1\n\nprint \"Total number of combined reads: \" + str(num_total_reads)\n\nfive_prime_fq_name = \"5prime_\"+ args.sample +\".fq\"\nthree_prime_fq_name = \"3prime_\"+ args.sample +\".fq\"\n\nread_num_to_read_id = {}\n\nthirds_len = int(args.flank_len)\nread_num_to_id_name = args.sample + \"read_num_to_read_id.pickle\"\n\nread_num = 0\nwith open(five_prime_fq_name, \"w\") as five_prime_file:\n        with open(three_prime_fq_name, \"w\") as three_prime_file:\n            with open(combined_out_name, \"r\") as f_in:\n                read_id = f_in.readline()\n                read_num_format = \"0\"+str(len(str(num_total_reads)))+\"d\"\n                while read_id:\n                    seq = f_in.readline()\n                    plus_line = f_in.readline()\n                    quality = f_in.readline()\n                    fastq_read = FastQEntry(read_id, seq, plus_line, quality)\n                    formatted_read_id = format(read_num,read_num_format)\n                    fastq_read.read_id = \"@\"+formatted_read_id\n\n                    fragment_5, fragment_3 = fastq_read.get_first_last_n(thirds_len)\n                    #Check that both fragments are defined before writing them out\n                    if fragment_5 and fragment_3:\n                        five_prime_file.write(str(fragment_5))\n                        three_prime_file.write(str(fragment_3))\n                        read_num_to_read_id[formatted_read_id] = read_id.strip()\n                        read_num += 1\n                    read_id = f_in.readline()\n\nprint \"Number of reads in splitted fastq files: \" + str(read_num)\n\npickle.dump(read_num_to_read_id,open(read_num_to_id_name,\"wb\"))",
                "filename": "combine_and_split.py"
              },
              {
                "fileContent": "# Fastq entry class\n\n# Imports\nimport sys\n\n\nclass FastQEntry(object):\n    __slots__ = [\"read_id\", \"seq\", \"plus_line\", \"quality\"]\n\n    def __init__(self, read_id, seq, plus_line, quality):\n        \"\"\"\n        Goal: initialize the FastQEntry object with the appropriate info\n        Arguments:\n            all of the fastq lines one at a time\n            read_id, seq, plus_line, and quality\n\n        Returns:\n            nothing\n        \"\"\"\n        self.read_id = read_id\n        self.seq = seq\n        self.plus_line = plus_line\n        self.quality = quality\n        self.clean()\n\n    def get_edge_thirds(self, min_third=20):\n        \"\"\"\n        Goal: split this FastQEntry into a 5' and 3' FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            a tuple of FastQEntry objects [5',3']\n        \"\"\"\n        third_len = len(self.seq) / 3\n        if third_len < min_third:\n            # sys.stderr.write(\"Skipping read too short to split in thirds: \"+self.read_id+\"\\n\")\n            return None, None\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[2 * third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[2 * third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def get_first_last_n(self, third_len=36):\n        \"\"\"\n        Goal: very similar to the edge \n        Arguments:\n            optional length of n to take (defaulted at 36)\n\n        Returns:\n            a tuple of 5' and 3' FastQEntry objects\n        \"\"\"\n        # Check to make sure can at least get the first and last third in length\n        if len(self.seq) <= third_len * 2:\n            # sys.stderr.write(\"SPORK: Skipping read too short to split in thirds: \"+self.read_id+\" len = \"+str(len(self.seq))+\"\\n\")\n            return None, None\n\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[-third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[-third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def clean(self):\n        \"\"\"\n        Goal: clean up the read id, sequence, plus line, and quality\n        Arguments:\n            none\n\n        Returns:\n            nothing\n        \"\"\"\n        # self.read_id = self.read_id.replace(\" \",\"_\").replace(\"\\t\",\"_\").replace(\"\\n\",\"\")\n        self.read_id = self.read_id.replace(\"\\n\", \"\")\n        self.seq = self.seq.replace(\"U\", \"T\").replace(\"\\n\", \"\")\n        self.plus_line = self.plus_line.replace(\" \", \"_\").replace(\"\\n\", \"\")\n        self.quality = self.quality.replace(\"\\n\", \"\")\n\n    def __str__(self):\n        \"\"\"\n        Goal: return an easy to print string of a FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            An output string\n        \"\"\"\n        ret_str = \"\"\n        ret_str += self.read_id + \"\\n\"\n        ret_str += self.seq + \"\\n\"\n        ret_str += self.plus_line + \"\\n\"\n        ret_str += self.quality + \"\\n\"\n        return ret_str\n\n    def __lt__(self, other):\n        \"\"\"\n        Goal: allow comparison between two FastQEntry objects based on read_id\n        Arguments:\n            other is a FastQEntry to compare to\n\n        Returns:\n            True if the read id of this object is 'less' than that of the other\n        \"\"\"\n        return self.read_id < other.read_id",
                "filename": "SPORK_FastQEntry.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\tif($job.inputs.read_1 && $job.inputs.read_1.metadata && $job.inputs.read_1.metadata.sample_id)\n      return \"-s \" + $job.inputs.read_1.metadata.sample_id\n    return \"\"\n}"
            },
            "separate": true
          }
        ],
        "abg:revisionNotes": "flank_len_end instead of flenk_len",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520432928,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 4 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520432958,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "flank_len_end instead of flenk_len",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1533818642,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "label": "Read2",
            "required": false,
            "sbg:category": "Input",
            "id": "#read_2",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "FQ, FASTQ",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-r2",
              "separate": true
            },
            "description": "Unaligned reads2 from KNIFE for DenovoIndex"
          },
          {
            "label": "Read1",
            "required": false,
            "sbg:category": "Input",
            "id": "#read_1",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "FQ, FASTQ",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-r1",
              "separate": true
            },
            "description": "unaligned reads1 from KNIFE for DenovoIndex"
          },
          {
            "sbg:toolDefaultValue": "25",
            "label": "Flank length",
            "sbg:category": "Input",
            "id": "#flank_len_end",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fl",
              "separate": true
            },
            "description": "5' and 3' flank length to use in SPACHETE, defaults to 25."
          }
        ],
        "sbg:image_url": null,
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "read_2": {
              "secondaryFiles": [],
              "path": "/path/to/read_2.ext",
              "class": "File",
              "size": 0
            },
            "read_1": {
              "metadata": {
                "sample_id": "read1"
              },
              "size": 0,
              "path": "/path/to/read_1.ext",
              "class": "File",
              "secondaryFiles": []
            },
            "flank_len_end": 10
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/combine-and-split-unaligned-reads/2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -93.98437500000006,
        "sbg:cmdPreview": "python combine_and_split.py  -s read1",
        "stdin": "",
        "label": "SPORK_combine_and_split_unaligned_reads"
      },
      "inputs": [
        {
          "id": "#SPORK_combine_and_split_unaligned_reads.read_2",
          "source": [
            "#getUnalignedReads_2.denovo_unaligned"
          ]
        },
        {
          "id": "#SPORK_combine_and_split_unaligned_reads.read_1",
          "source": [
            "#getUnalignedReads_1.denovo_unaligned"
          ]
        },
        {
          "id": "#SPORK_combine_and_split_unaligned_reads.flank_len_end",
          "default": 25,
          "source": [
            "#flank_len_end"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_combine_and_split_unaligned_reads.read_num_to_read_id"
        },
        {
          "id": "#SPORK_combine_and_split_unaligned_reads.combined_reads"
        },
        {
          "id": "#SPORK_combine_and_split_unaligned_reads.5prime"
        },
        {
          "id": "#SPORK_combine_and_split_unaligned_reads.3prime"
        }
      ],
      "sbg:x": 1757,
      "sbg:y": -93.98437500000006
    },
    {
      "id": "#Determine_mode",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:image_url": null,
        "sbg:revisionNotes": "lower_junction_overlap, higher_junction_overlap and threshold_junction_overlap",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1520537001,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "revision 14 copied",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1520537016,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:revisionNotes": "lower_junction_overlap, higher_junction_overlap and threshold_junction_overlap",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1535415119,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "class": "CommandLineTool",
        "outputs": [
          {
            "id": "#read_length",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#fastq_files",
              "glob": "*_readlength.txt"
            }
          },
          {
            "id": "#output_mode",
            "type": [
              "null",
              "string"
            ],
            "outputBinding": {
              "outputEval": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n\tif($self)\n    {\n    \treturn $self[0].contents\n    }\n \treturn \"\" \n}"
              },
              "glob": "output_mode.txt",
              "loadContents": true
            }
          },
          {
            "id": "#junction_overlap",
            "type": [
              "null",
              "int"
            ],
            "outputBinding": {
              "outputEval": {
                "engine": "#cwl-js-engine",
                "class": "Expression",
                "script": "{\n\tif($self)\n    {\n    \tread_length  = parseInt($self[0].contents)\n        if(read_length < $job.inputs.threshold_junction_overlap)\n        {\n        \treturn $job.inputs.lower_junction_overlap\n        }\n      \telse\n        {\n        \treturn $job.inputs.higher_junction_overlap\n        }\n    }\n \treturn \"\" \n}"
              },
              "glob": "*_readlength.txt",
              "loadContents": true
            }
          }
        ],
        "description": "",
        "successCodes": [],
        "sbg:modifiedOn": 1535415119,
        "baseCommand": [
          {
            "engine": "#cwl-js-engine",
            "class": "Expression",
            "script": "{\n  \toutput = \"\"\n\text = [].concat($job.inputs.fastq_files)[0].path.split('.').pop()\n     \n\tif(ext == 'gz' || ext == 'GZ')\n    {\t\n      \tfastq_list = [].concat($job.inputs.fastq_files)\n      \toutput = \"gunzip -f \" \n        for(i=0; i < fastq_list.length; i++)\n        \toutput += fastq_list[i].path.split('/').pop() + \" \"\n        output += \"&& python mode.py -fq \"\n        \n        for(i=0; i < fastq_list.length; i++){\n          \t\n          \tfile_name = fastq_list[i].path.split('/').pop().split(\".\").slice(0, -1).join(\".\")\n        \toutput += file_name + \" \"\n        }\n      \t\n      \tif($job.inputs.ntrim)\n        {\n        \toutput += \"-t \" + $job.inputs.ntrim\n        }\n    }\n  \telse\n    {\n    \toutput = \"python mode.py -fq \"\n        fastq_list = [].concat($job.inputs.fastq_files)\n        for(i=0; i < fastq_list.length; i++){\n          \t\n          \tfile_name = fastq_list[i].path.split('/').pop()\n            output += file_name + \" \"\n        }\n      \tif($job.inputs.ntrim)\n        {\n        \toutput += \"-t \" + $job.inputs.ntrim\n        }\n    }\n\treturn output\n}"
          }
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/determine-mode/2",
        "sbg:validationErrors": [],
        "sbg:publisher": "sbg",
        "sbg:latestRevision": 2,
        "temporaryFailCodes": [],
        "sbg:revision": 2,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1520537001,
        "x": 741.8041066250836,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import argparse\n\ndef main():\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(\"-fq\", \"--fastq\", required=True, nargs='+', help=\"fastq files\")\n    parser.add_argument('-s', '--sample', help='base name used in alignment output files', required=True)\n    parser.add_argument('-t', '--ntrim', help='ntrim used in denovo pipeline', type=int, required=True)\n\n    args = parser.parse_args()\n\n    fq_1 = args.fastq[0]\n\n    mode1 = \"complete\"\n    mode2 = \"complete\"\n\n    first = True\n\n    with open(fq_1, \"r\") as f1:\n        line1 = f1.readline()\n        read = f1.readline()\n\n    minReadLen = args.ntrim + 8\n\n    with open(args.sample + \"_readlength.txt\", \"w\") as f_write:\n        f_write.write(str(len(read.strip())))\n\n    print len(read.strip())\n    #if len(read.strip()) < minReadLen and len(args.fastq) < 2:\n    #    raise Exception(\"Single-end read! Read lenght is less then \" + str(minReadLen) + \". Exit!\\n\")\n\n    #if len(read.strip()) < minReadLen:\n    #    raise Exception(\"Read lenght is less then \" + str(minReadLen) + \". Exit!\\n\")\n\n    if len(args.fastq) < 2:\n        raise Exception(\"Single-end sample\\n\")\n\n    fq_2 = args.fastq[1]\n\n    with open(fq_2, \"r\") as f2:\n        line2 = f2.readline()\n    \n    read_id_1 = line1.strip().split(\"\\t\")[0].split(\" \")[0]\n    read_id_2 = line2.strip().split(\"\\t\")[0].split(\" \")[0]\n\n    print read_id_1\n    print read_id_2\n\n    if read_id_1 == read_id_2:\n        print mode1\n        with open(\"output_mode.txt\", \"w\") as f:\n            f.write(mode1)\n            quit(0)\n\n    if read_id_1[-2:] == \"/1\" or read_id_1[-2:] == \".1\":\n        mode1 = \"appended\"\n    elif read_id_1[-2:] == \"/2\" or read_id_1[-2:] == \".2\":\n        mode1 = \"appended\"\n        first=False\n\n\n\n    if first:\n        if read_id_2[-2:] == \"/2\" or read_id_2[-2:] == \".2\":\n            mode2 = \"appended\"\n    elif read_id_2[-2:] == \"/1\" or read_id_2[-2:] == \".1\":\n            mode2 = \"appended\"\n\n    if mode1 == mode2:\n        with open(\"output_mode.txt\", \"w\") as f:\n            print mode1\n            f.write(mode1)\n    else: raise Exception(\"Fastq files do not have the same mode\")\n\nif __name__ == '__main__':\n    main()",
                "filename": "mode.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "jordanski.milos",
          "milos_jordanski"
        ],
        "arguments": [
          {
            "position": 20,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n  \tfastq_files = [].concat($job.inputs.fastq_files)\n\tif (fastq_files[0] && fastq_files[0].metadata && fastq_files[0].metadata.sample_id)\n    {\n    \treturn \"-s \" + fastq_files[0].metadata.sample_id\n    }\n}"
            },
            "separate": true
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#threshold_junction_overlap",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "sbg:altPrefix": "--ntrim",
            "id": "#ntrim",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "id": "#lower_junction_overlap",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "id": "#higher_junction_overlap",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "sbg:altPrefix": "--fastq",
            "id": "#fastq_files",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false,
            "sbg:stageInput": "link"
          }
        ],
        "sbg:createdBy": "milos_jordanski",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "fastq_files": [
              {
                "metadata": {
                  "sample_id": "SAMPLE"
                },
                "path": "fastq_files-string-value-1.fq",
                "secondaryFiles": []
              },
              {
                "path": "fastq_files-string-value-2.fq"
              }
            ],
            "higher_junction_overlap": 18,
            "threshold_junction_overlap": 8,
            "ntrim": 9,
            "lower_junction_overlap": 2
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/determine-mode/2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -148.61183757034277,
        "sbg:cmdPreview": "python mode.py -fq fastq_files-string-value-1.fq fastq_files-string-value-2.fq -t 9  -s SAMPLE",
        "stdin": "",
        "label": "Determine mode",
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/determine-mode/2"
      },
      "inputs": [
        {
          "id": "#Determine_mode.threshold_junction_overlap",
          "source": [
            "#threshold_junction_overlap"
          ]
        },
        {
          "id": "#Determine_mode.ntrim",
          "default": 50
        },
        {
          "id": "#Determine_mode.lower_junction_overlap",
          "source": [
            "#lower_junction_overlap"
          ]
        },
        {
          "id": "#Determine_mode.higher_junction_overlap",
          "source": [
            "#higher_junction_overlap"
          ]
        },
        {
          "id": "#Determine_mode.fastq_files",
          "source": [
            "#fastq_files"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#Determine_mode.read_length"
        },
        {
          "id": "#Determine_mode.output_mode"
        },
        {
          "id": "#Determine_mode.junction_overlap"
        }
      ],
      "sbg:x": 741.8041066250836,
      "sbg:y": -148.61183757034277
    },
    {
      "id": "#SPORK_GetBasesAroundJunctionPoint",
      "run": {
        "sbg:sbgMaintained": false,
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:revisionNotes": "junction_length and script updated",
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1531179098,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:revisionNotes": null,
            "sbg:revision": 1,
            "sbg:modifiedOn": 1531179433,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:revisionNotes": "label updated",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1531179447,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:revisionNotes": "fixed",
            "sbg:revision": 3,
            "sbg:modifiedOn": 1531258933,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:revisionNotes": "junction_length and script updated",
            "sbg:revision": 4,
            "sbg:modifiedOn": 1536540423,
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "class": "CommandLineTool",
        "outputs": [
          {
            "id": "#5prime_fasta",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#far_junctions",
              "glob": "*5prime.fa"
            }
          },
          {
            "id": "#3prime_fasta",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#far_junctions",
              "glob": "*3prime.fa"
            }
          }
        ],
        "baseCommand": [
          "python",
          "get_bases_around_junction_point.py"
        ],
        "arguments": [
          {
            "position": 10,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\tif($job.inputs.far_junctions && $job.inputs.far_junctions.metadata && $job.inputs.far_junctions.metadata.sample_id)\n    {\n    \treturn \"-s \" + $job.inputs.far_junctions.metadata.sample_id\n    }\n  \treturn \"\"\n}"
            },
            "separate": true
          }
        ],
        "sbg:cmdPreview": "python get_bases_around_junction_point.py  -s SAMPLE",
        "successCodes": [],
        "sbg:modifiedOn": 1536540423,
        "sbg:createdBy": "jordanski.milos",
        "id": "milos_jordanski/spachete-salzman-collaboration/spork-getbasesaroundjunctionpoint/4",
        "sbg:validationErrors": [],
        "description": "",
        "sbg:publisher": "sbg",
        "temporaryFailCodes": [],
        "sbg:revision": 4,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "stdout": "",
        "sbg:createdOn": 1531179098,
        "x": 3838.3340596225776,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import argparse\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\"-fj\", \"--farJunctions\", required=True, help=\"farJunctions\")\nparser.add_argument(\"-nb\", \"--number_of_bases\", required=True)\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\n\nnum_bases = int(args.number_of_bases)\njunction_length = int(args.farJunctionLength)\n\nwith open(args.sample + \"_FarJunctions_3prime.fa\", \"w\") as f3prime:\n    with open(args.sample + \"_FarJunctions_5prime.fa\", \"w\") as f5prime:\n        with open(args.farJunctions) as f:\n            while True:\n                line1 = f.readline()\n                if not line1:\n                    break\n                line2 = f.readline()\n                if not line2:\n                    break\n                f3prime.write(line1)\n                f3prime.write(line2[junction_length/2 : junction_length/2 + num_bases] + \"\\n\")\n\n                f5prime.write(line1)\n                f5prime.write(line2[junction_length/2 - num_bases : junction_length/2] + \"\\n\")",
                "filename": "get_bases_around_junction_point.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "stdin": "",
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "inputs": [
          {
            "id": "#number_of_bases",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-nb",
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--farJunctionLength",
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fjl",
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--farJunctions",
            "id": "#far_junctions",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fj",
              "separate": true
            },
            "required": false
          }
        ],
        "sbg:image_url": null,
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "far_junctions": {
              "metadata": {
                "sample_id": "SAMPLE"
              },
              "size": 0,
              "path": "/path/to/far_junctions.ext",
              "class": "File",
              "secondaryFiles": []
            },
            "number_of_bases": 8,
            "junction_length": 4
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/spork-getbasesaroundjunctionpoint/4",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "y": -455.0001209312058,
        "label": "SPORK_GetBasesAroundJunctionPoint",
        "sbg:latestRevision": 4
      },
      "inputs": [
        {
          "id": "#SPORK_GetBasesAroundJunctionPoint.number_of_bases",
          "source": [
            "#number_of_bases"
          ]
        },
        {
          "id": "#SPORK_GetBasesAroundJunctionPoint.junction_length",
          "default": 300
        },
        {
          "id": "#SPORK_GetBasesAroundJunctionPoint.far_junctions",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_GetBasesAroundJunctionPoint.5prime_fasta"
        },
        {
          "id": "#SPORK_GetBasesAroundJunctionPoint.3prime_fasta"
        }
      ],
      "sbg:x": 3838.3340596225776,
      "sbg:y": -455.0001209312058
    },
    {
      "id": "#SPORK_FarJunc_filter_glm_class_file",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK_FarJunc_filter_glm_class_file",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "filter_glm_class_file_new.py",
                "fileContent": "import os\nimport argparse\nfrom bisect import bisect_left\nimport sys\nimport pickle\n\ndef binary_search(a, x, lo=0, hi=None):   # can't use a to specify default for hi\n    hi = hi if hi is not None else len(a) # hi defaults to len(a)\n    pos = bisect_left(a,x,lo,hi)          # find insertion position\n    return (pos if pos != hi and a[pos] == x else -1) # don't walk off the end\n\n\ndef filter_glm_class_file(glm_input_name,used_ids_name):\n\n    filtered_glm_outupt_name = glm_input_name+\".tmp\"\n\n    glm_output = open(filtered_glm_outupt_name,\"w\")\n    for glm_line in open(glm_input_name,\"r\"):\n        glm_read_id = glm_line.split(\"\\t\")[0].strip()\n        #If the glm input is NOT in the used ids names\n        #then write to the glm output\n        res_ind = binary_search(used_read_ids, glm_read_id)\n        if res_ind == -1:\n            glm_output.write(glm_line.strip()+\"\\n\")\n\n    glm_output.flush()\n    glm_output.close()\n\n    prefilter_name = glm_input_name+\".prefilter\"\n    os.rename(glm_input_name,prefilter_name)\n    os.rename(filtered_glm_outupt_name,glm_input_name)\n\nif __name__ == \"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-if', '--input_file', help='class input file')\n    parser.add_argument('-nr', '--naive_report', help='txt file')\n    parser.add_argument('-jwr', '--junctions_with_read_ids', help='pickle file')\n    args = parser.parse_args()\n\n    junctions_with_read_ids = pickle.load(open(args.junctions_with_read_ids, \"rb\"))\n\n    used_read_ids = []\n    with open(args.naive_report, \"r\") as f:\n        while True:\n            line = f.readline()\n            if not line:\n                break\n            if line.startswith(\"@\"):\n                continue\n\n            jct_ind = int(int(line.strip().split(\"\\t\")[0].split(\"=\")[-1]))\n            if jct_ind in junctions_with_read_ids:\n                for read_id in junctions_with_read_ids[jct_ind]:\n                    used_read_ids.append(read_id.split(\" \")[0].split(\"\\t\")[0][1:])\n            else:\n                print \"Something is wrong\"\n                print jct_ind\n                print line\n\n    used_read_ids.sort()\n\n    input_file_name = args.input_file\n    filter_glm_class_file(input_file_name, used_read_ids)"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nr"
            },
            "id": "#naive_report",
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-jwr"
            },
            "id": "#junctions_with_read_ids",
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-if"
            },
            "id": "#input_file",
            "sbg:stageInput": "link",
            "required": false
          }
        ],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tsplitted_path = $job.inputs.input_file.path.split(\"/\")\n    return splitted_path[splitted_path.length - 1]\n}"
              },
              "sbg:inheritMetadataFrom": "#input_file"
            },
            "id": "#filtered_output"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "baseCommand": [
          "python",
          "filter_glm_class_file_new.py"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [],
        "cwlVersion": "sbg:draft-2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550597303,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550598534,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550599564,
            "sbg:revisionNotes": "naive_report parsing finished"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550600627,
            "sbg:revisionNotes": "filtered_output metadata"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550607110,
            "sbg:revisionNotes": "split instead of strip"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550615348,
            "sbg:revisionNotes": "link input file"
          }
        ],
        "sbg:image_url": null,
        "sbg:job": {
          "inputs": {
            "junctions_with_read_ids": {
              "path": "/path/to/junctions_with_read_ids.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "naive_report": {
              "path": "/path/to/naive_report.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "input_file": {
              "path": "/path/to/input_file.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "sbg:cmdPreview": "python filter_glm_class_file_new.py",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/filter-glm-class-file-new/5",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/filter-glm-class-file-new/5",
        "sbg:revision": 5,
        "sbg:revisionNotes": "link input file",
        "sbg:modifiedOn": 1550615348,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1550597303,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 5,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a1a19d8f86e5f85628595c09b8ac3050834723e3d01ed311a869d4f704f07ab2a",
        "x": 4995.001175046009,
        "y": -283.33337457974886
      },
      "inputs": [
        {
          "id": "#SPORK_FarJunc_filter_glm_class_file.naive_report",
          "source": [
            "#SPORK_FarJuncNaiveReport.naive_report"
          ]
        },
        {
          "id": "#SPORK_FarJunc_filter_glm_class_file.junctions_with_read_ids",
          "source": [
            "#SPORK_BadFJ3.junctions_with_read_ids"
          ]
        },
        {
          "id": "#SPORK_FarJunc_filter_glm_class_file.input_file",
          "source": [
            "#SPORK_FarJuncNaiveReport.IDs"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_FarJunc_filter_glm_class_file.filtered_output"
        }
      ],
      "sbg:x": 4995.001175046009,
      "sbg:y": -283.33337457974886
    },
    {
      "id": "#SPORK_FJIndels_filter_glm_class_file",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK_FJIndels_filter_glm_class_file",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "filter_glm_class_file_new.py",
                "fileContent": "import os\nimport argparse\nfrom bisect import bisect_left\nimport sys\nimport pickle\n\ndef binary_search(a, x, lo=0, hi=None):   # can't use a to specify default for hi\n    hi = hi if hi is not None else len(a) # hi defaults to len(a)\n    pos = bisect_left(a,x,lo,hi)          # find insertion position\n    return (pos if pos != hi and a[pos] == x else -1) # don't walk off the end\n\n\ndef filter_glm_class_file(glm_input_name,used_ids_name):\n\n    filtered_glm_outupt_name = glm_input_name+\".tmp\"\n\n    glm_output = open(filtered_glm_outupt_name,\"w\")\n    for glm_line in open(glm_input_name,\"r\"):\n        glm_read_id = glm_line.split(\"\\t\")[0].strip()\n        #If the glm input is NOT in the used ids names\n        #then write to the glm output\n        res_ind = binary_search(used_read_ids, glm_read_id)\n        if res_ind == -1:\n            glm_output.write(glm_line.strip()+\"\\n\")\n\n    glm_output.flush()\n    glm_output.close()\n\n    prefilter_name = glm_input_name+\".prefilter\"\n    os.rename(glm_input_name,prefilter_name)\n    os.rename(filtered_glm_outupt_name,glm_input_name)\n\nif __name__ == \"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-if', '--input_file', help='class input file')\n    parser.add_argument('-nr', '--naive_report', help='txt file')\n    parser.add_argument('-jwr', '--junctions_with_read_ids', help='pickle file')\n    args = parser.parse_args()\n\n    junctions_with_read_ids = pickle.load(open(args.junctions_with_read_ids, \"rb\"))\n\n    used_read_ids = []\n    with open(args.naive_report, \"r\") as f:\n        while True:\n            line = f.readline()\n            if not line:\n                break\n            if line.startswith(\"@\"):\n                continue\n\n            jct_ind = int(int(line.strip().split(\"\\t\")[0].split(\"=\")[-1]))\n            if jct_ind in junctions_with_read_ids:\n                for read_id in junctions_with_read_ids[jct_ind]:\n                    used_read_ids.append(read_id.split(\" \")[0].split(\"\\t\")[0][1:])\n            else:\n                print \"Something is wrong\"\n                print jct_ind\n                print line\n\n    used_read_ids.sort()\n\n    input_file_name = args.input_file\n    filter_glm_class_file(input_file_name, used_read_ids)"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nr"
            },
            "id": "#naive_report",
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-jwr"
            },
            "id": "#junctions_with_read_ids",
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-if"
            },
            "id": "#input_file",
            "sbg:stageInput": "link",
            "required": false
          }
        ],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tsplitted_path = $job.inputs.input_file.path.split(\"/\")\n    return splitted_path[splitted_path.length - 1]\n}"
              },
              "sbg:inheritMetadataFrom": "#input_file"
            },
            "id": "#filtered_output"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "baseCommand": [
          "python",
          "filter_glm_class_file_new.py"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [],
        "cwlVersion": "sbg:draft-2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550597303,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550598534,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550599564,
            "sbg:revisionNotes": "naive_report parsing finished"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550600627,
            "sbg:revisionNotes": "filtered_output metadata"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550607110,
            "sbg:revisionNotes": "split instead of strip"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550615348,
            "sbg:revisionNotes": "link input file"
          }
        ],
        "sbg:image_url": null,
        "sbg:job": {
          "inputs": {
            "junctions_with_read_ids": {
              "path": "/path/to/junctions_with_read_ids.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "naive_report": {
              "path": "/path/to/naive_report.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "input_file": {
              "path": "/path/to/input_file.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "sbg:cmdPreview": "python filter_glm_class_file_new.py",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/filter-glm-class-file-new/5",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/filter-glm-class-file-new/5",
        "sbg:revision": 5,
        "sbg:revisionNotes": "link input file",
        "sbg:modifiedOn": 1550615348,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1550597303,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 5,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a1a19d8f86e5f85628595c09b8ac3050834723e3d01ed311a869d4f704f07ab2a",
        "x": 5713.3342098130415,
        "y": -88.33333463138999
      },
      "inputs": [
        {
          "id": "#SPORK_FJIndels_filter_glm_class_file.naive_report",
          "source": [
            "#SPORK_FarJuncNaiveReport.naive_report"
          ]
        },
        {
          "id": "#SPORK_FJIndels_filter_glm_class_file.junctions_with_read_ids",
          "source": [
            "#SPORK_BadFJ3.junctions_with_read_ids"
          ]
        },
        {
          "id": "#SPORK_FJIndels_filter_glm_class_file.input_file",
          "source": [
            "#SPORK_FJIndels_ClassIDFile.temp_output_FJIndels"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_FJIndels_filter_glm_class_file.filtered_output"
        }
      ],
      "sbg:x": 5713.3342098130415,
      "sbg:y": -88.33333463138999
    },
    {
      "id": "#SPORK_RegIndels_filter_glm_class_file",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK_RegIndels_filter_glm_class_file",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "filter_glm_class_file_new.py",
                "fileContent": "import os\nimport argparse\nfrom bisect import bisect_left\nimport sys\nimport pickle\n\ndef binary_search(a, x, lo=0, hi=None):   # can't use a to specify default for hi\n    hi = hi if hi is not None else len(a) # hi defaults to len(a)\n    pos = bisect_left(a,x,lo,hi)          # find insertion position\n    return (pos if pos != hi and a[pos] == x else -1) # don't walk off the end\n\n\ndef filter_glm_class_file(glm_input_name,used_ids_name):\n\n    filtered_glm_outupt_name = glm_input_name+\".tmp\"\n\n    glm_output = open(filtered_glm_outupt_name,\"w\")\n    for glm_line in open(glm_input_name,\"r\"):\n        glm_read_id = glm_line.split(\"\\t\")[0].strip()\n        #If the glm input is NOT in the used ids names\n        #then write to the glm output\n        res_ind = binary_search(used_read_ids, glm_read_id)\n        if res_ind == -1:\n            glm_output.write(glm_line.strip()+\"\\n\")\n\n    glm_output.flush()\n    glm_output.close()\n\n    prefilter_name = glm_input_name+\".prefilter\"\n    os.rename(glm_input_name,prefilter_name)\n    os.rename(filtered_glm_outupt_name,glm_input_name)\n\nif __name__ == \"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-if', '--input_file', help='class input file')\n    parser.add_argument('-nr', '--naive_report', help='txt file')\n    parser.add_argument('-jwr', '--junctions_with_read_ids', help='pickle file')\n    args = parser.parse_args()\n\n    junctions_with_read_ids = pickle.load(open(args.junctions_with_read_ids, \"rb\"))\n\n    used_read_ids = []\n    with open(args.naive_report, \"r\") as f:\n        while True:\n            line = f.readline()\n            if not line:\n                break\n            if line.startswith(\"@\"):\n                continue\n\n            jct_ind = int(int(line.strip().split(\"\\t\")[0].split(\"=\")[-1]))\n            if jct_ind in junctions_with_read_ids:\n                for read_id in junctions_with_read_ids[jct_ind]:\n                    used_read_ids.append(read_id.split(\" \")[0].split(\"\\t\")[0][1:])\n            else:\n                print \"Something is wrong\"\n                print jct_ind\n                print line\n\n    used_read_ids.sort()\n\n    input_file_name = args.input_file\n    filter_glm_class_file(input_file_name, used_read_ids)"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nr"
            },
            "id": "#naive_report",
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-jwr"
            },
            "id": "#junctions_with_read_ids",
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-if"
            },
            "id": "#input_file",
            "sbg:stageInput": "link",
            "required": false
          }
        ],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tsplitted_path = $job.inputs.input_file.path.split(\"/\")\n    return splitted_path[splitted_path.length - 1]\n}"
              },
              "sbg:inheritMetadataFrom": "#input_file"
            },
            "id": "#filtered_output"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "baseCommand": [
          "python",
          "filter_glm_class_file_new.py"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [],
        "cwlVersion": "sbg:draft-2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550597303,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550598534,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550599564,
            "sbg:revisionNotes": "naive_report parsing finished"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550600627,
            "sbg:revisionNotes": "filtered_output metadata"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550607110,
            "sbg:revisionNotes": "split instead of strip"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550615348,
            "sbg:revisionNotes": "link input file"
          }
        ],
        "sbg:image_url": null,
        "sbg:job": {
          "inputs": {
            "junctions_with_read_ids": {
              "path": "/path/to/junctions_with_read_ids.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "naive_report": {
              "path": "/path/to/naive_report.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "input_file": {
              "path": "/path/to/input_file.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "sbg:cmdPreview": "python filter_glm_class_file_new.py",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/filter-glm-class-file-new/5",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/filter-glm-class-file-new/5",
        "sbg:revision": 5,
        "sbg:revisionNotes": "link input file",
        "sbg:modifiedOn": 1550615348,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1550597303,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 5,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a1a19d8f86e5f85628595c09b8ac3050834723e3d01ed311a869d4f704f07ab2a",
        "x": 6051.668212797962,
        "y": -96.66658282279671
      },
      "inputs": [
        {
          "id": "#SPORK_RegIndels_filter_glm_class_file.naive_report",
          "source": [
            "#SPORK_FarJuncNaiveReport.naive_report"
          ]
        },
        {
          "id": "#SPORK_RegIndels_filter_glm_class_file.junctions_with_read_ids",
          "source": [
            "#SPORK_BadFJ3.junctions_with_read_ids"
          ]
        },
        {
          "id": "#SPORK_RegIndels_filter_glm_class_file.input_file",
          "source": [
            "#MACHETE_RegIndels_ClassIDFile.output_RegIndel"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_RegIndels_filter_glm_class_file.filtered_output"
        }
      ],
      "sbg:x": 6051.668212797962,
      "sbg:y": -96.66658282279671
    },
    {
      "id": "#SPORK_BadFJ3",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK BadFJ3",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# General Imports\nfrom collections import defaultdict\nimport subprocess\nimport itertools\nimport zlib\nimport time\nimport sys\nimport os\nimport re\n\n# Specific Imports\nfrom SPORK_consensus_utils import *\nfrom SPORK_Junction import Junction\nfrom SPORK_BinPair import BinPair\nfrom SPORK_GTFEntry import GTFEntry\nfrom SPORK_SAMEntry import SAMEntry\nfrom SPORK_FastQEntry import FastQEntry\n\n\n\ndef get_ref_seq(read_seq, MD):\n\n    cur_pos = 0\n    reference_string = \"\"\n    k = 0\n    for i, c in enumerate(MD):\n        if c.isdigit():\n            continue\n        if cur_pos != i:\n            num_matches = int(MD[cur_pos:i])\n        else:\n            num_matches = 0\n        reference_string += read_seq[k: k + num_matches]\n        reference_string += c\n        cur_pos = i + 1\n        k = k + num_matches + 1\n    reference_string += read_seq[k:]\n\n    return reference_string\n\n#######################################\n#   Get Reference and GTF from Mode   #\n#######################################\n# Finding the correct reference index based on the mode\n# Human defaults are used and currently the only supported mode\n# Could imagine lots of if else statements with other supported references though\n# Putting this in the utils file should allow for easy reference addition\ndef get_reference_and_gtf_from_mode(ref_dir, abs_path, mode=\"hg19\"):\n    \"\"\"\n    Goal: take in the desired mode and return the index and gtf path\n    Arguments:\n        the path to the circ_ref directory that MACHETE also uses\n        the mode (currently only allows hg19, so this function is mostly for show)\n        will become an 'elif' tree as more and more indicies are added\n\n    Returns:\n        a tuple of (reference_path,gtf_path)\n    \"\"\"\n    # index_path = \"/scratch/PI/horence/rob/index/\"\n    # reference = index_path+\"hg19\"\n    reference = ref_dir\n    gtf_path = \"\"\n    if mode == \"hg19\":\n        sys.stdout.write('SPORK: Reference using hg19\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"hg19_gtfs\")\n        reference = os.path.join(reference, \"hg19_genome\")\n\n    elif mode == \"grch38\":\n        sys.stdout.write('SPORK: Reference using grch38\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"grch38_gtfs\")\n        reference = os.path.join(reference, \"grch38_genome\")\n\n    elif mode == \"mm10\":\n        sys.stdout.write('SPORK: Reference using mm10\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"mm10_gtfs\")\n        reference = os.path.join(reference, \"mm10_genome\")\n\n    return reference, gtf_path\n\n\n#################################\n#   Find Bin Pair Group Ranges  #\n#################################\n# Run through the bin pair groupings to find the end index of each group\n# Example bin pair list:\n# [0] chr10:45_chr10:55\n# [2] chr10:45_chr10:55\n# [3] chr10:98_chr10:99\n# [4] chr10:145_chr10:155\n# [5] chr10:145_chr10:155\n# [6] chr10:145_chr10:155\n#\n# Output: [2,3,6]\ndef find_bin_pair_group_ranges(bin_pairs, constants_dict, bin_pairs_ids):\n    \"\"\"\n    Goal: take in a sorted list of bin_pairs and collapse them to ranges\n    Arguments:\n        bin_pairs is a list[BinPair] of the bin pairs\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        bin_pair_group_ranges which is a list[[start0,stop0],[start1,stop1],...]\n        also filters out groups that have less then a cutoff of members\n    \"\"\"\n    bin_pair_group_ends = []\n    prev_bin_pair = \"\"\n    for bin_pair_ind in range(len(bin_pairs)):\n        curr_bin_pair = bin_pairs[bin_pair_ind].bin_pair\n        if curr_bin_pair != prev_bin_pair:\n            bin_pair_group_ends.append(bin_pair_ind)\n            prev_bin_pair = curr_bin_pair\n\n    # Remove the 0 at the front of the bin_pair list\n    bin_pair_group_ends = bin_pair_group_ends[1:]\n\n    # Add on the last bin_pair end which will necessarily be the end of the bin_pair list\n    bin_pair_group_ends.append(len(bin_pairs))\n\n    # Find the bin pair ranges\n    bin_pair_group_ranges = []\n    to_remove_bin_pairs = []\n    to_keep_bin_pairs = []\n    for bin_pair_ind in range(len(bin_pair_group_ends) - 1):\n        start_ind = bin_pair_group_ends[bin_pair_ind]\n        stop_ind = bin_pair_group_ends[bin_pair_ind + 1]\n        if stop_ind - start_ind >= (constants_dict[\"group_member_cutoff\"]):  # The \"-1\" is for inclusive counting\n            bin_pair_group_ranges.append([start_ind, stop_ind])\n        else:\n            org_bin_pair = bin_pairs[start_ind].bin_pair\n            left_chr = org_bin_pair.split(\":\")[0]\n            left_pos = org_bin_pair.split(\":\")[1].split(\"_\")[0]\n            right_chr = \"_\".join(org_bin_pair.split(\":\")[1].split(\"_\")[1:])\n            right_pos = org_bin_pair.split(\":\")[2].split(\"_\")[0]\n            strand_left = \"+\" if org_bin_pair.split(\":\")[2].split(\"_\")[1][1] == \"-\" else \"-\"\n            strand_right = \"+\" if org_bin_pair.split(\":\")[2].split(\"_\")[1][3] == \"-\" else \"-\"\n\n            reverse_bin_pair = right_chr + \":\" + right_pos + \"_\" + left_chr + \":\" + left_pos + \"_(\" + strand_right + \",\" + strand_left + \")\"\n            if reverse_bin_pair in bin_pairs_ids:\n                bin_pair_group_ranges.append([start_ind, stop_ind])\n                to_keep_bin_pairs.append(org_bin_pair)\n            else:\n                to_remove_bin_pairs.append(org_bin_pair)\n    # print bin_pair_group_ends\n    # print bin_pair_group_ranges\n    # sys.stdout.flush()\n\n    #with open(\"to_remove_bin_pairs.txt\", \"w\") as f:\n    #    for bin_pair in to_remove_bin_pairs:\n    #        f.write(bin_pair + \"\\n\")\n\n    #with open(\"to_keep_bin_pairs.txt\", \"w\") as f:\n    #    for bin_pair in to_keep_bin_pairs:\n    #        f.write(bin_pair + \"\\n\")\n\n    return bin_pair_group_ranges\n\n\n\n################################\n#   Build Junction Sequences   #\n################################\n# Run through the bin_pair_group_ends to perform:\n# (1) checking if there are enough in each group\n# (2) padding the sequences in the first bin\n# (3) creating a consensus in the first bin\n# (4) scoring the consensus in the first bin\n# (5) repeat (2)-(4) for the second bin\n# (6) average the two consensus scores and see if they are below a cutoff\ndef build_junction_sequences(bin_pairs, bin_pair_group_ranges, full_path_name, constants_dict, read_num_to_read_id):\n    \"\"\"\n    Goal: convert the bin_pairs into a junction object for each bin_pair\n    Arguments:\n        bin_pairs is a list[BinPairs]\n        bin_pair_group_ranges is a list[[start0,stop0],[start1,stop1],...] so its a list of list\n        full_path_name is the 'spaces-removed' file that is looked at to get the full sequences\n            -> this is used to build the consensus for the junction\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        denovo_junctions which is a list[Junction]\n    \"\"\"\n    group_member_cutoff = constants_dict[\"group_member_cutoff\"]\n    consensus_score_cutoff = constants_dict[\"consensus_score_cutoff\"]\n    bin_size = constants_dict[\"bin_size\"]\n    #reference = constants_dict[\"reference\"]\n    denovo_junctions = []\n\n    # Look back at the original full path to get seq lines\n    unaligned_file = open(full_path_name, \"r\")\n    unaligned_reads = unaligned_file.readlines()\n    unaligned_file.close()\n    unaligned_reads = [unaligned_reads[ind] for ind in range(len(unaligned_reads)) if ind % 4 == 0 or ind % 4 == 1]\n    id_to_seq = {}\n\n    # Build the dictionary of read_id to the full read\n    for ind in range(0, len(unaligned_reads), 2):\n        key = unaligned_reads[ind].strip()\n        value = unaligned_reads[ind + 1].strip()\n        id_to_seq[key] = value\n\n    # walk through each bin_pair_group\n    #write_time(\"Working on the bin-pairs :\" + str(len(bin_pair_group_ranges)), time.time(), constants_dict[\"timer_file_path\"])\n\n    num_fail_size = 0\n    num_fail_score = 0\n    jct_ind = 0\n    for bin_pair_group_range in bin_pair_group_ranges:\n        # junction_num = \"(\"+str(bin_pair_group_ranges.index(bin_pair_group_range)+1)+\"/\"+str(len(bin_pair_group_ranges))+\")\"\n        # print junction_num\n        # sys.stdout.flush()\n\n        # start_build_junction = time.time()\n        start_ind = bin_pair_group_range[0]\n        stop_ind = bin_pair_group_range[1]\n        group_members = bin_pairs[start_ind:stop_ind]\n\n        # If there are not enough group members then skip this group\n        #if len(group_members) < group_member_cutoff:\n            # sys.stderr.write(\"Skipped group in build junction seqs\\n\") #expecting to have filtered out before this\n            # sys.stderr.write(\"len(group_members) == \"+str(len(group_members))+\"\\n\")\n            #num_fail_size += 1\n            #continue\n\n        # Otherwise start thinking about getting strandedness\n        five_prime_strand = group_members[0].five_prime_strand\n        three_prime_strand = group_members[0].three_prime_strand\n\n        # Find the consensus sequence and score\n        # Takes just the 5' ends to get the pos\n        # the full original unaligned seq\n        mapped_reads = [member.five_prime_SAM for member in group_members]\n        bin_consensus, bin_score = build_and_score_consensus(mapped_reads, five_prime_strand, id_to_seq, bin_size, constants_dict, read_num_to_read_id)\n        took_reverse_compliment = False\n\n        \"\"\"\n        # TODO what do I do if the five and three prime strands are not the same? (this represents a translocation)\n        # If the reverse compliment was taken above then take the rev compliment of the consensus too\n        # NOTE currently just taking reverse compliment whenever the 5' strand is negative to help groupings\n        #   i.e. if have 5' - and 3' + of a jct and 5' + and 3' - of the same jct, they should be collapsed, but won't be\n        #   unless I implement this\n        #if five_prime_strand == \"-\" and three_prime_strand == \"-\":\n        if five_prime_strand == \"-\":\n            group_members = [member.take_reverse_compliment() for member in group_members]\n            bin_consensus = reverse_compliment(bin_consensus)\n            took_reverse_compliment = True\n\n        \"\"\"\n        # If the bin score is good enough then add it\n        if bin_score < consensus_score_cutoff:\n            denovo_junction = Junction(bin_consensus, bin_score, group_members, jct_ind, took_reverse_compliment, constants_dict)\n            denovo_junctions.append(denovo_junction)\n            jct_ind += 1\n        else:\n            num_fail_score += 1\n\n    #write_time(\"Filtered out bin-pairs by size < \" + str(group_member_cutoff) + \" :\" + str(num_fail_size), time.time(), constants_dict[\"timer_file_path\"])\n    #write_time(\"Filtered out bin-pairs by score < \" + str(consensus_score_cutoff) + \" :\" + str(num_fail_score), time.time(), constants_dict[\"timer_file_path\"])\n    #write_time(\"Number of jcts after build jcts: \" + str(jct_ind), time.time(), constants_dict[\"timer_file_path\"])\n    return denovo_junctions\n\n\n##########################\n#   Find Splice Inds V2  #\n##########################\n# Runs bowtie on all of the possible splice sites of all possible junctions\n# Returns a dict keyed by jct_id and valued by a list of cut sites\ndef find_splice_inds_v2(denovo_junctions, constants_dict):\n    \"\"\"\n    Goal: find where in the consensus sequence to make and donor and acceptor cut\n    Arguments:\n        denovo_junctions is a list[Junction]\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        returns a tuple of (jcts_with_splice,jcts_without_splice)\n        to allow for continuing with only jcts that had a splice site found\n\n    Program flow:\n        1. Write all possible splice cuts for all possible\n           consensus seq jcts to a fasta file\n\n        2. Map this file to the genome reference\n           --> Don't allow gaps\n           --> Report the best k unique multiple mappings for each read\n\n        3. Look through the mapping file for each junction to find the best splice site\n           --> Preference should primarily be given to splits that map close to each other\n           --> Next preference is the most amount of the consensus successfully mapped\n    \"\"\"\n\n    # Get parameters from the constants_dict\n    splice_fasta_path = os.path.join(constants_dict[\"output_dir\"], \"putative_splices.fa\")\n    splice_mapped_path = os.path.join(constants_dict[\"output_dir\"], \"putative_splices.sam\")\n    flank_len = constants_dict[\"splice_finding_flank\"]\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    max_mismatches = int(constants_dict[\"splice_finding_allowed_mismatches\"])\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n    n_multimap = \"10\"\n\n    # 1. Write all possible splice cuts for all possible jcts to a fasta\n    #   if seq is abcdefghijklmnopqrstuvwxyz and thirds_len = 10 then you would want:\n    #       [abcdefghij]|[klmnopqrst]uvwxyz\n    #       a[bcdefghijk]|[lmnopqrstu]vwxyz\n    #       ab[cdefghijkl]|[mnopqrstuv]wxyz\n    #       abc[defghijklm]|[nopqrstuvw]xyz\n    #       abcd[efghijklmn]|[opqrstuvwx]yz\n    #       abcde[fghijklmno]|[pqrstuvwxy]z\n    #       abcdef[ghijklmnop]|[qrstuvwxyz]\n    #   where the first [] group is don and second [] group is acc\n    with open(splice_fasta_path, 'w') as splice_fasta:\n        for jct in denovo_junctions:\n            seq = jct.consensus\n            jct_ind = jct.jct_ind\n            for split_ind in range(flank_len, len(seq) - flank_len + 1):\n                don_seq = seq[:split_ind][-flank_len:]\n                acc_seq = seq[split_ind:][:flank_len]\n                base_header = '>' + str(jct_ind) + '_' + str(split_ind)\n\n                splice_fasta.write(base_header + '_don\\n' + don_seq + '\\n')\n                splice_fasta.write(base_header + '_acc\\n' + acc_seq + '\\n')\n\n    # 2. Map the splice fasta to the genome reference\n    with open(splice_mapped_path, \"w\") as splice_mapped:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-hd\", \"--no-unal\", min_score, read_gap_score,\n             ref_gap_score, \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, splice_fasta_path],\n            stdout=splice_mapped)\n\n    # 3. Look through the mapping file for each junction to find the best splice site\n    #   no sorting guarantees so have to read all in at once\n    #   (could pre-sort if this is too mem intensive)\n\n    # Maybe this is poor coding, but splice_dict is a 3-deep default dictionary\n    #   the 1st level is the jct_index\n    #   the 2nd level is the splice_index\n    #   the 3rd level is either 'don' or 'acc'\n    # Could have made a flat dict with a combination key of the levels\n    #   but then I would have to keep track of what the jct and splice indices are\n    splice_dict = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))\n    with open(splice_mapped_path, \"r\") as splice_mapped:\n        for line in splice_mapped:\n            sam = SAMEntry(line)\n            jct_ind, split_ind, kind = sam.read_id.split('_')\n            splice_dict[jct_ind][split_ind][kind].append(sam)\n\n    # Internal splice comparing function\n    def compare_don_acc(best_don, best_acc, test_don, test_acc):\n        # None case\n        if best_don == None and best_acc == None:\n            return test_don, test_acc\n\n        # If one pair is on the same chr and the other is not\n        best_same_chr = best_don.chromosome == best_acc.chromosome\n        test_same_chr = test_don.chromosome == test_acc.chromosome\n        if test_same_chr and not best_same_chr:\n            return test_don, test_acc\n        if best_same_chr and not test_same_chr:\n            return best_don, best_acc\n\n        # NOTE could extend this to do strand comparisons\n\n        # Now the pairs share chr status determine by which dropped less sequence\n        best_len = len(best_don.seq) + len(best_acc.seq)\n        test_len = len(test_don.seq) + len(test_acc.seq)\n        if best_len > test_len:\n            return best_don, best_acc\n        if test_len > best_len:\n            return test_don, test_acc\n\n        # Now determine by number of mismatches\n        best_mismatches = best_don.num_mismatches + best_acc.num_mismatches\n        test_mismatches = test_don.num_mismatches + test_acc.num_mismatches\n        if best_mismatches > test_mismatches:\n            return test_don, test_acc\n        else:\n            return best_don, best_acc\n\n    # Loop through the jcts looking throughout the entire splice_dict\n    jcts_with_splice = []\n    jcts_wout_splice = []\n\n    for jct in denovo_junctions:\n        best_don, best_acc = None, None\n        jct_ind = str(jct.jct_ind)\n        for splice_ind in splice_dict[jct_ind]:\n            dons = splice_dict[jct_ind][splice_ind]['don']\n            accs = splice_dict[jct_ind][splice_ind]['acc']\n\n            # NOTE Just a print out to check for multimappings\n            # if len(dons) > 1 or len(accs) > 1:\n            #    sys.stdout.write('MULTIMAPPING: '+jct_ind+'_'+splice_ind+'\\n')\n\n            for don, acc in itertools.product(dons, accs):\n                best_don, best_acc = compare_don_acc(best_don, best_acc, don, acc)\n\n        # If there is no splice\n        if best_don == None or best_acc == None:\n            jcts_wout_splice.append(jct)\n            continue\n\n        # Otherwise update jct data\n        jct.consensus = best_don.seq + best_acc.seq\n        jct.donor_sam = best_don\n        jct.acceptor_sam = best_acc\n        jcts_with_splice.append(jct)\n\n    # Return the jcts\n    sys.stdout.write('WITH SPLICE: ' + str(len(jcts_with_splice)) + ' WOUT SPLICE:' + str(len(jcts_wout_splice)) + '\\n')\n    return jcts_with_splice, jcts_wout_splice\n\n\n########################\n#   Find Splice Inds   #\n########################\n# Runs bowtie on all of the possible splice sites of all possible junctions\n# Returns a dict keyed by jct_id and valued by a list of cut sites\ndef find_splice_inds(denovo_junctions, constants_dict):\n    \"\"\"\n    Goal: find where in the consensus sequence to make and donor and acceptor cut\n    Arguments:\n        denovo_junctions is a list[Junction]\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        returns a tuple of (jcts_with_splice,jcts_without_splice)\n        to allow for continuing with only jcts that had a splice site found\n    \"\"\"\n    # Gather info from the constants dictionary\n    splice_finder_temp_name = os.path.join(constants_dict[\"output_dir\"], \"splice_finder_temp_\")\n    thirds_len = constants_dict[\"thirds_len\"]\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    max_mismatches = int(constants_dict[\"splice_finding_allowed_mismatches\"])\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    allowed_mappings = constants_dict[\"splice_finding_allowed_mappings\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n\n    # Handle temporary files\n    five_prime_mapped_name = splice_finder_temp_name + \"5_prime.sam\"\n    three_prime_mapped_name = splice_finder_temp_name + \"3_prime.sam\"\n    five_prime_fa_file = splice_finder_temp_name + \"5_prime.fa\"\n    three_prime_fa_file = splice_finder_temp_name + \"3_prime.fa\"\n    five_temp_file = open(five_prime_fa_file, \"w\")\n    three_temp_file = open(three_prime_fa_file, \"w\")\n\n    # Do all the aligning work only if there are no mapped files already\n    if use_prior and os.path.isfile(five_prime_mapped_name) and os.path.isfile(three_prime_mapped_name):\n        write_time(\"--Using existing files in splice ind id\", time.time(), constants_dict[\"timer_file_path\"])\n    else:\n        # Write out all the possible splice sites for every jct out to a 5' and 3' file\n        num_size_excluded = 0\n        avg_cons_len = 0\n        for jct_ind in range(len(denovo_junctions)):\n            sys.stdout.flush()\n            junction = denovo_junctions[jct_ind]\n            cons_len = len(junction.consensus)\n            avg_cons_len = (float(jct_ind * avg_cons_len) / (jct_ind + 1)) + (float(cons_len) / (jct_ind + 1))\n            # splice_map_size = len(junction.consensus)/3\n            # NOTE found that I was forcinng splice sites to be too central if I used the thirds len\n            # NOTE and lost BCR-ABL this way, so instead I'll stick with using 1/3 of the consensus\n            splice_map_size = thirds_len\n            # sys.stderr.write(\"Cons len \"+str(cons_len)+\" and thirds_len \"+str(splice_map_size)+\"\\n\")\n\n            five_prime_list = [junction.consensus[ind:ind + splice_map_size]\n                               for ind in range(0, cons_len - 2 * splice_map_size + 1)]\n\n            three_prime_list = [junction.consensus[ind:ind + splice_map_size]\n                                for ind in range(splice_map_size, cons_len - splice_map_size + 1)]\n\n            # Oh this is my problem, sometimes the consensus length is too small\n            # to try and find splice inds from, so I should just throw that out and iterate,\n            # otherwise I'll have blank lines added to my splice ind fa files and they will be\n            # incorrectly formatted\n            if len(five_prime_list) == 0 or len(three_prime_list) == 0:\n                num_size_excluded += 1\n                continue\n\n            five_prime_fa_list = [\">jct_\" + str(jct_ind) + \"_ind_\" + str(ind) + \"\\n\"\n                                  + five_prime_list[ind] for ind in range(len(five_prime_list))]\n\n            three_prime_fa_list = [\">jct_\" + str(jct_ind) + \"_ind_\" + str(ind) + \"\\n\"\n                                   + three_prime_list[ind] for ind in range(len(three_prime_list))]\n\n            five_temp_file.write(\"\\n\".join(five_prime_fa_list) + \"\\n\")\n            three_temp_file.write(\"\\n\".join(three_prime_fa_list) + \"\\n\")\n\n        # Don't forget to close the files :)\n        five_temp_file.close()\n        three_temp_file.close()\n        sys.stdout.write(\"SPORK: Average consensus length [\" + str(avg_cons_len) + \"]\\n\")\n        sys.stdout.write(\"SPORK: Splitting fqs, size excluded [\" + str(num_size_excluded) + \"] of [\" + str(\n            len(denovo_junctions)) + \"]\\n\")\n\n        # Map the temp files above to the reference and save in temp sam files\n        # Need to specify the -f flag because the inputs are fasta files\n        with open(five_prime_mapped_name, \"w\") as five_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-x\", reference, five_prime_fa_file], stdout=five_prime_mapped)\n\n        with open(three_prime_mapped_name, \"w\") as three_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-x\", reference, three_prime_fa_file], stdout=three_prime_mapped)\n\n        # Map the temp files above to the reference and save in temp sam files\n        # Need to specify the -f flag because the inputs are fasta files\n        \"\"\"\n        n_multimap = \"10\"\n        with open(five_prime_mapped_name,\"w\") as five_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, five_prime_fa_file], stdout=five_prime_mapped)\n\n        with open(three_prime_mapped_name,\"w\") as three_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, three_prime_fa_file], stdout=three_prime_mapped)\n        \"\"\"\n\n        # Sort the temp output files after removing the header lines\n        p1 = subprocess.Popen([\"grep\", \"-v\", \"@\", five_prime_mapped_name], stdout=subprocess.PIPE)\n        p2 = subprocess.Popen([\"sort\", \"-o\", five_prime_mapped_name], stdin=p1.stdout)\n        p2.communicate()\n\n        p3 = subprocess.Popen([\"grep\", \"-v\", \"@\", three_prime_mapped_name], stdout=subprocess.PIPE)\n        p4 = subprocess.Popen([\"sort\", \"-o\", three_prime_mapped_name], stdin=p3.stdout)\n        p4.communicate()\n\n    # Open the mapped, sorted, headerless files\n    five_prime_sam_file = open(five_prime_mapped_name, \"r\")\n    three_prime_sam_file = open(three_prime_mapped_name, \"r\")\n\n    # Try and find the best splice sites walking through both files at once\n    best_splices = {}\n    sam_five_list = []\n    sam_three_list = []\n    prev_jct_ind = 0\n    five_sam_line = five_prime_sam_file.readline()\n    three_sam_line = three_prime_sam_file.readline()\n    while five_sam_line and three_sam_line:\n        sys.stdout.flush()\n        five_sam_entry = SAMEntry(five_sam_line)\n        three_sam_entry = SAMEntry(three_sam_line)\n\n        five_jct_ind = int(five_sam_entry.read_id.split(\"_\")[1])\n        three_jct_ind = int(three_sam_entry.read_id.split(\"_\")[1])\n\n        # Both the 5' and 3' sam are the prev_jct_ind\n        if five_jct_ind == prev_jct_ind and three_jct_ind == prev_jct_ind:\n            if five_sam_entry.num_mismatches <= max_mismatches:\n                sam_five_list.append(five_sam_entry)\n            if three_sam_entry.num_mismatches <= max_mismatches:\n                sam_three_list.append(three_sam_entry)\n            five_sam_line = five_prime_sam_file.readline()\n            three_sam_line = three_prime_sam_file.readline()\n\n        # Only the 5' sam is at the prev_jct_ind\n        elif five_jct_ind == prev_jct_ind:\n            if five_sam_entry.num_mismatches <= max_mismatches:\n                sam_five_list.append(five_sam_entry)\n            five_sam_line = five_prime_sam_file.readline()\n\n        # Only the 3' sam is at the prev_jct_ind\n        elif three_jct_ind == prev_jct_ind:\n            if three_sam_entry.num_mismatches <= max_mismatches:\n                sam_three_list.append(three_sam_entry)\n            three_sam_line = three_prime_sam_file.readline()\n\n        # Niether the 5' nor 3' sam is at the prev_jct_ind\n        else:\n            # RB 11/18/16 Filter out 5' and 3' sams if chroms are not the same as the unsplit\n            # RB 11/21/16 Also imposing a radius on the same chromosome filter (start at 30, very tight)\n            # RB 05/26/17 Actually I don't want to impose this restriction, would be ok with\n            #            different alignments than the original\n            #            this boils down to just commenting out this 'extra' filtering\n            radius = 30\n            pj = denovo_junctions[prev_jct_ind]\n\n            \"\"\"\n            sam_five_list = [sam for sam in sam_five_list\n                             if (sam.chromosome == pj.donor_sam.chromosome and \n                                 abs(pj.donor_sam.start-sam.start) < radius)]\n\n            sam_three_list = [sam for sam in sam_three_list\n                              if (sam.chromosome == pj.acceptor_sam.chromosome and \n                                  abs(pj.acceptor_sam.start-sam.start) < radius)]\n            \"\"\"\n\n            # Get the best 5' and 3' pair of Sams\n            prev_consensus = pj.consensus\n            # best_five,best_three = get_best_splice(sam_five_list,sam_three_list,prev_consensus,max_mismatches)\n            best_five, best_three = get_multi_best_splice(sam_five_list, sam_three_list, prev_consensus, max_mismatches)\n\n            best_splices[prev_jct_ind] = [best_five, best_three]\n            sam_five_list = []\n            sam_three_list = []\n            prev_jct_ind = min(five_jct_ind, three_jct_ind)\n\n    # Have to push the last jct lists into the shared_dict\n    pj = denovo_junctions[prev_jct_ind]\n    prev_consensus = pj.consensus\n    sam_five_list = [sam for sam in sam_five_list if sam.chromosome == pj.donor_sam.chromosome]\n    sam_three_list = [sam for sam in sam_three_list if sam.chromosome == pj.acceptor_sam.chromosome]\n\n    # best_five,best_three = get_best_splice(sam_five_list,sam_three_list,prev_consensus,max_mismatches)\n    best_five, best_three = get_multi_best_splice(sam_five_list, sam_three_list, prev_consensus, max_mismatches)\n    best_splices[prev_jct_ind] = [best_five, best_three]\n\n    # Close the 5' and 3' sam files\n    five_prime_sam_file.close()\n    three_prime_sam_file.close()\n\n    # Loop through the jcts assigning the splice site info\n    jcts_with_splice = []\n    jcts_without_splice = []\n    for jct_ind in range(len(denovo_junctions)):\n        sys.stdout.flush()\n        jct = denovo_junctions[jct_ind]\n\n        # Use calculted best splice if was previously found and both the\n        # donor and acceptor elements exist\n        if jct_ind in best_splices and all([sam.exists for sam in best_splices[jct_ind]]):\n            donor_sam, acceptor_sam = best_splices[jct_ind]\n\n            # Need to include the donor seq not used in splitting\n            # gets complicated by + and - strand\n            donor_ind = int(donor_sam.read_id.split(\"_ind_\")[1])\n            donor_len = len(donor_sam.seq)\n            up_remaining = jct.consensus[:donor_ind]\n            if donor_sam.strand == \"+\":\n                donor_sam.seq = up_remaining + donor_sam.seq\n                donor_sam.start -= len(up_remaining)\n            elif donor_sam.strand == \"-\":\n                donor_sam.seq = up_remaining + reverse_compliment(donor_sam.seq)\n                donor_sam.stop += len(up_remaining)\n            jct.donor_sam = donor_sam\n\n            # Need to include the acceptor seq not used in splitting\n            # gets complicated by + and - strand\n            acceptor_ind = int(acceptor_sam.read_id.split(\"_ind_\")[1])\n            acceptor_len = len(acceptor_sam.seq)\n            down_remaining = jct.consensus[acceptor_ind + 2 * acceptor_len:]\n            if acceptor_sam.strand == \"+\":\n                acceptor_sam.seq = acceptor_sam.seq + down_remaining\n                acceptor_sam.stop += len(down_remaining) - 1\n            elif acceptor_sam.strand == \"-\":\n                acceptor_sam.seq = reverse_compliment(acceptor_sam.seq) + down_remaining\n                acceptor_sam.start -= len(down_remaining)\n            jct.acceptor_sam = acceptor_sam\n\n            jcts_with_splice.append(jct)\n\n        # If either the donor or acceptor doesn't map (or both), add it to the\n        # jcts_without_splice list instead NOTE this list is currently not used\n        else:\n            jcts_without_splice.append(jct)\n\n    # Choose either the forward or reverse form of the junction that yields\n    # the smaller donor site since this will help collapsing in the next step\n    # (could have chosen larger donor etc, just to flip them all same way)\n\n    write_time(\"Num Jcts w/ splice = \" + str(len(jcts_with_splice)), time.time(), timer_file_path)\n    write_time(\"Num Jcts w/out splice = \" + str(len(jcts_without_splice)), time.time(), timer_file_path)\n\n    small_don_jcts_with_splice = []\n    for jct in jcts_with_splice:\n        if jct.donor_sam.donor() < jct.acceptor_sam.acceptor():\n            small_don_jcts_with_splice.append(jct)\n        else:\n            small_don_jcts_with_splice.append(jct.yield_reverse())\n\n    # Return the jcts w/ and w/out splice separately\n    return small_don_jcts_with_splice, jcts_without_splice\n\n\n#######################\n#   Get Best Splice   #\n#######################\n# This is a helper function for the splice site finder\n# If there are multiple found splice, return the best from the shared sams dict from the two sam lists\ndef get_best_splice(sam_five_list, sam_three_list, consensus, max_mismatches):\n    \"\"\"\n    Goal: given a list of possible splice, return the best one for a junction\n    Arguments:\n        sam_five_list is a list[SAMEntry] for possible 5' cuts\n        sam_three_list is a list[SAMEntry] for possible 3' cuts\n        consensus is a str and the consensus sequence of this junction\n        max_mismatches is the maximum allowed mismatches in total for the 5' and 3' sides\n\n    Returns:\n        a tuple of the (best_5'_sam,best_3'_sam) to then be stored in the junction\n    \"\"\"\n    shared_dict = {}\n    id_dict = {}\n    best_sam_five = SAMEntry()\n    best_sam_five_len = 0\n    best_sam_three = SAMEntry()\n    best_sam_three_len = 0\n\n    # Populate the id_dict to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 5' mapping\n    for sam_five in sam_five_list:\n        id_dict[sam_five.read_id] = sam_five\n        if len(sam_five.seq) > best_sam_five_len:\n            best_sam_five_len = len(sam_five.seq)\n            best_sam_five = sam_five\n\n    # Check the id_dict to see if the 3' has a perfect 5' match\n    # Also keep track of the best (longest) 3' mapping\n    for sam_three in sam_three_list:\n        if len(sam_three.seq) > best_sam_three_len:\n            best_sam_three_len = len(sam_three.seq)\n            best_sam_three = sam_three\n        if sam_three.read_id in id_dict:\n            sam_five = id_dict[sam_three.read_id]\n            shared_dict[sam_three.read_id] = [sam_five, sam_three]\n\n    # Now pick out the best sam's to use\n    # If there is at least one shared perfect splice ind find the one w/ least mismatches\n    # then choose the perfect pair that has the least mismatches\n    if len(shared_dict) > 0:\n        best_key = \"\"\n        min_mismatches = max_mismatches + 1\n        for key in shared_dict:\n            sam1, sam2 = shared_dict[key]\n            num_mismatches = sam1.num_mismatches + sam2.num_mismatches\n            if best_key == \"\" or num_mismatches < min_mismatches:\n                best_key = key\n                min_mismatches = num_mismatches\n        best_five_sam, best_three_sam = shared_dict[best_key]\n        return best_five_sam, best_three_sam\n\n    # Otherwise there is a mapping for the left and right pieces, although there is space in between\n    # NOTE is it possible that the best 5' and 3' seqs have overlap in the middle?\n    else:\n        return best_sam_five, best_sam_three\n\n\n#############################\n#   Get Multi Best Splice   #\n#############################\n# This is a helper function for the splice site finder that takes into account\n# If there are multiple found splice, return the best from the shared sams dict from the two sam lists\ndef get_multi_best_splice(sam_five_list, sam_three_list, consensus, max_mismatches):\n    \"\"\"\n    Goal: given a list of possible splice, return the best one for a junction\n    Arguments:\n        sam_five_list is a list[SAMEntry] for possible 5' cuts\n        sam_three_list is a list[SAMEntry] for possible 3' cuts\n        consensus is a str and the consensus sequence of this junction\n        max_mismatches is the maximum allowed mismatches in total for the 5' and 3' sides\n\n    Returns:\n        a tuple of the (best_5'_sam,best_3'_sam) to then be stored in the junction\n    \"\"\"\n    shared_dict = defaultdict(list)\n    sam_fives = defaultdict(list)\n    sam_threes = defaultdict(list)\n    best_sam_five = SAMEntry()\n    best_sam_five_len = 0\n    best_sam_three = SAMEntry()\n    best_sam_three_len = 0\n\n    # Populate the sam_fives to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 5' mapping\n    for sam_five in sam_five_list:\n        sam_fives[sam_five.read_id].append(sam_five)\n        if len(sam_five.seq) > best_sam_five_len:\n            best_sam_five_len = len(sam_five.seq)\n            best_sam_five = sam_five\n\n    # Populate the sam_threes to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 3' mapping\n    for sam_three in sam_three_list:\n        sam_threes[sam_three.read_id].append(sam_three)\n        if len(sam_three.seq) > best_sam_three_len:\n            best_sam_three_len = len(sam_three.seq)\n            best_sam_three = sam_three\n\n    # Check the id_dict to see if the 5' has a perfect 3' match\n    # Within the perfect match, if there are multi maps choose the one that is closest together\n    # NOTE the internal loop is O(n^2) but n = 10 right now so not too bad\n    for id_key in sam_fives:\n        if id_key in sam_threes:\n            fives = sam_threes[id_key]\n            threes = sam_threes[id_key]\n\n            # For each split index propose the one where the 5' and 3' are the closest\n            # and put this in the shared_dict\n            best_five = fives[0]\n            best_three = threes[0]\n            for five in fives[1:]:\n                for three in threes[1:]:\n                    # If the current best are on different chroms\n                    if best_five.chromosome != best_three.chromosome:\n                        if five.chromosome == three.chromosome:\n                            best_five = five\n                            best_three = three\n\n                    # If the current best are on the same chroms\n                    else:\n                        if five.chromosome == three.chromosome:\n                            if abs(five.start - three.start) < abs(best_five.start - best_three.start):\n                                best_five = five\n                                best_three = three\n\n            shared_dict[id_key] = [best_five, best_three]\n\n    # Now pick out the best sam's to use\n    # If there is at least one shared perfect splice ind find the one w/ least mismatches\n    # then choose the perfect pair that has the least mismatches\n    if len(shared_dict) > 0:\n        best_key = \"\"\n        min_mismatches = max_mismatches + 1\n        for key in shared_dict:\n            sam1, sam2 = shared_dict[key]\n            num_mismatches = sam1.num_mismatches + sam2.num_mismatches\n            if best_key == \"\" or num_mismatches < min_mismatches:\n                best_key = key\n                min_mismatches = num_mismatches\n        best_five_sam, best_three_sam = shared_dict[best_key]\n        return best_five_sam, best_three_sam\n\n    # Otherwise there is a mapping for the left and right pieces, although there is space in between\n    # NOTE is it possible that the best 5' and 3' seqs have overlap in the middle?\n    else:\n        return best_sam_five, best_sam_three\n\n\n##########################\n#   Filter Map Quality   #\n##########################\n# Function to take in Junctions after Splice Ind finding and map pieces right around ind\n# to filter out degenerate or multiple mapping pieces. Currently uses a hard threshold\ndef filter_map_quality(jcts, constants_dict):\n    \"\"\"\n    Goal: Map left and right 25-mers of splice ind and filter out jcts by mapping score\n    Arguments:\n        jcts is a list of type Junction\n        constants dict has all the constants used in the program\n\n    Returns:\n        (pass_jcts,fail_jcts, anom_jcts) is a tuple of \n            (1) list of type Junction of jcts that passed\n            (2) list of type Junction of jcts that failed\n            (3) list of type Junction of jcts that had some other error\n    \"\"\"\n\n    # Add map qualities and only keep those above the cutoff\n    mq_cutoff = constants_dict[\"mq_cutoff\"]\n    mq_len = constants_dict[\"mq_len\"]\n\n    # mqmallg=unique(mallg[(!is.na(match( paste(mallg$junction),paste(mq[mq3+mq5>lower.mq]$junction))))])\n\n    # Write out temp fasta for Bowtie2 calls\n    temp_fasta_name = os.path.join(constants_dict[\"output_dir\"], \"mapq_temp.fasta\")\n    with open(temp_fasta_name, \"w\") as temp_fasta:\n        for ind, jct in enumerate(jcts):\n            seq = jct.consensus\n            don_seq = seq[:jct.splice_ind()][-mq_len:]  # Get the last mq_len bases before splice\n            acc_seq = seq[jct.splice_ind():][:mq_len]  # Get the first mq_len bases after splice\n            temp_fasta.write(\">jct_\" + str(ind) + \"_don\" + \"\\n\" + don_seq + \"\\n\")\n            temp_fasta.write(\">jct_\" + str(ind) + \"_acc\" + \"\\n\" + acc_seq + \"\\n\")\n\n    # Get bowtie2 parameter constants\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n    mq_mapped_name = os.path.join(constants_dict[\"output_dir\"], \"mapq_mapped.sam\")\n\n    # Call bowtie2 to get map qualities\n    with open(mq_mapped_name, \"w\") as mq_mapped:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n             \"-x\", reference, temp_fasta_name], stdout=mq_mapped)\n\n    # Go through the mapped output file\n    pass_jcts = []\n    fail_jcts = []\n    anom_jcts = []\n    with open(mq_mapped_name, \"r\") as mq_mapped:\n        sam_line = mq_mapped.readline()\n\n        while sam_line:\n            # Skip header lines\n            if \"@\" in sam_line:\n                sam_line = mq_mapped.readline()\n                continue\n\n            # Get sam entry 1\n            sam_entry_1 = SAMEntry(sam_line)\n            x, jct_ind_1, don = sam_entry_1.read_id.split(\"_\")\n            jct_ind_1 = int(jct_ind_1)\n\n            # Get sam entry 2\n            sam_line = mq_mapped.readline()\n            sam_entry_2 = SAMEntry(sam_line)\n            if not sam_line:\n                anom_jcts.append(jcts[jct_ind_1])\n                continue\n            x, jct_ind_2, acc = sam_entry_2.read_id.split(\"_\")\n            jct_ind_2 = int(jct_ind_2)\n\n            # Check for different anomalous cases where a don/acc doesn't appear in output\n            # If any anomally is hit we start w/ sam_entry_2 next loop, don't advance\n            if don != \"don\" or acc != \"acc\" or jct_ind_1 != jct_ind_2:\n                anom_jcts.append(jcts[jct_ind_1])\n                continue\n\n            # Otherwise if they are don/acc from the same jct check if they passed mq_cutoff\n            jct_mapq = sam_entry_1.mapping_quality + sam_entry_2.mapping_quality\n            jcts[jct_ind_1].mapq = jct_mapq\n            if jct_mapq > mq_cutoff:\n                pass_jcts.append(jcts[jct_ind_1])\n            else:\n                fail_jcts.append(jcts[jct_ind_1])\n\n            # Move on to the next line\n            sam_line = mq_mapped.readline()\n\n    # Return the passed, failed, and anomalous jcts\n    return (pass_jcts, fail_jcts, anom_jcts)\n\n\n#####################\n#   Generate GTFS   #\n#####################\n# Helper function to generate a list of gtf objects from a gtf path full of gtf files\ndef generate_gtfs(gtf_path, allowed_feature_types=[\"exon\"]):\n    \"\"\"\n    Goal: open all the gtf_files and put all gtf objects in a list from the given path\n    Arguments:\n        gtf_file_name is the full path to the gtf files\n        allowed_feature_types is a list of string specifiying which feature types to add (default 'exon' only)\n\n    Returns:\n        gtfs is a list[GTFEntry]\n    \"\"\"\n    gtfs = []\n    gtf_file_names = [gtf_name for gtf_name in os.listdir(gtf_path) if \"gtf\" in gtf_name]\n    for gtf_file_name in gtf_file_names:\n        abs_gtf_file_path = os.path.join(gtf_path, gtf_file_name)\n        # sys.stdout.write(\"Reading in GTF file \"+abs_gtf_file_path+\"\\n\")\n        with open(abs_gtf_file_path, \"r\") as gtf_file:\n            for gtf_line in gtf_file.readlines():\n                # RB 6/6/17: Try to skip common header lines to avoid parsing error\n                if gtf_line[0] == '#' or gtf_line[0] == '@':\n                    continue\n                gtf = GTFEntry(gtf_line)\n                if gtf.feature in allowed_feature_types:\n                    gtfs.append(gtf)\n\n    sys.stdout.write('Len GTFs: ' + str(len(gtfs)) + '\\n')\n    return gtfs\n\n\n########################\n#   Get JCT GTF info   #\n########################\ndef get_jct_gtf_info(junctions, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs):\n    \"\"\"\n    Goal: for each junction find the closest gtf for donor and acceptor\n    Arguments:\n        junctions is a list[Junction]\n        gtfs is a list[GTF]\n\n    Returns:\n        nothing (just updates the junction objects as pass-by-reference)\n    \"\"\"\n    # Separate the gtfs by chromosome into a dictionary\n\n\n    for junction in junctions:\n        closest_results = find_closest_gtf(junction, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs)\n        if closest_results[\"donor\"] and not junction.best_don_list and not junction.rev_best_don_list:\n            junction.donor_sam.gtf = closest_results[\"donor\"]\n        elif closest_results[\"donor\"] and not junction.rev_best_don_list:\n            for index in range(len(closest_results[\"donor\"])):\n                junction.best_don_list[index].gtf = closest_results[\"donor\"][index]\n        elif closest_results[\"donor\"] and not junction.best_don_list:\n            for index in range(len(closest_results[\"donor\"])):\n                junction.rev_best_don_list[index].gtf = closest_results[\"donor\"][index]\n\n        if closest_results[\"acceptor\"] and not junction.best_acc_list and not junction.rev_best_acc_list:\n            junction.acceptor_sam.gtf = closest_results[\"acceptor\"]\n        elif closest_results[\"acceptor\"] and not junction.rev_best_acc_list:\n            for index in range(len(closest_results[\"acceptor\"])):\n                junction.best_acc_list[index].gtf = closest_results[\"acceptor\"][index]\n        elif closest_results[\"acceptor\"] and not junction.best_acc_list:\n            for index in range(len(closest_results[\"acceptor\"])):\n                junction.rev_best_acc_list[index].gtf = closest_results[\"acceptor\"][index]\n\n\n#################################\n#        Find Closest GTF       #\n#################################\ndef find_closest_gtf(jct, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs):\n    \"\"\"\n    Goal: make it easier to call find closest gtf of donor and acceptor w/out code duplication\n    Arguments:\n        takes in a single junction\n        takes in chrom_gtfs_don which is a dict[\"chrom\":list[GTFEntry]] sorted by donor\n        takes in chrom_gtfs_acc which is a dict[\"chrom\":list[GTFEntry]] sorted by acceptor\n\n    Returns:\n        closest_results which is a dictionary keyed by\n        -> closest_results[\"donor\"] -> GTFEntry\n        -> closest_results[\"acceptor\"] -> GTFEntry\n    \"\"\"\n    closest_results = {\"donor\": None, \"acceptor\": None}\n\n    # Find the closest donor sam gtf\n    if jct.donor_sam.exists and not jct.best_don_list and not jct.rev_best_don_list:\n        query = jct.donor_sam.donor()\n        chrom = jct.donor_sam.chromosome\n        chrom_key = chrom + jct.donor_sam.strand\n        if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(chrom_don_libs[chrom_key])>0 and len(chrom_gtfs_don[chrom_key])>0:\n            gtfs_don = chrom_gtfs_don[chrom_key]\n            don_lib = chrom_don_libs[chrom_key]\n            # closest_don_ind,its = bin_search_gtf(query,don_lib)\n\n            closest_don_ind = brute_search_gtf(query, don_lib)  # <-- RB trying brute force\n            closest_results[\"donor\"] = gtfs_don[closest_don_ind]\n\n    elif jct.donor_sam.exists and not jct.rev_best_don_list:\n        closest_results[\"donor\"] = []\n        for index in range(len(jct.best_don_list)):\n            query = jct.best_don_list[index].donor()\n            chrom = jct.best_don_list[index].chromosome\n            chrom_key = chrom + jct.best_don_list[index].strand\n            if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(chrom_don_libs[chrom_key]) > 0 and len(\n                    chrom_gtfs_don[chrom_key]) > 0:\n                gtfs_don = chrom_gtfs_don[chrom_key]\n                don_lib = chrom_don_libs[chrom_key]\n                closest_don_ind = brute_search_gtf(query, don_lib)\n                closest_results[\"donor\"].append(gtfs_don[closest_don_ind])\n\n    elif jct.donor_sam.exists and not jct.best_don_list:\n        closest_results[\"donor\"] = []\n        for index in range(len(jct.rev_best_don_list)):\n            query = jct.rev_best_don_list[index].donor()\n            chrom = jct.rev_best_don_list[index].chromosome\n            chrom_key = chrom + jct.rev_best_don_list[index].strand\n            if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(\n                    chrom_don_libs[chrom_key]) > 0 and len(\n                    chrom_gtfs_don[chrom_key]) > 0:\n                gtfs_don = chrom_gtfs_don[chrom_key]\n                don_lib = chrom_don_libs[chrom_key]\n                closest_don_ind = brute_search_gtf(query, don_lib)\n                closest_results[\"donor\"].append(gtfs_don[closest_don_ind])\n\n    # Find the closest acceptor sam gtf\n    if jct.acceptor_sam.exists and not jct.best_acc_list and not jct.rev_best_acc_list:\n        query = jct.acceptor_sam.acceptor()\n        chrom = jct.acceptor_sam.chromosome\n        chrom_key = chrom + jct.acceptor_sam.strand\n        if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(chrom_gtfs_acc[chrom_key])>0 and len(chrom_acc_libs[chrom_key])>0:\n            gtfs_acc = chrom_gtfs_acc[chrom_key]\n            acc_lib = chrom_acc_libs[chrom_key]\n            # closest_acc_ind,its = bin_search_gtf(query,acc_lib)\n            closest_acc_ind = brute_search_gtf(query, acc_lib)  # <-- RB trying brute force\n            closest_results[\"acceptor\"] = gtfs_acc[closest_acc_ind]\n    elif jct.acceptor_sam.exists and not jct.rev_best_acc_list:\n        closest_results[\"acceptor\"] = []\n        for index in range(len(jct.best_acc_list)):\n            query = jct.best_acc_list[index].acceptor()\n            chrom = jct.best_acc_list[index].chromosome\n            chrom_key = chrom + jct.best_acc_list[index].strand\n            if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(\n                    chrom_gtfs_acc[chrom_key]) > 0 and len(chrom_acc_libs[chrom_key]) > 0:\n                gtfs_acc = chrom_gtfs_acc[chrom_key]\n                acc_lib = chrom_acc_libs[chrom_key]\n                closest_acc_ind = brute_search_gtf(query, acc_lib)\n                closest_results[\"acceptor\"].append(gtfs_acc[closest_acc_ind])\n\n    elif jct.acceptor_sam.exists and not jct.best_acc_list:\n        closest_results[\"acceptor\"] = []\n        for index in range(len(jct.rev_best_acc_list)):\n            query = jct.rev_best_acc_list[index].acceptor()\n            chrom = jct.rev_best_acc_list[index].chromosome\n            chrom_key = chrom + jct.rev_best_acc_list[index].strand\n            if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(\n                    chrom_gtfs_acc[chrom_key]) > 0 and len(chrom_acc_libs[chrom_key]) > 0:\n                gtfs_acc = chrom_gtfs_acc[chrom_key]\n                acc_lib = chrom_acc_libs[chrom_key]\n                closest_acc_ind = brute_search_gtf(query, acc_lib)\n                closest_results[\"acceptor\"].append(gtfs_acc[closest_acc_ind])\n\n    return closest_results\n\n\n#################################\n#    Binary Search Closest GTF  #\n#################################\n# Recursive binary search function\n# NOTE this could probably be sped up using bisectleft, but I doubt by much\ndef bin_search_gtf(query, library, start_ind=0, end_ind=-1, its=1, disp=False):\n    \"\"\"\n    Goal: do a binary search through the library for the closest ind\n    Arguments:\n        query is an int\n        library is a list[int] of genomic positions to look through\n        start_ind is defaulted to 0 and keeps track of where to look\n        end_ind is defaulted to -1 and keeps track of where to look\n\n    Returns:\n        the index of the closest matching library value to the query\n    \"\"\"\n    # First iteration\n    if its == 1 and end_ind == -1:\n        end_ind = len(library) - 1\n\n    # Base case\n    if end_ind - start_ind <= 1:\n        sys.stdout.flush()\n        start_dist = abs(query - library[start_ind])\n        end_dist = abs(library[end_ind] - query)\n        ret_ind = start_ind if start_dist <= end_dist else end_ind\n        if disp:\n            sys.stdout.write(str(its) + \")\" + \" Found closest to:[\" + library[ret_ind] + \"]\\n\")\n        return ret_ind, its\n    # Recursive case\n    else:\n        mid_ind = (start_ind + end_ind) / 2\n        # Determine whether or not to print this line\n        # (almost never want to except when debugging)\n        if disp:\n            print str(its) + \")\", library[start_ind], \"--\", library[mid_ind], \"--\", library[end_ind]\n\n        # Check to see how to recurse\n        if query < library[mid_ind]:\n            return bin_search_gtf(query, library, start_ind, mid_ind, its + 1, disp=disp)\n        else:\n            return bin_search_gtf(query, library, mid_ind, end_ind, its + 1, disp=disp)\n\n            #####################################\n\n\n# Brute Force Closest GTF        #\n#####################################\ndef brute_search_gtf(query, library):\n    \"\"\"\n    Goal: do brute search through the library for the closest ind\n    Arguments:\n        query is an int\n        library is a list[int] of genomic positions to look through\n\n    Returns:\n        the index of the closest matching library value to the query\n    \"\"\"\n\n    closest_ind = 0\n    closest_dist = abs(library[0] - query)\n    for ind, val in enumerate(library[1:]):\n        if abs(val - query) < closest_dist:\n            closest_ind = ind + 1  # <-- have to add 1 since skipping first ind\n            closest_dist = abs(val - query)\n\n    return closest_ind\n\n\n#####################################\n#         Identify Fusions          #\n#####################################\n# Takes junctions that already have gtf info\n# If a junction has the following properties call it a 'fusion':\n#   IF donor and acceptor sams are at_boundary:\n#       IF donor and acceptor are on different chromosomes\n#           [yes fusion]\n#       ELIF donor and acceptor are on different strands\n#       ELIF distance between donor and acceptor > threshold\n#           [yes fusion]\n#       ELSE\n#           [no fusion]\n#   ELSE:\n#       [no fusion]\n#\n# Returns a list of junctions that are deemed 'fusions'\ndef identify_fusions(junctions):\n    \"\"\"\n    Goal: take the junctions and find the ones that could be fusions\n    Arguments:\n        junctions is a list[Junction] objects\n        span_cutoff is an optional int or float defining min distance for a fusion\n            on the same chromosome\n    Returns:\n        fusion_jcts as a list[Junction] with the junctions defined as fusions\n    \"\"\"\n    #span_cutoff = constants_dict[\"span_cutoff\"]\n    fusion_jcts = []\n    for jct in junctions:\n        fusion_type = jct.get_fusion_type()\n        if \"fusion\" in fusion_type and \"no_fusion\" not in fusion_type:\n            fusion_jcts.append(jct)\n    return fusion_jcts\n\n\n####################\n#   Assign Class   #\n####################\n# Assigns a pair of R1 and R2 to a class based on certain factors. These are both SAMEntry objects.\n# Possible classes. R1 always maps to a denovo jct, and R2 somewhere else.\n# NOTE I currently have no confidence that this function works\n# TODO update the logic to allow 'Fusion' classification\n# TODO use regex to parse the chromosome rather than all this messy splitting (it looks terrible)\n# [1] Linear\n# [2] Linear Anomally\n# [3] Circular\n# [4] Circular Anomally\n# [5] None <-- kind of in the place of fusions for now\ndef assign_class(sam_R1, sam_R2):\n    \"\"\"\n    Goal: take the donor and acceptor sam and categorize them\n    Arguments:\n        sam_R1 is of type SAMEntry\n        sam_R2 is of type SAMEntry\n\n    Returns:\n        a string of the generated type\n    \"\"\"\n    jct_chrom_1 = sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[1]\n    jct_chrom_2 = sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[0]\n\n    # If the jct splices 2 chromosomes together just skip it for now\n    if jct_chrom_1 != jct_chrom_2:\n        return \"None\"\n    # If the R1 and R2 are on different chromosomes just skip it for now\n    if jct_chrom_1 != sam_R2.chromosome:\n        return \"None\"\n\n    span = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[5].split(\":\")[1])\n\n    # Linear case\n    if span > 0:\n        if sam_R1.strand != sam_R2.strand:\n            return \"Linear\"\n        else:\n            return \"Linear_Anomaly\"\n\n    # Circular case\n    else:\n        start_1 = int(sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[3].split(\":\")[1])\n        stop_1 = int(sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[4].split(\":\")[1])\n        start_2 = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[2].split(\":\")[1])\n        stop_2 = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[3].split(\":\")[1])\n        if sam_R1.strand == sam_R2.strand:\n            return \"Circular_Anomaly\"\n        elif start_2 <= sam_R2.start <= stop_1:\n            return \"Circular\"\n        else:\n            return \"Circular_Anomaly\"\n\n\n############################\n#   Write GLM Class File   #\n############################\n# Simple function to print out GLM class file in the right format\n# NOTE I don't think this function currently works\ndef write_glm_class_file(class_file_name, sam_list):\n    \"\"\"\n    Goal: print out a class file for the GLM\n    Arguments:\n        class_file_name is the name of the save file for the GLM\n        sam_list is a list[[SAMEntry,SAMEntry,str,list[string],list[string]],...]\n\n    Returns:\n        nothing (just prints to the file instead)\n    \"\"\"\n    header = \"\"\n    header += \"id\\t\"\n    header += \"class\\t\"\n    header += \"pos\\t\"\n    header += \"qual\\t\"\n    header += \"aScore\\t\"\n    header += \"numN\\t\"\n    header += \"readLen\\t\"\n    header += \"junction\\t\"\n    header += \"strand\\t\"\n    header += \"posR2\\t\"\n    header += \"qualR2\\t\"\n    header += \"aScoreR2\\t\"\n    header += \"numNR2\\t\"\n    header += \"readLenR2\\t\"\n    header += \"junctionR2\\t\"\n    header += \"strandR2\\n\"\n    with open(class_file_name, \"w\") as class_file:\n        class_file.write(header)\n        for read_pair in sam_list:\n            sam_R1, sam_R2, pair_class, sam_R1_genes, sam_R2_genes = read_pair\n\n            # Add general info to the out_line\n            out_line = \"\"\n            out_line += str(sam_R1.read_id.split(\"/\")[0]) + \"\\t\"\n            out_line += str(pair_class) + \"\\t\"\n\n            # Add R1 info to the out_line\n            out_line += str(sam_R1.start) + \"\\t\"\n            out_line += str(sam_R1.mapping_quality) + \"\\t\"\n            out_line += str(sam_R1.alignment_score) + \"\\t\"\n            out_line += str(sam_R1.num_Ns) + \"\\t\"\n            out_line += str(len(sam_R1.seq)) + \"\\t\"\n            out_line += str(sam_R1.junction()) + \"|\" + sam_R1_genes + \"\\t\"\n            out_line += str(sam_R1.strand) + \"\\t\"\n\n            # Add R2 info to the out_line\n            out_line += str(sam_R2.start) + \"\\t\"\n            out_line += str(sam_R2.mapping_quality) + \"\\t\"\n            out_line += str(sam_R2.alignment_score) + \"\\t\"\n            out_line += str(sam_R2.num_Ns) + \"\\t\"\n            out_line += str(len(sam_R2.seq)) + \"\\t\"\n            out_line += str(sam_R2.junction()) + \"|\" + sam_R2_genes + \"\\t\"\n            out_line += str(sam_R2.strand) + \"\\n\"\n\n            # Write the built up out_line to the glm input class file\n            class_file.write(out_line)\n\n\n##################\n#   Write Time   #\n##################\n# Helper function to write out the timing of something\n# Takes in the message, a start time in seconds, and a timer_file_path\n# Appends to the timer file by default, first call should overwrite\ndef write_time(message, start_time, timer_file_path, append=True, uniform_len=70):\n    \"\"\"\n    Goal: write a timed event out to a file\n    Arguments:\n        message is the text of the job to put next to the time (i.e. 'Time to align reads')\n        start_time is the start of the job gotten by time.time()\n        time_file_path is the full path to the timer store file\n        append is a boolean saying whether or not to append to the file vs. overwriting (default append)\n        uniform_len is the max message length to allow aligning the timer output file\n\n    Returns:\n        nothing (just writes to the timer file)\n    \"\"\"\n    seconds_duration = float(time.time() - start_time)\n    minutes_duration = seconds_duration / 60\n    hours_duration = seconds_duration / 3600\n    seconds_str = (\"{:3.2f}\".format(seconds_duration)).rjust(5, \" \")\n    minutes_str = (\"{:3.2f}\".format(minutes_duration)).rjust(5, \" \")\n    hours_str = (\"{:3.2f}\".format(hours_duration)).rjust(5, \" \")\n\n    if len(message) < uniform_len:\n        message += \" \" * (uniform_len - len(message))\n    else:\n        message = message[:uniform_len]\n    time_out_str = message + \":    \"\n    time_out_str += seconds_str + \":seconds    \"\n    time_out_str += minutes_str + \":minutes    \"\n    time_out_str += hours_str + \":hours\\n\"\n    timer_file = open(timer_file_path, \"a\") if append else open(timer_file_path, \"w\")\n    timer_file.write(time_out_str)\n    timer_file.close()\n\n\n##########################\n#   Collapse Junctions   #\n##########################\ndef collapse_junctions(jcts, collapse_thresh, group_out_file_name=None):\n    \"\"\"\n    Goal: take in the junctions and collapse ones at or near the same\n          splice sites\n    Arguments:\n        junctions is a list[Junction] object\n        full_path_name points to the the combined fastq file\n        constants dict is a dictionary of global constants\n\n    Returns:\n        a tuple with the first element as the singles \"uncollapsed list\"\n        and the second being the collapsed list of junctions list[Junction]\n    \"\"\"\n    # Get the collapsing threshold (radius of donor and acceptor to collapse in)\n    #collapse_thresh = constants_dict[\"collapse_thresh\"]\n\n    # Separate the jcts by chromosome pairs to make later O(N^2) less painful\n    # so will have one entry for chr1:chr2, chr1:chr3 etc\n    # it will be combinations, not permutations (chr1:chr2 == chr2:chr1)\n    splices_by_chroms = {}\n    for jct in jcts:\n        chrom_1 = \"chr\" + str(jct.donor_sam.chromosome)\n        chrom_2 = \"chr\" + str(jct.acceptor_sam.chromosome)\n        if chrom_1 + chrom_2 in splices_by_chroms:\n            splices_by_chroms[chrom_1 + chrom_2].append(jct)\n        #elif chrom_2 + chrom_1 in splices_by_chroms:\n        #    splices_by_chroms[chrom_2 + chrom_1].append(jct)\n        else:\n            splices_by_chroms[chrom_1 + chrom_2] = [jct]\n\n    groupings = {}\n    for chroms in splices_by_chroms:\n        groupings[chroms] = []\n        for jct in splices_by_chroms[chroms]:\n            don = jct.donor_sam.donor()\n            acc = jct.acceptor_sam.acceptor()\n            found_prev_group = False\n\n            # Only compare jct to other jcts if both\n            # don and acc are not None\n            if don and acc:\n                for prev_group in groupings[chroms]:\n                    for prev_jct in prev_group:\n                        prev_don = prev_jct.donor_sam.donor()\n                        prev_acc = prev_jct.acceptor_sam.acceptor()\n                        # If any one of the acceptor/donors are None\n                        if not prev_don or not prev_acc:\n                            continue\n                        if abs(don - prev_don) <= collapse_thresh and abs(acc - prev_acc) <= collapse_thresh:\n                            # sys.stderr.write(\"Found match for:\\n\")\n                            # sys.stderr.write(jct.verbose_fasta_string())\n                            prev_group.append(jct)\n                            found_prev_group = True\n                            break\n\n                    # If found a prev_group, don't need to look through\n                    # other prev groups\n                    if found_prev_group:\n                        break\n\n            # If it didn't find any of the prev_groups, start a new group\n            if not found_prev_group:\n                groupings[chroms].append([jct])\n\n    # Separate singles from groups\n    singles = []\n    groups = []\n    group_out_file = None\n    if group_out_file_name:\n        group_out_file = open(group_out_file_name, \"w\")\n\n    for chroms in groupings:\n        for group in groupings[chroms]:\n            if len(group) <= 1:\n                singles += group\n            else:\n                if group_out_file_name:\n                    group_out_file.write(\"Group info:\\n\")\n                    group_out_file.write(\"\".join([m.verbose_fasta_string() for m in group]) + \"\\n\")\n                counts = [len(member.bin_pair_group) for member in group]\n                max_ind = counts.index(max(counts))\n                repr_jct = group[max_ind]\n                repr_jct.collapsed_num = sum(counts)\n                groups.append(repr_jct)\n\n    if group_out_file_name:\n        group_out_file.close()\n\n\n    return singles, groups\n\n\n########################\n#   Badfj3 fusions     #\n########################\ndef badfj3_fusions(junctions, constants_dict):\n    # Bowtie params\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n\n    # Build up file stems\n    badfj3_stem = os.path.join(constants_dict[\"output_dir\"], \"badfj3_\")\n    don_fasta = badfj3_stem + \"don.fasta\"\n    acc_fasta = badfj3_stem + \"acc.fasta\"\n    badfj3_mapped = badfj3_stem + \"mapped.sam\"\n\n    # Open the R1 and R2\n    don_fasta_f = open(don_fasta, \"w\")\n    acc_fasta_f = open(acc_fasta, \"w\")\n\n    # Build up the \"paired end\" files\n    jct_dict = {}\n    for jct in junctions:\n        jct_dict[jct.jct_ind] = jct\n        header = \">\" + str(jct.jct_ind)\n        break_point = jct.splice_ind()\n        don = jct.consensus[:break_point]\n        acc = jct.consensus[break_point:]\n\n        # RB: 5/26/17 Change this to map just the first and last 20 bases\n        # don_fasta_f.write(header+\"\\n\"+don+\"\\n\")\n        # acc_fasta_f.write(header+\"\\n\"+acc+\"\\n\")\n        don_fasta_f.write(header + \"\\n\" + don[:20] + \"\\n\")\n        acc_fasta_f.write(header + \"\\n\" + acc[-20:] + \"\\n\")\n\n    # Close the R1 and R2 fastqs\n    don_fasta_f.close()\n    acc_fasta_f.close()\n\n    badfj3_gap = \"500000\"  # If the don/acc can map within 1/2 Mb, then jct not fusion\n\n    # Run bowtie2 on the R1 and R2\n    with open(badfj3_mapped, \"w\") as badfj3_mapped_f:\n        subprocess.call([\n            \"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", \"--no-mixed\", \"--no-hd\",\n            min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n            \"-x\", reference, \"-X\", badfj3_gap, \"--ff\", \"-1\",\n            don_fasta, \"-2\", acc_fasta\n        ],\n            stdout=badfj3_mapped_f)\n\n    # Read back the sam file\n    flags = [\"paired\", \"proper\", \"no_align\", \"paired_no_align\", \"minus\", \"mate_minus\", \"R1\", \"R2\"]\n    seen_jct_inds = []\n    with open(badfj3_mapped, \"r\") as badfj3_mapped_f:\n        for line in badfj3_mapped_f:\n            # NOTE this is a sloppy way of parsing a PE SAM file (should use samtools view)\n            split_line = line.split('\\t')\n            jct_ind = int(split_line[0])\n            flag = int(split_line[1])\n\n            # Does sloppy binary flag parsing\n            jct_flags = {flags[ind]: bool(int(bit)) for ind, bit in enumerate(format(flag, \"08b\"))}\n\n            # If it didn't align, then just skip it, it can't be a badfj3\n            if jct_flags[\"no_align\"] or jct_flags[\"paired_no_align\"]:\n                continue\n            # If it did align AND it has already been seen this is a badfj3\n            elif jct_ind in seen_jct_inds:\n                jct_dict[jct_ind].badfj3 = True\n            # If it did align but has not already been seen put it in the see_jct_inds\n            else:\n                seen_jct_inds.append(jct_ind)\n\n    return junctions\n\n\n############################\n#   Old Badfj3 fusions     #\n############################\n\"\"\"\ndef badfj3_fusions(fusion_junctions,constants_dict):\n\n    #Bowtie params\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n\n    #Build up file stems\n    badfj3_stem = os.path.join(constants_dict[\"output_dir\"],\"badfj3_\")\n    don_fasta = badfj3_stem+\"don.fasta\"\n    acc_fasta = badfj3_stem+\"acc.fasta\"\n    badfj3_mapped = badfj3_stem+\"mapped.sam\"\n\n    #Open the R1 and R2\n    don_fasta_f = open(don_fasta,\"w\")\n    acc_fasta_f = open(acc_fasta,\"w\")\n\n    #Build up the \"paired end\" files\n    for fusion in fusion_junctions:\n        header = \">\"+str(fusion.jct_ind)+\"\\n\"\n        break_point = fusion.splice_ind()\n        don = fusion.consensus[:break_point]\n        acc = fusion.consensus[break_point:]\n        don_fasta_f.write(header+don+\"\\n\")\n        acc_fasta_f.write(header+acc+\"\\n\")\n\n    #Close the R1 and R2\n    don_fasta_f.close()\n    acc_fasta_f.close()\n\n    badfj3_gap = \"500000\" #If the don/acc can map within 1/2 Mb, then jct not fusion\n\n    #Run bowtie2 on the R1 and R2\n    with open(badfj3_mapped,\"w\") as badfj3_mapped_f:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n             \"-x\", reference, \"-X\", badfj3_gap, \"--ff\", \"-1\", don_fasta, \"-2\", acc_fasta], stdout=badfj3_mapped_f)\n\n\n    still_fusions = []\n    now_jcts = []\n\n    #Read back the sam file\n    with open(badfj3_mapped,\"r\") as badfj3_mapped_f:\n        for line in badfj3_mapped_f:\n            print line #NOTE!!! need to see how PE output looks\n\n    return still_fusions,now_jcts\n\"\"\"\n\n\n##########################\n#   Reverse Compliment   #\n##########################\n# Just a little helper function to give the reverse compliment of a sequence\ndef reverse_compliment(seq):\n    \"\"\"\n    Goal: take a sequence and return the reverse compliment\n    Arguments:\n        seq is a string of A's,T's,C's,G's, and N's\n\n    Returns:\n        the reverse compliment string\n    \"\"\"\n    comp_dict = {\"A\": \"T\",\n                 \"a\": \"t\",\n                 \"T\": \"A\",\n                 \"t\": \"a\",\n                 \"C\": \"G\",\n                 \"c\": \"g\",\n                 \"G\": \"C\",\n                 \"g\": \"c\",\n                 \"N\": \"N\",\n                 \"n\": \"n\"}\n\n    rev_comp_seq = \"\".join([comp_dict[base] for base in seq])[::-1]\n    return rev_comp_seq\n\n\n################################################################\n#   Print out the constants dict for better version tracking   #\n################################################################\ndef write_constants_dict(constants_dict, params_out_name):\n    \"\"\"\n    Goal: print out the constants dict to inform what parameters were used on the run\n    Arguments:\n        constants_dict is a dict keyed by string and valued by numeric or string\n        params_out_name is the file path to store the constants dict info\n    Returns:\n        None, everything is written to the file\n    \"\"\"\n    uniform_len = max([len(str(key)) for key in constants_dict])\n    spaces = \" \" * uniform_len\n\n    with open(params_out_name, \"w\") as params_out:\n        # Header info with date and time\n        params_out.write(\"Parameter file used for SPORK run\\n\")\n        params_out.write(\"\\tDate \" + time.strftime(\"%d/%m/%y\") + \" (day/month/year)\\n\")\n        params_out.write(\"\\tTime \" + time.strftime(\"%H:%M:%S\") + \"\\n\")\n        params_out.write(\"\\nParameters:\\n\")\n        params_out.write(\"-\" * (uniform_len + 4) + \"\\n\")\n\n        # Loop through the parameters printing nicely\n        len_sorted_params = sorted(constants_dict.keys(), key=lambda k: len(k))\n        for param in len_sorted_params:\n            padded_param = param[:uniform_len] + spaces[:uniform_len - len(param)]\n            param_val = str(constants_dict[param])\n            params_out.write(padded_param + \"    :    \" + param_val + \"\\n\")\n\n\n###################################\n#   Track NUP214 as a test case   #\n###################################\ndef follow_nup214(forward_jct, reverse_jct):\n    \"\"\"\n    Goal: check if forward or reverse nup214 makes more sense in terms\n          of donor and acceptor sites\n    Arguments:\n        forward_jct is of type Junction\n        reverse_jct is of type Junction and is the rev-comp of forward_jct\n\n    Returns:\n        nothing, just writes out info to stdout\n    \"\"\"\n    if (forward_jct.donor_sam.str_gene() == \"NUP214\" or\n                forward_jct.acceptor_sam.str_gene() == \"NUP214\" or\n                reverse_jct.donor_sam.str_gene() == \"NUP214\" or\n                reverse_jct.acceptor_sam.str_gene() == \"NUP214\"):\n        sys.stdout.write(\"Found a NUP214\\n\")\n        sys.stdout.write(forward_jct.verbose_fasta_string())\n        sys.stdout.write(str(forward_jct.donor_sam.gtf) + \"\\n\")\n        sys.stdout.write(str(forward_jct.acceptor_sam.gtf) + \"\\n\")\n        sys.stdout.write(reverse_jct.verbose_fasta_string())\n        sys.stdout.write(str(reverse_jct.donor_sam.gtf) + \"\\n\")\n        sys.stdout.write(str(reverse_jct.acceptor_sam.gtf) + \"\\n\")\n        sys.stdout.write(\"Forward dist: \" + str(forward_dist) + \" reverse_dist: \" + str(reverse_dist) + \"\\n\")\n        sys.stdout.write(\"Forward donor gtf span:\" + str(forward_jct.donor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Forward acceptor gtf span:\" + str(forward_jct.acceptor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Reverse donor gtf span:\" + str(reverse_jct.donor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Reverse acceptor gtf span:\" + str(reverse_jct.acceptor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"\\n\")\n        sys.stdout.flush()\n\n\n###################################\n#   Track NUP214 as a test case   #\n###################################\ndef get_seq_complexity(seq):\n    \"\"\"\n    Goal: take in a string and return the sequence complexity. Makes use of zlib to compress\n          the string and see how much compression occurred. If lots of compression, then seq was low complexity\n\n    Arguments:\n        seq is a sequence (or really any string)\n\n    Return:\n        a float for the string complexity between 0 and 1 (0 is least complex, 1 is most)\n    \"\"\"\n    uncompressed = sys.getsizeof(seq)\n    compressed = sys.getsizeof(zlib.compress(seq))\n    compression = float(compressed) / uncompressed  # 0 is worst, 1 is best (visually making 0.675 cutoff)\n    return compression",
                "filename": "SPORK_utils.py"
              },
              {
                "fileContent": "#Class to store GTF entries\n#TODO give this better documentation\n\n#Imports\nimport re\nimport sys\n\nclass GTFEntry(object):\n    __slots__ = [\"chromosome\",\"source\",\"feature\", \"start\",\"stop\",\"score\",\"strand\", \"frame\",\"gene_name\", \"donor\",\"acceptor\",\"span\", \"synonyms\"]\n\n    def __init__(self,gtf_line='chr\\tsrc\\tfeat\\t-1\\t-1\\t-1\\t+\\t0\\tgene_name \"default\";'):\n        \"\"\"\n        Goal: initialize a GTFEntry\n        Arguments:\n            a gtf_line from a standard gtf file, optional, if none given default made\n\n        Returns:\n            nothing\n        \"\"\"\n        split_gtf_line = gtf_line.split(\"\\t\")\n        self.chromosome = split_gtf_line[0]\n        self.source = split_gtf_line[1]\n        self.feature = split_gtf_line[2]\n        self.start = int(split_gtf_line[3])\n        self.stop = int(split_gtf_line[4])\n        self.score = split_gtf_line[5]\n        self.strand = split_gtf_line[6]\n        self.frame = split_gtf_line[7]\n        self.donor = self.stop if self.strand == \"+\" else self.start\n        self.acceptor = self.start if self.strand == \"+\" else self.stop\n        self.span = abs(self.donor-self.acceptor)\n        group_info = split_gtf_line[8]\n        gene_name_pattern = re.compile('gene_name \"(.*?)\";')\n        gene_name = gene_name_pattern.findall(group_info)\n        if len(gene_name) == 0:\n            gene_id_pattern = re.compile('gene_id \"(.*?)\";')\n            gene_name = gene_id_pattern.findall(group_info)\n            if len(gene_name) == 0:\n                sys.stdout.write(\"SPORK ERROR: in gtf init. No found gene_name or gene_id\")\n                sys.stderr.write(\"SPORK ERROR: in gtf init. No found gene_name or gene_id\")\n                sys.exit(1)\n        self.gene_name = gene_name[0]\n        self.synonyms = set()\n    def __str__(self):\n        \"\"\"\n        Goal: yield a string representation of this GTFEntry\n        Arguments:\n            none\n\n        Returns:\n            a string of important info about this GTFEntry\n        \"\"\"\n        ret_str = \"\"\n        ret_str += \"chromosome: \"+self.chromosome+\"\\t\"\n        ret_str += \"name: \"+self.gene_name+\"\\t\"\n        ret_str += \"donor: \"+str(self.donor)+\"\\t\"\n        ret_str += \"accep: \"+str(self.acceptor)+\"\\t\"\n        ret_str += \"strand: \"+self.strand+\"\\t\"\n        ret_str += \"start: \"+str(self.start)+\"\\t\"\n        ret_str += \"stop: \"+str(self.stop)+\"\\t\"\n        return ret_str\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allows comparison between GTFEntries\n        Arguments:\n            other is also a GTFEntry\n\n        Returns:\n            true if self's chromosome is smaller than other's,\n            or if they are shared and self's start position is smaller\n            false otherwise\n        \"\"\"\n        if self.chromosome != other.chromosome:\n            return self.chromosome < other.chromosome\n        else:\n            return self.start < other.start",
                "filename": "SPORK_GTFEntry.py"
              },
              {
                "fileContent": "# Fastq entry class\n\n# Imports\nimport sys\n\n\nclass FastQEntry(object):\n    __slots__ = [\"read_id\", \"seq\", \"plus_line\", \"quality\"]\n  \n    def __init__(self, read_id, seq, plus_line, quality):\n        \"\"\"\n        Goal: initialize the FastQEntry object with the appropriate info\n        Arguments:\n            all of the fastq lines one at a time\n            read_id, seq, plus_line, and quality\n\n        Returns:\n            nothing\n        \"\"\"\n        self.read_id = read_id\n        self.seq = seq\n        self.plus_line = plus_line\n        self.quality = quality\n        self.clean()\n\n    def get_edge_thirds(self, min_third=20):\n        \"\"\"\n        Goal: split this FastQEntry into a 5' and 3' FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            a tuple of FastQEntry objects [5',3']\n        \"\"\"\n        third_len = len(self.seq) / 3\n        if third_len < min_third:\n            # sys.stderr.write(\"Skipping read too short to split in thirds: \"+self.read_id+\"\\n\")\n            return None, None\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[2 * third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[2 * third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def get_first_last_n(self, third_len=36):\n        \"\"\"\n        Goal: very similar to the edge \n        Arguments:\n            optional length of n to take (defaulted at 36)\n\n        Returns:\n            a tuple of 5' and 3' FastQEntry objects\n        \"\"\"\n        # Check to make sure can at least get the first and last third in length\n        if len(self.seq) <= third_len * 2:\n            # sys.stderr.write(\"SPORK: Skipping read too short to split in thirds: \"+self.read_id+\" len = \"+str(len(self.seq))+\"\\n\")\n            return None, None\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[-third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[-third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def clean(self):\n        \"\"\"\n        Goal: clean up the read id, sequence, plus line, and quality\n        Arguments:\n            none\n\n        Returns:\n            nothing\n        \"\"\"\n        # self.read_id = self.read_id.replace(\" \",\"_\").replace(\"\\t\",\"_\").replace(\"\\n\",\"\")\n        self.read_id = self.read_id.replace(\"\\n\", \"\")\n        self.seq = self.seq.replace(\"U\", \"T\").replace(\"\\n\", \"\")\n        self.plus_line = self.plus_line.replace(\" \", \"_\").replace(\"\\n\", \"\")\n        self.quality = self.quality.replace(\"\\n\", \"\")\n\n    def __str__(self):\n        \"\"\"\n        Goal: return an easy to print string of a FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            An output string\n        \"\"\"\n        ret_str = \"\"\n        ret_str += self.read_id + \"\\n\"\n        ret_str += self.seq + \"\\n\"\n        ret_str += self.plus_line + \"\\n\"\n        ret_str += self.quality + \"\\n\"\n        return ret_str\n\n    def __lt__(self, other):\n        \"\"\"\n        Goal: allow comparison between two FastQEntry objects based on read_id\n        Arguments:\n            other is a FastQEntry to compare to\n\n        Returns:\n            True if the read id of this object is 'less' than that of the other\n        \"\"\"\n        return self.read_id < other.read_id",
                "filename": "SPORK_FastQEntry.py"
              },
              {
                "fileContent": "# Identified junction class\n\n# Imports\nfrom SPORK_SAMEntry import SAMEntry\nimport copy\nimport sys\nimport itertools\nfrom scipy.stats import chisquare\n\n\n# Junction class\nclass Junction(object):\n    __slots__ = [\"consensus\", \"score\", \"bin_pair\", \"bin_pair_group\", \"took_reverse_compliment\", \"constants_dict\",\n                 \"badfj3\", \"donor_sam\", \"acceptor_sam\", \"mapq\", \"jct_ind\", \"best_don_list\", \"best_acc_list\",\n                 \"rev_best_don_list\", \"rev_best_acc_list\", \"is_at_boundary\", \"uniformity_score\", \"collapsed_num\"]\n\n    def __init__(self, consensus, score, bin_pair_group, jct_ind, took_reverse_compliment, constants_dict):\n        \"\"\"\n        Goal: Initialization function of junction\n        Arguments:\n            consensus                -- str\n            score                    -- float\n            bin_pair_group           -- list[bin_pair]\n            took_reverse_coompliment -- bool\n            constants_dict           -- dict[str->multiple types]\n\n        Returns:\n            nothing\n        \"\"\"\n        # Read in arguments\n        self.consensus = consensus\n        self.score = score\n        self.bin_pair_group = bin_pair_group\n        self.jct_ind = jct_ind\n        self.took_reverse_compliment = took_reverse_compliment\n        self.constants_dict = constants_dict\n        self.mapq = 0\n        self.badfj3 = False\n\n        # Find chromosome, bin_pair and strand info from the first mapped read\n        rep_bin_pair = self.bin_pair_group[0]\n        self.bin_pair = rep_bin_pair.bin_pair\n        self.donor_sam = SAMEntry()\n        self.acceptor_sam = SAMEntry()\n\n        # Get some information for the donor sam from the five_prime sam of the bin pair\n        self.donor_sam.chromosome = rep_bin_pair.five_prime_chr\n        self.donor_sam.start = rep_bin_pair.five_prime_SAM.start\n        self.donor_sam.stop = rep_bin_pair.five_prime_SAM.stop\n\n        # Get some information for the acceptor sam from the three_prime sam of the bin pair\n        self.acceptor_sam.chromosome = rep_bin_pair.three_prime_chr\n        self.acceptor_sam.start = rep_bin_pair.three_prime_SAM.start\n        self.acceptor_sam.stop = rep_bin_pair.three_prime_SAM.stop\n\n        self.best_don_list = None\n        self.best_acc_list = None\n        self.rev_best_don_list = None\n        self.rev_best_acc_list = None\n        self.uniformity_score = [-1, 1]\n\n        bin_size = constants_dict[\"bin_size\"]\n        three_prime_loc = [0] * bin_size\n        five_prime_loc = [0] * bin_size\n\n        for bin_pair in bin_pair_group:\n            three_prime_loc[bin_pair.three_prime_SAM.start % bin_size] += 1\n            five_prime_loc[bin_pair.five_prime_SAM.start % bin_size] += 1\n\n        self.uniformity_score = [round(chisquare(three_prime_loc)[1], 5), round(chisquare(five_prime_loc)[1], 5)]\n        self.collapsed_num = 0\n        self.is_at_boundary = False\n\n    # Use the sam's to find the splice index in reference to the concensus\n    def splice_ind(self):\n        \"\"\"\n        Goal: Get the splice site in consensus coordinates [0,len(consensus)-1]\n        Arguments:\n            none\n\n        Returns:\n            the 3' edge of the donor sequence if both sams are defined\n            otherwise returns the middle index of the consensus as a guess\n        \"\"\"\n\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            # NOTE currently doesn't handle gaps well (just returns the donor side index of gap)\n            # comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n            #        \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n            #        \"N\": \"N\", \"n\": \"n\"}\n            acc_seq = self.acceptor_sam.seq\n            # if (self.acceptor_sam.strand == \"-\" and not self.took_reverse_compliment) or (self.acceptor_sam.strand == \"+\" and self.took_reverse_compliment):\n            #    acc_seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n            return self.consensus.find(acc_seq)\n\n        else:\n            return len(self.consensus) / 2\n\n    # Use the sam's again to find the size of the gap between the two pieces\n    def splice_gap(self):\n        \"\"\"\n        Goal: Find the distance between the donor and acceptor splice sites\n              in consensus coordinates [0,len(consensus)-1]\n        Arguments:\n            none\n\n        Returns:\n            the distance between the 3' end of the donor and 5' end of the acceptor\n            if one or both of the sam's are undefined return None\n        \"\"\"\n        # if self.donor_sam.exists and self.acceptor_sam.exists:\n        # RB 5/26/17: Having strange index errors, I think going by lengths is equivalent\n        #    return len(self.consensus) - len(self.donor_sam.seq) - len(self.acceptor_sam.seq)\n\n        # sys.stderr.write(self.consensus+':  '+self.donor_sam.seq+'\\n')\n        # donor_pos = self.consensus.index(self.donor_sam.seq)+len(self.donor_sam.seq)\n        # sys.stderr.write(self.consensus+':  '+self.acceptor_sam.seq+'\\n')\n        # acceptor_pos = self.consensus.index(self.acceptor_sam.seq)\n        # return donor_pos-acceptor_pos\n        # else:\n        #    return None\n        return 0\n\n    # Use the sam's again to find the size of the gap between the two pieces\n    def span(self):\n        \"\"\"\n        Goal: find the genomic span between the sams\n        Arguments:\n            none\n\n        Returns:\n            if both exist subtract the donor and acceptor sites\n            this distance will always be positive\n            if one or both don't exist just return -1\n        \"\"\"\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            span = self.donor_sam.donor() - self.acceptor_sam.acceptor()\n            return abs(span)\n        else:\n            return -1\n\n    # Give a name to the splice type for this junction\n    def splice_type(self):\n        \"\"\"\n        Goal: get the type of splice this junction represents\n        Arguments:\n            none\n\n        Returns:\n            \"Full\" if both sams exist and have zero gaps in the split\n            \"Gapped\" if both sams exist but there is space in the middle\n            \"Five_Only\" if only the donor sam exists\n            \"Three_Only\" if only the acceptor sam exists\n            \"None\" if niether sam exists\n        \"\"\"\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            if self.splice_gap() == 0:\n                return \"Full\"\n            else:\n                return \"Gapped\"\n        elif self.donor_sam.exists:\n            return \"Five_Only\"\n        elif self.acceptor_sam.exists:\n            return \"Three_Only\"\n        else:\n            return \"None\"\n\n    # Check to see if this jct represents a fusion\n    def get_fusion_type(self, span_cutoff=1e5):\n        \"\"\"\n        Goal: check if this junction represents a fusion\n        Arguments:\n            none\n\n        Returns:\n            bool of whether or not the donor and acceptor have different genes\n            if one or more don't exists then return False\n        \"\"\"\n        anonat = \"\"  # Can be 'bot', 'donor', 'acceptor', or 'none'\n        chroms = \"\"  # Can be 'interchrom', 'distant-intrachrom', or 'local-intrachrom'\n        strand = \"\"  # Can be 'inversion', 'plus', or 'minus'\n        revreg = \"\"  # Can be 'rev', 'reg', or 'invert'\n\n        # Get the anonat type\n        if self.at_boundary(\"donor\") and self.at_boundary(\"acceptor\"):\n            anonat = \"both\"\n        elif self.at_boundary(\"donor\"):\n            anonat = \"donor\"\n        elif self.at_boundary(\"acceptor\"):\n            anonat = \"acceptor\"\n        else:\n            anonat = \"niether\"\n\n        # Get the strand type\n        if self.donor_sam.strand != self.acceptor_sam.strand:\n            strand = \"inversion\"\n        elif self.donor_sam.strand == \"+\":\n            strand = \"plus\"\n        elif self.donor_sam.strand == \"-\":\n            strand = \"minus\"\n\n        # Get the chromosomes type\n        if self.donor_sam.chromosome != self.acceptor_sam.chromosome:\n            chroms = \"interchrom\"\n        elif strand == \"inversion\":\n            chroms = \"inversion-intrachrom\"\n        elif self.span() >= span_cutoff:\n            chroms = \"distant-intrachrom\"\n        else:\n            chroms = \"local-intrachrom\"\n\n        # Get the revreg type\n        if strand == \"inversion\":\n            revreg = \"invert\"\n        elif self.donor_sam.donor() < self.acceptor_sam.acceptor() and self.donor_sam.strand == \"+\":\n            revreg = \"reg\"\n        elif self.donor_sam.donor() > self.acceptor_sam.acceptor() and self.donor_sam.strand == \"-\":\n            revreg = \"reg\"\n        else:\n            revreg = \"rev\"\n\n        # Should this be considered a fusion?\n        fusion = \"no_fusion\"\n\n        if anonat == \"both\":\n            if self.splice_gap() != None and abs(self.splice_gap()) <= self.constants_dict[\"fusion_max_gap\"]:\n                #if chroms != \"local-intrachrom\":\n                #    fusion = \"fusion\"\n                fusion = \"fusion\"\n\n        # Concatenate them into one string\n        fusion_type = fusion + \"-\" + anonat + \"_\" + chroms + \"_\" + strand + \"_\" + revreg\n        return fusion_type\n\n    # Get distance to closest splice boundary\n    def boundary_dist(self, splice_site, bowtie_style=True):\n        \"\"\"\n        Goal: get the distance of the specified splice site from the closest exon\n        Arguments:\n            splice_site which is a string and can be either \"donor\" or \"acceptor\"\n            bowtie_style is an optional boolean argument\n                if True (default), then if a donor/acceptor falls to the 'right' of the gtf-site,\n                regardless of strand, it will be a positive distance\n\n                if False, then the strand does matter, and being 5' of gtf is negative and 3' is positive\n\n\n        Returns:\n            the distance to the closest gtf of the specified splice_site\n            the distance being positive or negative means different things based on the bowtie_style parameter\n            explained above\n        \"\"\"\n        # If donor distance is requested\n        if splice_site == \"donor\" and self.donor_sam.gtf:\n            donor_dist = 0\n            if not bowtie_style:\n                if self.donor_sam.strand == \"+\":\n                    donor_dist = self.donor_sam.donor() - self.donor_sam.gtf.donor\n                elif self.donor_sam.strand == \"-\":\n                    donor_dist = self.donor_sam.gtf.donor - self.donor_sam.donor()\n                else:\n                    sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect strand option \\n\")\n                    sys.exit(1)\n            elif bowtie_style:\n                donor_dist = self.donor_sam.donor() - self.donor_sam.gtf.donor\n\n            return donor_dist\n\n        # If acceptor distance is requested\n        elif splice_site == \"acceptor\" and self.acceptor_sam.gtf:\n            acceptor_dist = 0\n            if not bowtie_style:\n                if self.acceptor_sam.strand == \"+\":\n                    acceptor_dist = self.acceptor_sam.acceptor() - self.acceptor_sam.gtf.acceptor\n                elif self.acceptor_sam.strand == \"-\":\n                    acceptor_dist = self.acceptor_sam.gtf.acceptor - self.acceptor_sam.acceptor()\n                else:\n                    sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect strand option \\n\")\n                    sys.exit(1)\n            elif bowtie_style:\n                acceptor_dist = self.acceptor_sam.acceptor() - self.acceptor_sam.gtf.acceptor\n\n            return acceptor_dist\n\n        # If a different string was passed in or the specified gtf doesn't exist\n        else:\n            sys.stderr.write(str(self) + '\\n')\n            sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect str or gtf doesn't exist\\n\")\n            sys.exit(1)\n\n    # Return whether or not an donor and acceptor is at a boundary\n    def at_boundary(self, splice_site):\n        \"\"\"\n        Goal: check to see if the specified sam is at an exon boundary\n        Arguments:\n            splice_site of type string. should be \"donor\" or \"acceptor\"\n            to specify which sam to check\n\n            radius is optional and signifies the maximum distance from\n            an exon boundary to consider a sam. Default is 3\n\n        Returns:\n            a boolean of whether or not the specified sam is within\n            'radius' distance of any exon boundary\n        \"\"\"\n        dist = self.boundary_dist(splice_site)\n        if abs(dist) <= self.constants_dict[\"at_boundary_cutoff\"]:\n            return True\n        else:\n            return False\n\n    # Returns whether or not this junction is linear\n    def linear(self):\n        \"\"\"\n        Goal: check to see if this junction in linear\n        Arguments:\n            none\n\n        Returns:\n            a boolean of whether the junction is linear or not\n        \"\"\"\n        five_prime_bin, three_prime_bin, strand_info = self.bin_pair.split(\"_\")\n        five_prime_chr = five_prime_bin.split(\":\")[0]\n        five_prime_bin = five_prime_bin.split(\":\")[1]\n        three_prime_chr = three_prime_bin.split(\":\")[0]\n        three_prime_bin = three_prime_bin.split(\":\")[1]\n        linear = True if int(five_prime_bin) <= int(three_prime_bin) else False\n        # RB 04/25/17: I'm not sure this is correct, took_reverse_compliment is always False\n        linear = not linear if self.took_reverse_compliment else linear\n        return linear\n\n    # Returns this junction and a reverse compliment of this junction\n    # to facilitate finding the gtf's of each and seeing which form is better\n    def yield_forward_and_reverse(self):\n        \"\"\"\n        Goal: return a copy of self and a reverse compliment of self\n        Arguments:\n            none\n\n        Returns:\n            a tuple of Junction where the first entry is self and the\n            second is a reverse compliment of self\n        \"\"\"\n        # sys.stdout.write(\"Before copy in yield_forward_and_reverse\\n\")\n        rev_self = Junction(self.consensus, self.score, self.bin_pair_group, self.jct_ind, self.took_reverse_compliment,\n                            self.constants_dict)\n        # rev_self = copy.deepcopy(self)\n        # sys.stdout.write(\"After copy in yield_forward_and_reverse\\n\")\n        rev_self.took_reverse_compliment = not rev_self.took_reverse_compliment\n\n        comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n                \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n                \"N\": \"N\", \"n\": \"n\"}\n\n        # Take the reverse compliments of the seqs and switch them between donor and acceptor\n        rev_self.consensus = \"\".join([comp[base] for base in self.consensus])[::-1]\n        rev_self.donor_sam.seq = \"\".join([comp[base] for base in self.donor_sam.seq])[::-1]\n        rev_self.acceptor_sam.seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n        rev_self.donor_sam.seq, rev_self.acceptor_sam.seq = rev_self.acceptor_sam.seq, rev_self.donor_sam.seq\n\n        rev_self.donor_sam.strand = \"-\" if self.acceptor_sam.strand == \"+\" else \"+\"\n        rev_self.acceptor_sam.strand = \"-\" if self.donor_sam.strand == \"+\" else \"+\"\n\n        rev_self.donor_sam.start, rev_self.acceptor_sam.start = self.acceptor_sam.start, self.donor_sam.start\n        rev_self.donor_sam.stop, rev_self.acceptor_sam.stop = self.acceptor_sam.stop, self.donor_sam.stop\n\n        rev_self.donor_sam.md, rev_self.acceptor_sam.md = self.acceptor_sam.md, self.donor_sam.md\n\n        rev_self.donor_sam.chromosome, rev_self.acceptor_sam.chromosome = self.acceptor_sam.chromosome, self.donor_sam.chromosome\n        rev_self.donor_sam.exists = True\n        rev_self.acceptor_sam.exists = True\n\n        if self.best_don_list:\n            rev_self.rev_best_don_list = []\n            rev_self.rev_best_acc_list = []\n            for index in range(len(self.best_don_list)):\n                rev_don = copy.deepcopy(self.best_don_list[index])\n                rev_acc = copy.deepcopy(self.best_acc_list[index])\n\n                rev_don.seq = \"\".join([comp[base] for base in self.best_acc_list[index].seq])[::-1]\n                rev_acc.seq = \"\".join([comp[base] for base in self.best_don_list[index].seq])[::-1]\n\n                rev_don.strand = \"-\" if self.best_acc_list[index].strand == \"+\" else \"+\"\n                rev_acc.strand = \"-\" if self.best_don_list[index].strand == \"+\" else \"+\"\n\n                rev_don.md = self.best_acc_list[index].md\n                rev_acc.md = self.best_don_list[index].md\n\n                rev_don.start = self.best_acc_list[index].start\n                rev_acc.start = self.best_don_list[index].start\n\n                rev_don.stop = self.best_acc_list[index].stop\n                rev_acc.stop = self.best_don_list[index].stop\n\n                rev_don.chromosome = self.best_acc_list[index].chromosome\n                rev_acc.chromosome = self.best_don_list[index].chromosome\n\n                rev_self.rev_best_don_list.append(rev_don)\n                rev_self.rev_best_acc_list.append(rev_acc)\n\n        return self, rev_self\n\n    # Returns this junction and a reverse compliment of this junction\n    # to facilitate finding the gtf's of each and seeing which form is better\n    def yield_reverse(self):\n        \"\"\"\n        Goal: return a reversed self\n        Arguments:\n            none\n\n        Returns:\n            a Junction which is the reverse of self (note does change original)\n        \"\"\"\n        self.took_reverse_compliment = not self.took_reverse_compliment\n\n        comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n                \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n                \"N\": \"N\", \"n\": \"n\"}\n\n        # Take the reverse compliments of the seqs and switch them between donor and acceptor\n        self.consensus = \"\".join([comp[base] for base in self.consensus])[::-1]\n        self.donor_sam.seq = \"\".join([comp[base] for base in self.donor_sam.seq])[::-1]\n        self.acceptor_sam.seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n        self.donor_sam.seq, self.acceptor_sam.seq = self.acceptor_sam.seq, self.donor_sam.seq\n\n        # Flip the strands of both SAMs\n        # NOTE only switch the strands if both are + or -, don't do it otherwise\n        # Interesting that it works this way, but I drew it out and I'm confident\n        if self.donor_sam.strand == self.acceptor_sam.strand:\n            self.donor_sam.strand = \"-\" if self.donor_sam.strand == \"+\" else \"+\"\n            self.acceptor_sam.strand = \"-\" if self.acceptor_sam.strand == \"+\" else \"+\"\n\n        # Trade starts and stops of donor and acceptor and chromosome\n        self.donor_sam.start, self.acceptor_sam.start = self.acceptor_sam.start, self.donor_sam.start\n        self.donor_sam.stop, self.acceptor_sam.stop = self.acceptor_sam.stop, self.donor_sam.stop\n        self.donor_sam.chromosome, self.acceptor_sam.chromosome = self.acceptor_sam.chromosome, self.donor_sam.chromosome\n\n        return self\n\n    # Format the junction for MACHETE in fasta form\n    # NOTE only call this function on 'fusion' identified junctions\n    def fasta_MACHETE(self):\n        \"\"\"\n        Goal: produce a fasta_string for MACHETE\n        Arguments:\n            none\n        Returns:\n            a fasta formatted string (with a newline between header and sequence)\n        \"\"\"\n        # Make the necessary variables\n        chrom1 = self.donor_sam.chromosome\n        chrom2 = self.acceptor_sam.chromosome\n        genes1 = self.donor_sam.str_gene()\n        genes2 = self.acceptor_sam.str_gene()\n        pos1 = self.donor_sam.donor()\n        pos2 = self.acceptor_sam.acceptor()\n        strand1 = self.donor_sam.strand\n        strand2 = self.acceptor_sam.strand\n        fusion_type = self.get_fusion_type()\n\n        # Start building the fasta string\n        fasta_str = \"\"\n        fasta_str += \">\"\n        fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n        fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n        fasta_str += fusion_type\n        fasta_str += \",num=\" + str(len(self.bin_pair_group))\n        fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n        fasta_str += \",score=\" + str(self.score)\n        fasta_str += \",gap=\" + str(self.splice_gap())\n        fasta_str += \",break-point=\" + str(self.splice_ind())\n        fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(self.uniformity_score[1]) + \")\"\n        fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n        fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n        fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n        fasta_str += \",mapq=\" + str(self.mapq)\n        fasta_str += \",badfj3:\" + str(self.badfj3)\n        fasta_str += \",jct_ind=\" + str(self.jct_ind)\n        fasta_str += \"\\n\"\n\n        # Add the actual padded consensus to the output string\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n\n        return fasta_str\n\n    def fasta_header(self):\n        \"\"\"\n        Goal: produce a fasta_string for MACHETE\n        Arguments:\n            none\n        Returns:\n            a fasta formatted string (with a newline between header and sequence)\n        \"\"\"\n        # Make the necessary variables\n        chrom1 = self.donor_sam.chromosome\n        chrom2 = self.acceptor_sam.chromosome\n        genes1 = self.donor_sam.str_gene()\n        genes2 = self.acceptor_sam.str_gene()\n        pos1 = self.donor_sam.donor()\n        pos2 = self.acceptor_sam.acceptor()\n        strand1 = self.donor_sam.strand\n        strand2 = self.acceptor_sam.strand\n        fusion_type = self.get_fusion_type()\n\n        # Start building the fasta string\n        fasta_str = \"\"\n        fasta_str += \">\"\n        fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n        fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n        fasta_str += fusion_type\n        fasta_str += \",num=\" + str(len(self.bin_pair_group))\n        fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n        fasta_str += \",score=\" + str(self.score)\n        fasta_str += \",gap=\" + str(self.splice_gap())\n        fasta_str += \",break-point=\" + str(self.splice_ind())\n        fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n            self.uniformity_score[1]) + \")\"\n        fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n        fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n        fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n        fasta_str += \",mapq=\" + str(self.mapq)\n        fasta_str += \",badfj3:\" + str(self.badfj3)\n        fasta_str += \",jct_ind=\" + str(self.jct_ind)\n\n        return fasta_str\n\n    # Format the junction to print in fasta-esque form\n    def log_string(self):\n        \"\"\"\n        Goal: produce a fasta_string\n        Arguments:\n            optionally include a junction index.\n            if it is included, it will be printed out\n\n        Returns:\n            a description of the junction over multiple lines\n        \"\"\"\n        fasta_str = \"\"\n        fasta_str += \">|\" + str(self.donor_sam.chromosome) + \"|\"\n        fasta_str += str(self.donor_sam.str_gene()) + \" \"\n        fasta_str += str(self.donor_sam.gene_strand()) + \" strand|\"\n        fasta_str += str(self.donor_sam.start) + \"-\"\n        fasta_str += str(self.donor_sam.stop) + \"|\"\n        fasta_str += \"strand1:\" + str(self.donor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist1:\" + str(self.boundary_dist(\"donor\")) + \"|\"\n        fasta_str += \"at_boundary1:\" + str(self.at_boundary(\"donor\")) + \"|\\n\"\n\n        fasta_str += \">|\" + str(self.acceptor_sam.chromosome) + \"|\"\n        fasta_str += str(self.acceptor_sam.str_gene()) + \" \"\n        fasta_str += str(self.acceptor_sam.gene_strand()) + \" strand|\"\n        fasta_str += str(self.acceptor_sam.start) + \"-\"\n        fasta_str += str(self.acceptor_sam.stop) + \"|\"\n        fasta_str += \"strand2:\" + str(self.acceptor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist2:\" + str(self.boundary_dist(\"acceptor\")) + \"|\"\n        fasta_str += \"at_boundary2:\" + str(self.at_boundary(\"acceptor\")) + \"|\\n\"\n\n        fasta_str += \">|splice:\" + str(self.splice_ind()) + \"|\"\n        fasta_str += \"score:\" + str(self.score) + \"|\"\n        fasta_str += \"fusion:\" + str(self.get_fusion_type()) + \"|\"\n        fasta_str += \"num:\" + str(len(self.bin_pair_group)) + \"|\"\n        fasta_str += \"splice:\" + str(self.splice_type()) + \"|\"\n        fasta_str += \"mapq=\" + str(self.mapq) + \"|\"\n        fasta_str += \"badfj3:\" + str(self.badfj3) + \"|\"\n        fasta_str += \"jct_ind:\" + str(self.jct_ind) + \"|\\n\"\n\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n        fasta_str += str(self.donor_sam.seq) + \"\\n\"\n        fasta_str += \" \" * self.splice_ind() + str(self.acceptor_sam.seq) + \"\\n\"\n\n        # Also printing out gtf information\n        # fasta_str += \"Donor_gtf:\"+str(self.donor_sam.gtf)+\"\\n\"\n        # fasta_str += \"Acceptor_gtf:\"+str(self.acceptor_sam.gtf)+\"\\n\"\n        return fasta_str\n\n    # Format the junction to print in fasta form\n    def verbose_fasta_string(self):\n        \"\"\"\n        Goal: produce a fasta formatted string of this junction with lots of header info\n        Arguments:\n            none\n\n        Returns:\n            a fasta string (with a newline between the header and sequence)\n        \"\"\"\n        fasta_str = \"\"\n        fasta_str += \">|chromosome1:\" + str(self.donor_sam.chromosome) + \"|\"\n        fasta_str += \"genes1:\" + str(self.donor_sam.str_gene()) + \"|\"\n        fasta_str += \"start1:\" + str(self.donor_sam.start) + \"|\"\n        fasta_str += \"stop1:\" + str(self.donor_sam.stop) + \"|\"\n        fasta_str += \"strand1:\" + str(self.donor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist1:\" + str(self.boundary_dist(\"donor\")) + \"|\"\n        fasta_str += \"at_boundary1:\" + str(self.at_boundary(\"donor\")) + \"|_\"\n\n        fasta_str += \"|chromosome2:\" + str(self.acceptor_sam.chromosome) + \"|\"\n        fasta_str += \"genes2:\" + str(self.acceptor_sam.str_gene()) + \"|\"\n        fasta_str += \"start2:\" + str(self.acceptor_sam.start) + \"|\"\n        fasta_str += \"stop2:\" + str(self.acceptor_sam.stop) + \"|\"\n        fasta_str += \"strand2:\" + str(self.acceptor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist2:\" + str(self.boundary_dist(\"acceptor\")) + \"|\"\n        fasta_str += \"at_boundary2:\" + str(self.at_boundary(\"acceptor\")) + \"|_|\"\n\n        fasta_str += \"jct_ind:\" + str(self.jct_ind) + \"|\"\n        fasta_str += \"splice:\" + str(self.splice_ind()) + \"|\"\n        fasta_str += \"span:\" + str(self.span()) + \"|\"\n        fasta_str += \"score:\" + str(self.score) + \"|\"\n        fasta_str += \"fusion:\" + str(self.get_fusion_type()) + \"|\"\n        fasta_str += \"num:\" + str(len(self.bin_pair_group)) + \"|\"\n        fasta_str += \"splice-gap:\" + str(self.splice_gap()) + \"|\"\n        fasta_str += \"splice-type:\" + str(self.splice_type()) + \"|\"\n        fasta_str += \"badfj3:\" + str(self.badfj3) + \"|\"\n        fasta_str += \"took-rev-comp:\" + str(self.took_reverse_compliment) + \"|\\n\"\n\n        # Add N padding to the consensus to get a uniform len\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n        return fasta_str\n\n    # Add N padding to the consensus to get a uniform len\n    # With the splice site in the middle\n    def format_consensus(self, splice_flank_len):\n        \"\"\"\n        Goal: return the consensus properly formatted centered and uniform len\n        Arguments:\n            splice_flank_len is an int deciding how long either side should be\n            from the consensus\n        Returns:\n            a string of either the full consensus of None if there is no splice ind\n        \"\"\"\n        full_consensus = None\n        if self.splice_ind() != -1:\n            splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n            left_padding = \"N\" * (splice_flank_len - self.splice_ind())\n            right_padding = \"N\" * (splice_flank_len - (len(self.consensus) - self.splice_ind()))\n            if self.splice_ind() <= splice_flank_len:\n                five_consensus = self.consensus[:self.splice_ind()]\n            else:\n                five_consensus = self.consensus[self.splice_ind() - splice_flank_len:self.splice_ind()]\n            if self.splice_ind() + splice_flank_len >= len(self.consensus):\n                three_consensus = self.consensus[self.splice_ind():]\n            else:\n                three_consensus = self.consensus[self.splice_ind():self.splice_ind() + splice_flank_len]\n            full_consensus = left_padding + five_consensus + three_consensus + right_padding\n        return str(full_consensus)\n\n    # Give back the R1 readIDs used to make this junction\n    def get_read_ids(self):\n        \"\"\"\n        Goal: return a list of the read ids (strings) that made this junction\n        Arguments:\n            none\n        Returns:\n            a list[string] of the read-ids for this junction\n        \"\"\"\n        read_ids = []\n        for bin_pair in self.bin_pair_group:\n            donor_id = bin_pair.five_prime_SAM.read_id.replace(\"/5_prime\", \"\")\n            acceptor_id = bin_pair.five_prime_SAM.read_id.replace(\"/3_prime\", \"\")\n            if donor_id == acceptor_id:\n                read_ids.append(donor_id)\n            else:\n                sys.stderr.write(\"SPORK ERROR, nonmatching ids in jct: [\" + donor_id + \"] vs [\" + acceptor_id + \"]\\n\")\n                sys.exit(1)\n\n        return read_ids\n\n    def add_duplicates(self, duplicate_junctions):\n\n        if self.donor_sam.gtf.synonyms or self.acceptor_sam.gtf.synonyms:\n            chrom1 = self.donor_sam.chromosome\n            chrom2 = self.acceptor_sam.chromosome\n            genes1 = self.donor_sam.str_gene()\n            genes2 = self.acceptor_sam.str_gene()\n            pos1 = self.donor_sam.donor()\n            pos2 = self.acceptor_sam.acceptor()\n            strand1 = self.donor_sam.strand\n            strand2 = self.acceptor_sam.strand\n            fusion_type = self.get_fusion_type()\n\n            # Start building the fasta string\n            fasta_str_org = \"\"\n            fasta_str_org += \">\"\n            fasta_str_org += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n            fasta_str_org += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n            fasta_str_org += fusion_type\n            fasta_str_org += \",num=\" + str(len(self.bin_pair_group))\n            fasta_str_org += \",collapsed_num=\" + str(self.collapsed_num)\n            fasta_str_org += \",score=\" + str(self.score)\n            fasta_str_org += \",gap=\" + str(self.splice_gap())\n            fasta_str_org += \",break-point=\" + str(self.splice_ind())\n            fasta_str_org += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                self.uniformity_score[1]) + \")\"\n            fasta_str_org += \",at_boundary=\" + str(self.is_at_boundary)\n            fasta_str_org += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n            fasta_str_org += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n            fasta_str_org += \",mapq=\" + str(self.mapq)\n            fasta_str_org += \",badfj3:\" + str(self.badfj3)\n            fasta_str_org += \",jct_ind=\" + str(self.jct_ind)\n            fasta_str_org += \"\\n\"\n            if self.donor_sam.gtf.synonyms and self.acceptor_sam.gtf.synonyms:\n                for genes1, genes2 in itertools.product(self.donor_sam.gtf.synonyms, self.acceptor_sam.gtf.synonyms):\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    # genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if self.donor_sam.gtf.synonyms and not self.acceptor_sam.gtf.synonyms:\n                for genes1 in self.donor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if self.donor_sam.gtf.synonyms and not self.acceptor_sam.gtf.synonyms:\n                for genes1 in self.donor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if not self.donor_sam.gtf.synonyms and self.acceptor_sam.gtf.synonyms:\n                for genes2 in self.acceptor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    genes1 = self.donor_sam.str_gene()\n                    # genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n    # More human readable format\n    def __str__(self):\n        \"\"\"\n        Goal: output the junction in an expanded human readable form\n        Arguments:\n            none\n\n        Returns:\n            the string to be printed out\n        \"\"\"\n        out_str = \"\"\n        out_str += \"Junction with bin pair [\" + self.bin_pair + \"] with [\" + str(\n            len(self.bin_pair_group)) + \"] reads mapped\\n\"\n        out_str += \"Linear \" if self.linear() else \"Non-Linear \"\n        out_str += \"Donor on the \" + str(self.donor_sam.strand) + \" strand and acceptor on the \" + str(\n            self.acceptor_sam.strand) + \"\\n\"\n        out_str += \"5' map position [\" + str(self.donor_sam.start) + \"-\" + str(self.donor_sam.stop) + \"]\\n\"\n        out_str += \"3' map position [\" + str(self.acceptor_sam.start) + \"-\" + str(self.acceptor_sam.stop) + \"]\\n\"\n        out_str += \"badfj3:\" + str(self.badfj3) + \"\\n\"\n        out_str += \"Consensus with score [\" + str(self.score) + \"] and donor splice site [\" + str(\n            self.donor_sam.stop) + \"]:\\n\"\n        out_str += str(self.consensus) + \"\\n\"\n        out_str += str(self.donor_sam.seq) + \"\\n\"\n        out_str += \" \" * len(str(self.donor_sam.seq)) + str(self.acceptor_sam.seq) + \"\\n\"\n        out_str += \"Donor genes [\" + str(self.donor_sam.str_gene()) + \"]\\n\"\n        out_str += \"Acceptor genes [\" + str(self.acceptor_sam.str_gene()) + \"]\\n\"\n        return out_str\n\n    # Rank junctions in order of bin_pairs when sorted\n    def __lt__(self, other):\n        \"\"\"\n        Goal: give a comparison operator for the Junction class\n        Arguments:\n            other junction to compare to\n\n        Returns:\n            a boolean of whether or not this bin_pair\n            is smaller than the other bin_pair\n        \"\"\"\n        return self.bin_pair < other.bin_pair",
                "filename": "SPORK_Junction.py"
              },
              {
                "fileContent": "#Imports\nimport sys\n\n#build and score consensus function\n#(1) pads the left and right side of each sequence depending on where it mapped in the bin\n#(2) finds a consensus using a majority vote\n#(3) calculates a consensus score as the (number of mismatches)/(total_possible_mismatches)\ndef build_and_score_consensus(mapped_reads, strand, id_to_seq, bin_size, constants_dict, read_num_to_read_id):\n    #Add padding to the left sides of the reads based on where they fell in the bin pair\n    #Note that for the plus strand, more padding should be added the larger ther pos%bin_size value\n    #while this should have less padding on a minus strand read. This is implemented w/ the ternary expression\n    #read_num_to_read_id = constants_dict[\"read_num_to_read_id\"]\n    padded_seqs = []\n    left_padded_seqs = []\n    for mapped_read in mapped_reads:\n        id_key = mapped_read.read_id\n        id_key = id_key.replace(\"/5_prime\",\"\")\n        id_key = id_key.replace(\"/3_prime\",\"\")\n        id_key = read_num_to_read_id[id_key]\n        #id_key = id_key.replace(\"_\",\" \")\n        if id_key in id_to_seq:\n            full_seq = id_to_seq[id_key]\n        else:\n            sys.stderr.write(\"SPORK ERROR: Couldn't find sequence \"+id_key+\" in consensus building\\n\")\n            sys.exit(1)\n        mapped_read.read_id = id_key\n        left_padding = int(mapped_read.start%bin_size) if strand == \"+\" else int(bin_size-mapped_read.start%bin_size)\n        left_padded_seq = \" \"*left_padding+full_seq\n\n        #Don't allow exact sequence duplicates\n        if left_padded_seq not in left_padded_seqs:\n            left_padded_seqs.append(left_padded_seq)\n\n    #Add padding on the right sides so that every sequence is the same length\n    #Handled the same for plus and minus strand\n    max_len_seq = max([len(seq) for seq in left_padded_seqs])\n    for left_padded_seq in left_padded_seqs:\n        left_padded_len = len(left_padded_seq)\n        padding_to_add = max_len_seq-left_padded_len\n        padded_seq = left_padded_seq+\" \"*padding_to_add\n        padded_seqs.append(padded_seq)\n\n    #Go through each position and get the majority vote as the consensus base\n    #The dictionaries are just to help convert letters into indices and back\n    min_bases_per_col = constants_dict[\"min_bases_per_col\"]\n    consensus = \"\"\n    empty_spaces = 0\n    num_possible_discrepancies = 0\n    num_discrepancies = 0\n    base_dict = {\"A\":0,\"C\":1,\"G\":2,\"T\":3}\n    rev_base_dict = {0:\"A\",1:\"C\",2:\"G\",3:\"T\"}\n    for seq_ind in range(max_len_seq):\n        counts = [0,0,0,0]\n        for seq in padded_seqs:\n            base = seq[seq_ind].upper()\n            if base in base_dict:\n                counts[base_dict[base]] += 1\n        total_bases = sum(counts)\n        if total_bases >= min_bases_per_col:\n            num_possible_discrepancies += total_bases\n            max_count = max(counts)\n            num_discrepancies += total_bases-max_count\n            max_index = counts.index(max_count)\n            consensus += rev_base_dict[max_index]\n        else: empty_spaces += 1\n\n    #Give a terrible score if there are 0 possible discrepancies\n    #This arises most often when a junction only has one unique sequence\n    if int(num_possible_discrepancies) <= 0:\n        consensus_score = 999999\n        #sys.stderr.write(\"Null consensus:\\n\"+\"\\n\".join(padded_seqs)+\"\\n\")\n    else:\n        consensus_score = float(num_discrepancies)/int(num_possible_discrepancies)\n\n    #Print out the consensus's in a nice way\n    print_consensus = False\n    if print_consensus:\n        print \"Strand: \"+strand\n        print \"Discrepancies: \"+str(num_discrepancies)\n        print \"=\"*(len(seq)+2)\n        for seq in padded_seqs:\n            print \"|\"+seq+\"|\"\n        print \"=\"*(len(seq)+2)\n        print \"|\"+\" \"*(len(seq)-len(consensus)-min_bases_per_col)+consensus+\" \"*min_bases_per_col+\"|\"\n        left_score_str = \"|Score: \"+str(consensus_score)+\" \"\n        right_score_str = \" \"*(len(seq)+2-len(left_score_str)-1)+\"|\"\n        print left_score_str+right_score_str\n        print \"=\"*(len(seq)+2)\n        print \"\"\n\n    return consensus,consensus_score",
                "filename": "SPORK_consensus_utils.py"
              },
              {
                "fileContent": "#Import sys to write to sys.stderr sometimes\nimport sys\n\n#Mapped Read class\nclass SAMEntry(object):\n    __slots__ = [\"read_id\",\"strand\",\"chromosome\",\"start\",\"stop\",\"seq\",\"seq_quality\",\"exists\", \"num_gaps\", \"md\", \"num_mismatches\",\"num_Ns\",\"mapping_quality\",\"alignment_score\",\"gtf\"]\n\n    def __init__(self,full_line = None):\n        \"\"\"\n        Goal: initialize a SAMEntry object\n        Arguments:\n            can take in a full sam line (which it then parses),\n            or nothing, in which case a \"null\" SAMEntry is created\n            with None for every member\n\n        Returns:\n            nothing\n        \"\"\"\n        #Create an empty None-Type ish SAMEntry\n        if not full_line:\n            self.exists          = False\n            self.read_id         = None\n            self.strand          = None\n            self.chromosome      = None\n            self.start           = None\n            self.mapping_quality = None\n            self.seq             = None\n            self.seq_quality     = None\n            self.alignment_score = None\n            self.num_Ns          = None\n            self.num_mismatches  = None\n            self.num_gaps        = None\n            self.md              = None\n            self.stop            = None\n            self.gtf             = None\n\n        #Otherwise actually parse the line\n        else:\n            split_line = full_line.split(\"\\t\")\n            #Example bowtie2 SAM line w/ annotation:\n            #[0:read_id               ] K00180:68:H5CF7BBXX:3:1122:4422:11442/5_prime\n            #[1 :strand (0/16)        ] 0\n            #[2 :chromosome           ] chr21\n            #[3 :position             ] 9827122\n            #[4 :map quality          ] 42\n            #[5 :CIGAR string         ] 33M\n            #[6 :name of mate         ] *\n            #[7 :pos of mate          ] 0\n            #[8 :template len         ] 0\n            #[9 :sequence             ] CTTTGGTCGCTCGCTCCTCTCCTACTTGGATAA\n            #[10:quality string       ] <AAAFJJJFJJJJJFJFJJFJJJJJAJJFAFFJ\n            #[11:Alignment score      ] AS:i:0\n            #[12:number of N's        ] XN:i:0\n            #[13:number of mismatches ] XM:i:0\n            #[14:number gap opens     ] XO:i:0\n            #[15:number gap extensions] XG:i:0\n            #[16:edit distance        ] NM:i:0\n            #[17:string for mismatches] MD:Z:33\n            #[18:whether or not paired] YT:Z:UU\n            self.exists          = True\n            self.read_id         = split_line[0]\n            self.strand          = \"+\" if split_line[1] == \"0\" or split_line[1] == \"256\" else \"-\"\n            self.chromosome      = split_line[2]\n            self.start           = int(split_line[3])\n            self.mapping_quality = int(split_line[4])\n            self.seq             = split_line[9]\n            self.seq_quality     = split_line[10]\n            self.alignment_score = int(split_line[11].split(\":\")[-1])\n\n            for value in split_line[11:]:\n                if value[0:3] == \"XN:\":\n                    self.num_Ns          = int(value.split(\":\")[-1])\n                if value[0:3] == \"XM:\":\n                    self.num_mismatches  = int(value.split(\":\")[-1])\n                if value[0:3] == \"XO:\":\n                    self.num_gaps        = int(value.split(\":\")[-1])\n                if value[0:3] == \"MD:\":\n                    self.md = value.split(\":\")[-1]\n\n            self.stop = self.start+len(self.seq)\n            self.gtf = None\n\n    def donor(self):\n        \"\"\"\n        Goal: return the donor position of the SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            The donor position as an integer\n        \"\"\"\n        don = self.stop if self.strand == \"+\" else self.start\n        return don\n\n    def acceptor(self):\n        \"\"\"\n        Goal: return the acceptor position of the SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            The acceptor position as an integer\n        \"\"\"\n        acc = self.start if self.strand == \"+\" else self.stop\n        return acc\n\n    def str_gene(self):\n        \"\"\"\n        Goal: return the gene name associated with this SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            None in string form if no gene, or the gene name in string form\n        \"\"\"\n        if self.gtf:\n            return str(self.gtf.gene_name)\n        else:\n            return str(self.gtf)\n\n    def gene_strand(self):\n        \"\"\"\n        Goal: return the gtf gene strand associated with this SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            None in string form if no gene, or the gene strand in string form\n        \"\"\"\n        if self.gtf:\n            return str(self.gtf.strand)\n        else:\n            return str(self.gtf)\n\n    def junction(self):\n        \"\"\"\n        Goal: get a string of SAMEntry that looks similar to junction fasta headers\n        Arguments:\n            none\n\n        Returns:\n            a string of this SAMEntry\n        \"\"\"\n        out_str = \"\"\n        out_str += \"jct|\"+self.chromosome.split(\"|\")[1] if \"|\" in self.chromosome else self.chromosome\n        out_str += \"|\"+str(self.start)\n        out_str += \"|\"+str(self.stop)\n        out_str += \"|\"+str(self.strand)\n        return out_str\n\n    def __str__(self):\n        \"\"\"\n        Goal: get a human friendly string representation of SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            a string of important information of self\n        \"\"\"\n        ret_str = \"\"\n        ret_str += str(self.read_id)+\"\\t\"\n        ret_str += str(self.seq)+\"\\t\"\n        ret_str += str(self.chromosome)+\"\\t\"\n        ret_str += str(self.start)+\"\\t\"\n        ret_str += str(self.stop)+\"\\n\"\n        return ret_str\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allow comparison between SAMEntries for sorting\n        Arguments:\n            other is of type SAMEntry as well\n\n        Returns:\n            true if self is on a smaller chromosome, or has a smaller\n            start if chromosomes are shared, otherwise false\n        \"\"\"\n        same_chr = self.chromosome == other.chromosome\n        if not same_chr:\n            return self.chromosome < other.chromosome\n        else:\n            return self.start < other.start",
                "filename": "SPORK_SAMEntry.py"
              },
              {
                "fileContent": "#BinPair class\nclass BinPair(object):\n    __slots__ = [\"five_prime_SAM\",\"three_prime_SAM\",\"five_prime_bin\",\"three_prime_bin\",\n                 \"five_prime_strand\",\"three_prime_strand\",\"bin_pair\",\"five_prime_chr\",\"three_prime_chr\"]\n\n    def __init__(self,five_prime_SAM,three_prime_SAM,five_prime_bin,three_prime_bin):\n        \"\"\"\n        Goal: setup a BinPair object\n        Arguments:\n            a 5' SAMEntry object, a 3' SAMEntry object, and a bin from each (bins are ints)\n\n        Returns:\n            nothing\n        \"\"\"\n        self.five_prime_SAM = five_prime_SAM\n        self.three_prime_SAM = three_prime_SAM\n        self.five_prime_bin = int(five_prime_bin)\n        self.three_prime_bin = int(three_prime_bin)\n        self.five_prime_strand = five_prime_SAM.strand\n        self.three_prime_strand = three_prime_SAM.strand\n        self.five_prime_chr = five_prime_SAM.chromosome\n        self.three_prime_chr = three_prime_SAM.chromosome\n        self.bin_pair = self.five_prime_chr+\":\"+str(self.five_prime_bin)+\"_\"+self.three_prime_chr+\":\"+str(self.three_prime_bin)+\"_(\"+self.five_prime_strand+\",\"+self.three_prime_strand+\")\"\n\n    #Schematic of what the reverse compliment aims to do:\n    #================\n    #Before flipping:\n    #================\n    #\n    #(+ strand)-----------------------------------------\n    #\n    #             (*)  (#)                (*)  (#)\n    #              ======                  ======\n    #(- strand)----| 3' |------------------| 5' |-------\n    #              ======                  ======\n    #\n    #(*)'s are the upstream positions and (#)'s are the downstream positions\n    #\n    #===============\n    #After flipping:\n    #===============\n    #\n    #             (*)  (#)                (*)  (#)\n    #              ======                  ======\n    #(+ strand)----| 5' |------------------| 3' |-------\n    #              ======                  ======\n    #\n    #(- strand)-----------------------------------------\n    #\n    #So the 5' box got the orig 3' positions and should have the rev comp seq of the orig 3' seq\n    #the same thing happens to the 3' box\n    def take_reverse_compliment(self):\n        \"\"\"\n        Goal: take the reverse compliment of this bin pair\n        Arguments:\n            none\n\n        Returns:\n            itself for use in list comprehensions\n        \"\"\"\n        #Switch all the strands\n        self.five_prime_SAM.strand = \"-\" if self.five_prime_SAM.strand == \"+\" else \"+\"\n        self.three_prime_SAM.strand = \"-\" if self.three_prime_SAM.strand == \"+\" else \"+\"\n        self.five_prime_strand = \"-\" if self.five_prime_strand == \"+\" else \"+\"\n        self.three_prime_strand = \"-\" if self.three_prime_strand == \"+\" else \"+\"\n\n        #Swap the positions of the five and three prime SAMs\n        hold_five_prime_start = self.five_prime_SAM.start\n        hold_five_prime_stop = self.five_prime_SAM.stop\n        self.five_prime_SAM.start = self.three_prime_SAM.start\n        self.five_prime_SAM.stop = self.three_prime_SAM.stop\n        self.three_prime_SAM.start = hold_five_prime_start\n        self.three_prime_SAM.stop = hold_five_prime_stop\n\n        #Take the reverse compliment of the 5' and 3' seqs\n        #The list comprehensions are complicated but I like doing it in one line:\n        #   The [rev_comp_dict[base] for base in self.five_prime_SAM.seq] builds a list of complimentary bases\n        #   The \"\".join takes that list and turns it into a string\n        #   The [::-1] at the very end reverses the string to turn the compliment string into the rev comp string\n        rev_comp_dict = {\"A\":\"T\",\"a\":\"t\",\"T\":\"A\",\"t\":\"a\",\n                         \"C\":\"G\",\"c\":\"g\",\"G\":\"C\",\"g\":\"c\",\n                         \"N\":\"N\",\"n\":\"n\"}\n        rev_comp_5_prime_seq = \"\".join([rev_comp_dict[base] for base in self.five_prime_SAM.seq])[::-1]\n        rev_comp_3_prime_seq = \"\".join([rev_comp_dict[base] for base in self.three_prime_SAM.seq])[::-1]\n\n        #Then put the orig 3' rev comp into the new 5' and vice versa\n        self.five_prime_SAM.seq = rev_comp_3_prime_seq\n        self.three_prime_SAM.seq = rev_comp_5_prime_seq\n\n        #Switch the chromosomes too in case this is a fusion\n        hold_chromosome = self.five_prime_SAM.chromosome\n        self.five_prime_SAM.chromosome = self.three_prime_SAM.chromosome\n        self.three_prime_SAM.chromosome = hold_chromosome\n\n        #Using this in a list comprehension, so I want it to return itself\n        return self\n\n    def __str__(self):\n        \"\"\"\n        Goal: make this object into a string for easy printing\n        Arguments:\n            none\n\n        Returns:\n            a string representation of a bin pair\n        \"\"\"\n        return \"Bin Pair: \"+self.bin_pair+\" Left: \"+self.five_prime_SAM.read_id+\" Right: \"+self.three_prime_SAM.read_id+\"\\n\"\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allow comparison between two binpair objects\n        Arguments:\n            other is a binpair object just like self\n\n        Returns:\n            true if the bin_pair string of self is less than that of other\n        \"\"\"\n        return self.bin_pair < other.bin_pair",
                "filename": "SPORK_BinPair.py"
              },
              {
                "fileContent": "import argparse\nimport pickle\n\nparser = argparse.ArgumentParser()\nparser.add_argument('-sam', '--sam_file', help = 'SAM file')\nparser.add_argument('-dj', '--denovo_junctions', help = 'pickle file')\nparser.add_argument('-fj', '--fusion_junctions', help = 'pickle file')\nparser.add_argument('-s', '--sample', help = 'sample name')\n\nargs = parser.parse_args()\n\ndenovo_junctions = pickle.load(open(args.denovo_junctions,\"rb\"))\nfus_jct_dict = pickle.load(open(args.fusion_junctions, \"rb\"))\nbadfj3_mapped = args.sam_file\n\nflags = [\"paired\",\"proper\",\"no_align\",\"paired_no_align\",\"minus\",\"mate_minus\",\"R1\",\"R2\"]\nseen_jct_inds = []\n\njct_dict = {}\nfor jct in denovo_junctions:\n    jct_dict[jct.jct_ind] = jct\n\nwith open(badfj3_mapped, \"r\") as badfj3_mapped_f:\n    for line in badfj3_mapped_f:\n        # NOTE this is a sloppy way of parsing a PE SAM file (should use samtools view)\n        split_line = line.split('\\t')\n        jct_ind = int(split_line[0])\n        flag = int(split_line[1])\n\n        # Does sloppy binary flag parsing\n        jct_flags = {flags[ind]: bool(int(bit)) for ind, bit in enumerate(format(flag, \"08b\"))}\n\n        # If it didn't align, then just skip it, it can't be a badfj3\n        if jct_flags[\"no_align\"] or jct_flags[\"paired_no_align\"]:\n            continue\n        # If it did align AND it has already been seen this is a badfj3\n        elif jct_ind in seen_jct_inds:\n            jct_dict[jct_ind].badfj3 = True\n        # If it did align but has not already been seen put it in the see_jct_inds\n        else:\n            seen_jct_inds.append(jct_ind)\n\njunction_fasta = open(args.sample + \"_novel_junctions.fasta\", \"w\")\nlog_style_file = open(args.sample + \"_novel_junctions.log\", \"w\")\nfusions_file = open(args.sample + \"_novel_fusions.fasta\", \"w\")\n\n\nunique_seq = {}\nseq_duplicates = {}\nsplice_flank_len = int(denovo_junctions[0].constants_dict[\"splice_flank_len\"])\n\nduplicate_junctions = {}\n\njunctions_with_read_ids = {}\n\nfor denovo_junction in denovo_junctions:\n    #NOTE change back to verbose_fasta_string()\n    junction_fasta.write(denovo_junction.fasta_MACHETE())\n    log_style_file.write(denovo_junction.log_string())\n    if denovo_junction.jct_ind in fus_jct_dict:\n\n        denovo_junction.add_duplicates(duplicate_junctions)\n\n        if denovo_junction.format_consensus(splice_flank_len) in unique_seq:\n            seq_duplicates[denovo_junction.fasta_header()] = unique_seq[denovo_junction.format_consensus(splice_flank_len)]\n        else:\n            unique_seq[denovo_junction.format_consensus(splice_flank_len)] = denovo_junction.fasta_header()\n            fusions_file.write(denovo_junction.fasta_MACHETE())\n\n            junctions_with_read_ids[denovo_junction.jct_ind] = []\n            for bp in denovo_junction.bin_pair_group:\n                junctions_with_read_ids[denovo_junction.jct_ind].append(bp.five_prime_SAM.read_id[:-3])\n\n\npickle.dump(seq_duplicates, open(args.sample + \"_seq_duplicates.pickle\",\"wb\"), -1)\npickle.dump(duplicate_junctions, open(args.sample + \"_duplicate_junctions.pickle\",\"wb\"), -1)\npickle.dump(junctions_with_read_ids, open(args.sample + \"_junctions_with_read_ids.pickle\",\"wb\"), -1)",
                "filename": "badfj3.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "inputs": [
          {
            "sbg:altPrefix": "--sam_file",
            "id": "#sam_file",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-sam",
              "loadContents": false,
              "separate": true
            },
            "required": false
          },
          {
            "sbg:altPrefix": "--fusion_junctions",
            "id": "#fusion_junctions",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fj",
              "separate": true
            },
            "required": false
          },
          {
            "sbg:altPrefix": "--denovo_junctions",
            "id": "#denovo_junctions",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-dj",
              "separate": true
            },
            "required": false
          }
        ],
        "outputs": [
          {
            "id": "#seq_duplicates",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#denovo_junctions",
              "glob": "*_seq_duplicates.pickle"
            }
          },
          {
            "id": "#novel_junctions_log",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#sam_file",
              "glob": "*_novel_junctions.log"
            }
          },
          {
            "id": "#novel_junctions",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#sam_file",
              "glob": "*_novel_junctions.fasta"
            }
          },
          {
            "id": "#novel_fusions",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#sam_file",
              "glob": "*_novel_fusions.fasta"
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_junctions_with_read_ids.pickle",
              "sbg:inheritMetadataFrom": "#denovo_junctions"
            },
            "id": "#junctions_with_read_ids"
          },
          {
            "id": "#duplicate_junctions",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#denovo_junctions",
              "glob": "*_duplicate_junctions.pickle"
            }
          }
        ],
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "baseCommand": [
          "python",
          "badfj3.py"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\tif($job.inputs.sam_file && $job.inputs.sam_file.metadata && $job.inputs.sam_file.metadata.sample_id)\n      return \"-s \" + $job.inputs.sam_file.metadata.sample_id\n    return \"\"\n}"
            },
            "separate": true
          }
        ],
        "sbg:image_url": null,
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520433220,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520433246,
            "sbg:revisionNotes": "revision 6 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1525813896,
            "sbg:revisionNotes": "SPORK_Junction.py and SPORK_SAMEntry.py updated"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527438866,
            "sbg:revisionNotes": "SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527504880,
            "sbg:revisionNotes": "SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527519739,
            "sbg:revisionNotes": "SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527977839,
            "sbg:revisionNotes": "span_cutoff=1e6"
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528043814,
            "sbg:revisionNotes": "span_cutoff=1e5"
          },
          {
            "sbg:revision": 8,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528207426,
            "sbg:revisionNotes": "SPORK_SAMEntry num_mismatches updated"
          },
          {
            "sbg:revision": 9,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528292424,
            "sbg:revisionNotes": "Everything updated"
          },
          {
            "sbg:revision": 10,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529328992,
            "sbg:revisionNotes": "SPORK_utils.py handles multiple alignments"
          },
          {
            "sbg:revision": 11,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529589330,
            "sbg:revisionNotes": "back to revision 9"
          },
          {
            "sbg:revision": 12,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530018363,
            "sbg:revisionNotes": "SPORK_Junction, SPORK_utils and SPORK_consensus_utils updated to handle multiple alignments"
          },
          {
            "sbg:revision": 13,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530055996,
            "sbg:revisionNotes": "SPORK_utils updated: handles multiple alignments"
          },
          {
            "sbg:revision": 14,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530216971,
            "sbg:revisionNotes": "all scripts updated"
          },
          {
            "sbg:revision": 15,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530225416,
            "sbg:revisionNotes": "SPORK_Junction: .gtf.synonyms"
          },
          {
            "sbg:revision": 16,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530262131,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 17,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531178646,
            "sbg:revisionNotes": "SPORK_Junction: break-point"
          },
          {
            "sbg:revision": 18,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531209263,
            "sbg:revisionNotes": "SPORK_Junction: break-point added fixed"
          },
          {
            "sbg:revision": 19,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533645442,
            "sbg:revisionNotes": "SPORK_Junction: add_junction: break-point added"
          },
          {
            "sbg:revision": 20,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534781535,
            "sbg:revisionNotes": "SPORK_utils and SPORK_SAMEntry updated"
          },
          {
            "sbg:revision": 21,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534785526,
            "sbg:revisionNotes": "SPORK_SAMEntry fixed"
          },
          {
            "sbg:revision": 22,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534790494,
            "sbg:revisionNotes": "SPORK_SAMEntry fixed"
          },
          {
            "sbg:revision": 23,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534805390,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 24,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534945309,
            "sbg:revisionNotes": "SPORK_Junction updated"
          },
          {
            "sbg:revision": 25,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534955817,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 26,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535201883,
            "sbg:revisionNotes": "SPORK_Junction, get_fusion_type: span_cutoff=1e6"
          },
          {
            "sbg:revision": 27,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535537887,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 28,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535754945,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e0)"
          },
          {
            "sbg:revision": 29,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535846249,
            "sbg:revisionNotes": "def get_fusion_type(self, span_cutoff=1e3)"
          },
          {
            "sbg:revision": 30,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535908509,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 31,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536347505,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 32,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536350401,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 33,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536351441,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 34,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536359350,
            "sbg:revisionNotes": "SPORK_Junction format_consensus updated"
          },
          {
            "sbg:revision": 35,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536363509,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 36,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536370352,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e6)"
          },
          {
            "sbg:revision": 37,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536419407,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 38,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536448122,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 39,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536480718,
            "sbg:revisionNotes": "seq_duplicates added"
          },
          {
            "sbg:revision": 40,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536518455,
            "sbg:revisionNotes": "SPORK_Junction: fasta_header added"
          },
          {
            "sbg:revision": 41,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536526718,
            "sbg:revisionNotes": "fasta_header() fixed"
          },
          {
            "sbg:revision": 42,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536704502,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind() fixed"
          },
          {
            "sbg:revision": 43,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536704613,
            "sbg:revisionNotes": "SPORK_Junction splice_ind() fixed"
          },
          {
            "sbg:revision": 44,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536704642,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind() fixed"
          },
          {
            "sbg:revision": 45,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536709896,
            "sbg:revisionNotes": "SPORK_Junction: fasta_header() added"
          },
          {
            "sbg:revision": 46,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536972713,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind() and fasta_header() updated"
          },
          {
            "sbg:revision": 47,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537020920,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 48,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537129937,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4)"
          },
          {
            "sbg:revision": 49,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537137784,
            "sbg:revisionNotes": "def get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 50,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537223285,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5), strand"
          },
          {
            "sbg:revision": 51,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537229307,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4)"
          },
          {
            "sbg:revision": 52,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537346776,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 53,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537722355,
            "sbg:revisionNotes": "similar_seq added"
          },
          {
            "sbg:revision": 54,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537729017,
            "sbg:revisionNotes": "fixed_splice_flank_len fixed"
          },
          {
            "sbg:revision": 55,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537734266,
            "sbg:revisionNotes": "fixed prefix removed"
          },
          {
            "sbg:revision": 56,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537832532,
            "sbg:revisionNotes": "duplicate_junctions added, similar_seq removed"
          },
          {
            "sbg:revision": 57,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1538688957,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4)"
          },
          {
            "sbg:revision": 58,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1539076960,
            "sbg:revisionNotes": "is_at_boundary, get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 59,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545151864,
            "sbg:revisionNotes": "SPORK_utils.py: collapse_junctions"
          },
          {
            "sbg:revision": 60,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545866849,
            "sbg:revisionNotes": "SPORK_Junction.py: get_fusion_type fixed,"
          },
          {
            "sbg:revision": 61,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1547547110,
            "sbg:revisionNotes": "SPORK_Junction: get_fusion_type fixed"
          },
          {
            "sbg:revision": 62,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550145935,
            "sbg:revisionNotes": "junctions_with_read_ids added"
          },
          {
            "sbg:revision": 63,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550191210,
            "sbg:revisionNotes": "bp.five_prime_SAM.read_id[:-3]"
          },
          {
            "sbg:revision": 64,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550770246,
            "sbg:revisionNotes": "SPORK_utils.py and SPORK_Junction.py updated to support collapsed_num and uniformity_score"
          },
          {
            "sbg:revision": 65,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550773155,
            "sbg:revisionNotes": "SPORK_Junction.py: _SAM instead of _sam"
          },
          {
            "sbg:revision": 66,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550774832,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: bin_pair. added"
          },
          {
            "sbg:revision": 67,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550779742,
            "sbg:revisionNotes": "SPORK_utils.py fixed: repr_jct"
          },
          {
            "sbg:revision": 68,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550785342,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: self.collapsed_num"
          },
          {
            "sbg:revision": 69,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550791559,
            "sbg:revisionNotes": "SPORK_Junction.py: round uniformity score"
          },
          {
            "sbg:revision": 70,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550795822,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: uniformity_score log"
          },
          {
            "sbg:revision": 71,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550959682,
            "sbg:revisionNotes": "SPORK_Junction.py: uniformity_score log \";\" and allow within gene splicing"
          }
        ],
        "sbg:cmdPreview": "python badfj3.py  -s SAMPE",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "denovo_junctions": {
              "secondaryFiles": [],
              "path": "/path/to/denovo_junctions.ext",
              "class": "File",
              "size": 0
            },
            "fusion_junctions": {
              "secondaryFiles": [],
              "path": "/path/to/fusion_junctions.ext",
              "class": "File",
              "size": 0
            },
            "sam_file": {
              "metadata": {
                "sample_id": "SAMPE"
              },
              "size": 0,
              "path": "/path/to/sam_file.ext",
              "class": "File",
              "secondaryFiles": []
            }
          }
        },
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/badfj3/71",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/badfj3/71",
        "sbg:revision": 71,
        "sbg:revisionNotes": "SPORK_Junction.py: uniformity_score log \";\" and allow within gene splicing",
        "sbg:modifiedOn": 1550959682,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520433220,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos",
          "milos_jordanski"
        ],
        "sbg:latestRevision": 71,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a668c3846b5cdad1fa5795a93d0e3f7781068777ae05733c6870b676a798c4c7d",
        "x": 2814.335656205902,
        "y": -103.98425839944446
      },
      "inputs": [
        {
          "id": "#SPORK_BadFJ3.sam_file",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.result_sam_file"
          ]
        },
        {
          "id": "#SPORK_BadFJ3.fusion_junctions",
          "source": [
            "#SPORK_concatenate_files.fusion_junction_ids_new"
          ]
        },
        {
          "id": "#SPORK_BadFJ3.denovo_junctions",
          "source": [
            "#SPORK_concatenate_files.denovo_junctions_all"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_BadFJ3.seq_duplicates"
        },
        {
          "id": "#SPORK_BadFJ3.novel_junctions_log"
        },
        {
          "id": "#SPORK_BadFJ3.novel_junctions"
        },
        {
          "id": "#SPORK_BadFJ3.novel_fusions"
        },
        {
          "id": "#SPORK_BadFJ3.junctions_with_read_ids"
        },
        {
          "id": "#SPORK_BadFJ3.duplicate_junctions"
        }
      ],
      "sbg:x": 2814.335656205902,
      "sbg:y": -103.98425839944446
    },
    {
      "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads",
      "run": {
        "class": "CommandLineTool",
        "label": "GLM_script_UseIndel_SPORK_With_Building_Reads",
        "description": "",
        "requirements": [
          {
            "fileDef": [
              {
                "fileContent": "########## FUNCTIONS ##########\n\nrequire(data.table)\nlibrary(base)\nset.seed(1, kind = NULL, normal.kind = NULL)\n\n# allows for variable read length (for trimmed reads)\ngetOverlapForTrimmed <- function(x, juncMidpoint=150){\n    if (as.numeric(x[\"pos\"]) > juncMidpoint){\n        overlap = 0\n    } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n        overlap = 0\n    } else {\n        overlap = min(30,as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint, juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n    }\n    return(overlap)\n}\n\n#define islowquality parameter\ngetIsLowQual <- function(x){\n  if (as.numeric(x[\"qual\"]) <= 3){\n    IsLowQual = 1\n  } else {\n    IsLowQual = 0\n  }\n  \n  return(IsLowQual)\n}\n\n\ngetMaxOverlap <- function(x, juncMidpoint=150){\n  if (as.numeric(x[\"pos\"]) > juncMidpoint){\n    overlap = 0\n  } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n    overlap = 0\n  } else {\n    overlap = max(as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint, juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n  }\n  \n  return(overlap)\n}\n\nprocessScoreInput <- function(scoreFile){\n    setkey(scores, id)\n    return(scores)\n}\n\naddDerivedFields <- function(dt, useClass){\n    # correction 4/2016 of class files\n    if(nrow(dt) > 0){\n        # calculate and add on cols for junction overlap, score adjusted for N penalties,\n        ########## now, we have info for read1 and read2\n        # calculate and add on cols for junction overlap, score adjusted for N penalties,\n        dt[,`:=`(is.pos=useClass,overlap=apply(dt, 1, getOverlapForTrimmed), Maxoverlap=apply(dt, 1, getMaxOverlap))]  # syntax for multiple :=\n        dt[,IsLowQual:=apply(dt,1,getIsLowQual)]\n        # and length-adjusted alignment score (laplace smoothing so alignment score of 0 treated different for different length reads)\n        dt[, lenAdjScore:=(as.numeric(aScore) - 0.001)/as.numeric(readLen)]\n        \n        dt[Maxoverlap <= 50 ,Low_MaxOverlap := 1]\n        dt[Maxoverlap > 50 & Maxoverlap <= 70,Med_MaxOverlap := 1]\n        dt[Maxoverlap > 70,High_MaxOverlap := 1]\n        dt[is.na(Low_MaxOverlap),Low_MaxOverlap := 0]\n        dt[is.na(Med_MaxOverlap),Med_MaxOverlap := 0]\n        dt[is.na(High_MaxOverlap),High_MaxOverlap := 0]\n\n        quantiles_overlap = quantile(dt$Maxoverlap)\n        dt[Maxoverlap <= quantiles_overlap[[2]],MaxOverlap_Cat := 0]\n        dt[Maxoverlap > quantiles_overlap[[2]] & Maxoverlap <= quantiles_overlap[[4]],MaxOverlap_Cat := 1]\n        dt[Maxoverlap > quantiles_overlap[[4]],MaxOverlap_Cat := 2]\n\n        dt[tolower(junctionR2) %like% 'reg',is.JuncR2 := 1]\n        dt[tolower(junctionR2) %like% 'rev',is.JuncR2 := 1]\n        dt[is.na(is.JuncR2),is.JuncR2 := 0]\n\n        dt[,`:=`(pos=NULL, aScore=NULL, numN=NULL, readLen=NULL)]\n        ################# repeat for read2\n        ## therefore, only add length adjusted alignment score for R2 !!\n        # and length-adjusted alignment score (`` smoothing\" so alignment score of 0 treated different for different length reads)\n        dt[, lenAdjScoreR2:=(aScoreR2 - 0.001)/readLenR2]\n        dt[,`:=`(pos=NULL, aScoreR2=NULL, numNR2=NULL, readLenR2=NULL, adjScoreR2=NULL, aScore=NULL, numN=NULL, readLen=NULL, adjScore=NULL)]\n        }\n    return(dt)\n}\n\n# the input file is just the file output by the circularRNApipeline under /ids\nprocessClassInput <- function(classFile,my.names){\n\n    cats = fread(classFile,  sep=\"\\t\")\n    # cats = fread(classFile,  sep=\"\\t\")\n    ############################################################\n    if ( my.names!=\"none\"){\n        names(cats)=my.names\n    }\n\n    # syntax for changing names setnames(cats, names(cats), c(\"id\", \"R1\", \"R2\", \"class\"))\n    setkey(cats, id)\n    return(cats)\n}\n\n# To avoid integer underflow issue when we have too many very small or very large probabilities.\n# Take inverse of posterior probability, then take log, which simplifies to sum(log(q) - /sum(log(p))\n# and then reverse operations to convert answer back to a probability.\n# param p: vector of p values for all reads aligning to junction\n# return posterior probability that this is a circular junction based on all reads aligned to it\ngetPprodByJunction <- function(p ){\n    out = tryCatch(\n    {\n     x = sum(log(p))  # use sum of logs to avoid integer underflow\n     return(exp(x))\n    },\n    error = function(cond){\n     print(cond)\n     print(p)\n     return(\"?\")\n    },\n    warning = function(cond){\n     print(cond)\n     print(p)\n     return(\"-\")\n    }\n    )\n    return(out)\n}\n\napplyToClass <- function(dt, expr) {\n    e = substitute(expr)\n    dt[,eval(e),by=is.pos]\n}\n\napplyToJunction <- function(dt, expr) {\n    e = substitute(expr)\n    dt[,eval(e),by=junction]\n}\n\n\n#######################################################################\n######################## BEGIN JS ADDITION ############################\n####################### FIRST JS FUNCTION #############################\n########################################################################\n################# JS added function to FIT the GLM using arbitrary two-classes\n\nmy.glm.model<-function(which_formula, linear_reads, decoy_reads,use_R2 , max.iter, factor){\n  ### FUNCTION TO FIT GLM TO linear READS, returns the GLM and junction predictions,\n  saves = list()  # to hold all of the glms for future use\n  #max.iter = 2  # number of iterations updating weights and retraining glm\n  \n  # set up structure to hold per-read predictions\n  n.neg = nrow(decoy_reads)\n  n.pos = nrow(linear_reads)\n  n.reads = n.neg+n.pos\n  class.weight = min(n.pos, n.neg)\n  \n  ## note that this is coded as linear_reads and decoy_reads but applies to any pair class\n  \n  readPredictions = rbindlist(list(linear_reads, decoy_reads))\n  \n  # set initial weights uniform for class sum off all weights within any class is equal\n  if (n.pos >= n.neg){\n    readPredictions[,cur_weight:=c(rep(n.neg/n.pos, n.pos), rep(1*factor, n.neg))]\n  } else {\n    readPredictions[,cur_weight:=c(rep(1, n.pos), rep((factor*n.pos)/n.neg, n.neg))]\n  }\n  \n  # glm\n  \n  \n  \n  \n  for(i in 1:max.iter){\n    # M step: train model based on current read assignments, down-weighting the class with more reasourcds\n    \n    if (use_R2==1){\n      \n      if (which_formula==1){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==2){\n        x=glm( is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==3){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + Low_MaxOverlap:Maxoverlap + Med_MaxOverlap:Maxoverlap+ High_MaxOverlap:Maxoverlap, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==4){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2  + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==5){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2  + IsLowQual + is.JuncR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==6){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + is.JuncR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      }\n      \n    }\n    if (use_R2==0){\n      \n      if (which_formula==1){\n        x=glm(is.pos~overlap+lenAdjScore+qual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==2){\n        x=glm( is.pos~overlap+lenAdjScore+qual + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==3){\n        x=glm(is.pos~overlap+lenAdjScore+qual + Low_MaxOverlap:Maxoverlap + Med_MaxOverlap:Maxoverlap+ High_MaxOverlap:Maxoverlap, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==4){\n        x=glm(is.pos~overlap+lenAdjScore+qual + as.factor(MaxOverlap_Cat + 0), data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } \n      \n    }\n    saves[[i]] = x\n    \n    # get CI on the output probabilities and use 95% CI\n    preds = predict(x, type = \"link\", se.fit = TRUE)\n    critval = 1.96 # ~ 95% CI\n    upr = preds$fit + (critval * preds$se.fit)\n    lwr = preds$fit - (critval * preds$se.fit)\n    upr2 = x$family$linkinv(upr)\n    lwr2 = x$family$linkinv(lwr)\n    \n    # use the upper 95% value for decoys and lower 95% for linear\n    adj_vals = c(rep(NA, n.reads))\n    adj_vals[which(readPredictions$is.pos == 1)] = lwr2[which(readPredictions$is.pos == 1)]\n    adj_vals[which(readPredictions$is.pos == 0)] = upr2[which(readPredictions$is.pos == 0)]\n    x$fitted.values = adj_vals  # so I don't have to modify below code\n    \n    # report some info about how we did on the training predictions\n    totalerr = sum(abs(readPredictions[,is.pos] - round(x$fitted.values)))\n    print (paste(i,\"total reads:\",n.reads))\n    print(paste(\"both negative\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==0), \"out of \", n.neg))\n    print(paste(\"both positive\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==2), \"out of \", n.pos))\n    print(paste(\"classification errors\", totalerr, \"out of\", n.reads, totalerr/n.reads ))\n    #print(coef(summary(x)))\n    readPredictions[, cur_p:=x$fitted.values] # add this round of predictions to the running totals\n    \n    # calculate junction probabilities based on current read probabilities and add to junction predictions data.table\n    \n    tempDT = applyToJunction(subset(readPredictions, is.pos == 1), getPprodByJunction(cur_p))\n    setnames(tempDT, \"V1\", paste(\"iter\", i, sep=\"_\")) # iter_x is the iteration of product of ps\n    setkey(tempDT, junction)\n    junctionPredictions = junctionPredictions[tempDT]  # join junction predictions and the new posterior probabilities\n    rm(tempDT)  # clean up\n    \n    # E step: weight the reads according to how confident we are in their classification. Only if we are doing another loop\n    if(i < max.iter){\n      posScale = class.weight/applyToClass(readPredictions,sum(cur_p))[is.pos == 1,V1]\n      negScale = class.weight/(n.neg - applyToClass(readPredictions,sum(cur_p))[is.pos == 0,V1])\n      readPredictions[is.pos == 1,cur_weight:=cur_p*posScale]\n      readPredictions[is.pos == 0,cur_weight:=((1 - cur_p)*negScale*factor)]\n    }\n    setnames(readPredictions, \"cur_p\", paste(\"iter\", i, sep=\"_\")) # update names\n  }\n  \n  # calculate mean and variance for null distribution\n  ## this uses a normal approximation which holds only in cases with large numbers of reads, ie the CLT only holds as the number of reads gets very large\n  \n  ## should be called p-predicted\n  #read_pvals = readPredictions[,max.iter]\n  \n  # rename cols to be consistent with circular glmReports, syntax below removes col. \"ITER_1\"\n  if (max.iter>1){\n    # cleaning up\n    for (myi in c(1:(max.iter-1))){\n      junctionPredictions[, paste(\"iter_\",myi,sep=\"\"):=NULL]\n    }\n  }\n  setnames(junctionPredictions, paste(\"iter_\",max.iter,sep=\"\"), \"p_predicted\")\n  list(saves, junctionPredictions) ## JS these are the outputs and done with function\n}\n\n########################################################################\n###################### prediction from model ##########################\n##### as a function, needs input data and model\n\npredictNewClassP <- function(my_reads, null){ ## need not be circ_reads, just easier syntax\n    ######### up until this point, every calculation is PER READ, now we want a function to collapse\n    ######### want to do hypothesis testing\n    # calculate junction probabilities based on predicted read probabilities\n    ## Use simple function-- NOTE: \"p predicted\" is a CI bound not the point estimate. It is still technically a consistent estimate of p predicted\n    ## prob of an anomaly by glm is phat/(1+phat) under 'real' 1/(1+phat) under 'decoy' junction, so the ratio of these two reduces to 1/phat. as phat -> 1, no penalty is placed on anomaly.\n\n    #merge\n    junctionPredictions = my_reads[, .N, by = junction] # get number of reads per junction\n    setnames(junctionPredictions, \"N\", \"numReads\")\n    setkey(junctionPredictions, junction)\n\n    my_reads[, logproduct:=sum( log (p_predicted) * (1-is.anomaly) + log( 1/(1+p_predicted) *is.anomaly)), by=junction]\n    my_reads[,means_qual:=mean(qual), by=junction]    #Roozbeh added this new column for the average of mapping qualities to the report file\n    means = my_reads[,list(junction,means_qual)]\n    junctionPredictions = merge(junctionPredictions,means)\n\n    ## is anomaly adjusted log sum scoremm\n    logsum=my_reads[,sum( log ( p_predicted / (1+p_predicted*is.anomaly))), by=junction]\n    logsum_2=my_reads[,sum( log ( p_predicted_2 / (1+p_predicted_2*is.anomaly))), by=junction]\n    print (\"Logsum is reported which is equal to the sum of the logs of phats-- if exponentiated, corresponds to product of ps\")\n\n    ## merge these new variables to the dataframe\n    junctionPredictions=merge(junctionPredictions,logsum)\n    setnames(junctionPredictions, \"V1\", \"logsum\")\n\n    junctionPredictions=merge(junctionPredictions,logsum_2)\n    setnames(junctionPredictions, \"V1\", \"logsum_2\")\n\n    print (names(junctionPredictions))\n\n    ########### adding quantiles of p_predicted\n    n.quant=2\n    for (qi in 1:n.quant){\n        my_quantiles = my_reads[,round(10*quantile(p_predicted/(1+is.anomaly* p_predicted),probs=c(0:n.quant)/n.quant,na.rm=TRUE)[qi])/10,by=junction]\n\n        # merge into junctionPredictions\n        #print (head(my_quantiles))\n        setkey(my_quantiles,junction)\n        junctionPredictions=merge(junctionPredictions,my_quantiles)\n        setnames(junctionPredictions, \"V1\", paste(\"q_\",qi,sep=\"\"))\n    }\n\n    ##################################\n    ##  tempDT, to collapse across junctions\n    # p_predicteds are the exponentiation\n    junctionPredictions [ ,p_predicted_2:=exp(logsum_2),by=junction]\n    junctionPredictions [ ,p_predicted:=exp(logsum),by=junction]\n\n    #print (head(junctionPredictions[order(junction),]))\n\n    ## NOTE: P VALUE IS probability of observing a posterior as extreme as it is, \"getPvaluebyJunction\" is a bayesian posterior\n    junctionPredictionsWP=assignP(junctionPredictions,null)\n\n    rm(tempDT)  # clean up\n    ## adding here:\n\n    unique(junctionPredictionsWP) ## returned\n\n}\n########################################################################################### ASSIGN p values through permutation\n###################################\nassignP<-function(junctionPredictions,null) {\n    # logsum is the logged sum\n    # add p-value to junctionPredictions (see GB supplement with logic for this)\n\n    lognull=log(null)\n\n    use_mu = mean(lognull) # this is actually the mean of the read level predictions\n    use_var=var(lognull)\n    ## for large n,\n    #print (\"using cdf of null distribution as \"p_value\" which is misnomer for convenient and replaced below \")\n    n.thresh.exact=15\n    print (n.thresh.exact)\n\n    junctionPredictions[ (numReads>n.thresh.exact) , p_value :=  pnorm((logsum - numReads*use_mu)/sqrt(numReads*use_var))]\n\n    junctionPredictions[ (numReads>n.thresh.exact) , p_value_2 :=  pnorm((logsum_2 - numReads*use_mu)/sqrt(numReads*use_var))]\n\n    ## make empirical distribution of posteriors:\n\n    print (\"exact calculation through sampling 10K p predicted\")\n    my.dist=list(n.thresh.exact)\n    for ( tempN in 1:n.thresh.exact){ #### get distributions to convolve in next loop\n        n.sampled=1000 # used to compute the null distribution of posteriors\n        my.dist[[tempN]]=sample(lognull, n.sampled, replace=T)\n    }\n\n    for ( tempN in 1:n.thresh.exact){ ## use this loop to assign jncts w/ tempN\n        sim.readps=my.dist[[1]]\n        if (tempN>1){\n            for (tj in 2: tempN){ # loop, taking products\n            sim.readps=my.dist[[tj]] +  sim.readps\n        }\n    }\n    # convert to posterior\n    ## fraction of time p_predicted is smaller than -- so if p_predicted is very large, the fraction of time it is smaller is big\n    ## use the null to compute p_vals\n    #print (head(junctionPredictions))\n    #print (paste(tempN, \"is value of readcount for exact calculation and length of sim reads is \",length(sim.readps)))\n\n    junctionPredictions [ (numReads == tempN ), p_value:= sum( exp(sim.readps)<p_predicted)/length(sim.readps),by=junction]\n\n    #print (\"if below table is not empty, ERROR\")\n    #print (junctionPredictions[p_value>1])\n\n\n    junctionPredictions [ (numReads == tempN ), p_value_2:= sum( exp(sim.readps)<p_predicted_2)/length(sim.readps), by=junction]\n\n    }\n    return(junctionPredictions)\n}\n###########################################################################################\n###########################################################################################\n###########################################################################################\n###########################################################################################\n######## END FUNCTIONS, BEGIN WORK #########\n\n## command line inputs\nuser.input=0\n\nno.indel.classfile=0\n\nif (user.input==0){\n    args = commandArgs(trailingOnly = TRUE)\n    fusion_class_input=args[1]\n    class_input=args[2]\n    srr= args[3]\n    output_dir=args[4]\n    reg_indel_class_input = args[5]\n    FJ_indel_class_input = args[6]\n    print (paste(\"outputdir\", output_dir))\n    ## should be:\n    #FJ_indel_class_input = paste(parentdir,srr,\"_output_FJIndels.txt\",sep=\"\")\n    #reg_indel_class_input = paste(parentdir,srr,\"_output_RegIndel.txt\",sep=\"\")\n}\n\nmax.iter=2 ## iterations for glm\nfactor = 1\n\nif (user.input==1){\n output_dir=\"\"}\n\nuse.indels=1\nuse.fusion=1\n\n## define output class files\nglm_out = paste(output_dir,srr,\"_DATAOUT\",sep=\"\")\nanomaly_glm_out = paste(output_dir,srr,\"_AnomalyDATAOUT\",sep=\"\")\n\nindel_glm_out = paste(output_dir,srr,\"_IndelDATAOUT_SPORK\",sep=\"\")\nlinear_juncp_out = paste(output_dir,srr,\"_LINEARJUNCP_OUT_SPORK\",sep=\"\")\ncirc_juncp_out = paste(output_dir,srr,\"_CIRC_JUNCP_OUT_SPORK\",sep=\"\")\nfusion_juncp_out = paste(output_dir,srr,\"_FUSION_JUNCP_OUT_SPORK\",sep=\"\")\nlinearwanomaly_juncp_out = paste(output_dir,srr,\"_LINEAR_W_ANOMALY_JUNCP_OUT_SPORK\",sep=\"\")\nfusionwanomaly_juncp_out= paste(output_dir,srr,\"_FUSION_W_ANOM_JUNCPOUT_SPORK\", sep=\"\")\nfusionwanomaly_and_indel_juncp_out= paste(output_dir,srr,\"_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_SPORK\", sep=\"\")\n####### CURRENT GOAL IS TO UPDATE LINEAR pvalues w/ anomaly reads\nlinear_juncp_update_out = paste(output_dir,srr,\"_LINEARJUNCP_UPDATED_OUT_SPORK\",sep=\"\")\n##### SINK THE SUMMARY OF THIS SCRIPT\nprint (paste(\"OUtput dir\", fusionwanomaly_and_indel_juncp_out))\n#sink(paste(output_dir,srr,\"_glmInformation_\",sep=\"\"))\n\n### DONE W/ LOOP\n\n\nmy.names=\"none\" ## this is bc Gillians fields are not names like Lindas are\nmyClasses = processClassInput(class_input, my.names)\n\nif (use.fusion==1){\n    print (paste(\"using \", fusion_class_input))\n    myClassesFusion = processClassInput(fusion_class_input,names(myClasses))\n}\nif (use.indels==1){\n    print (paste(\"using \", reg_indel_class_input,\" and \" , FJ_indel_class_input))\n    myClassesRegIndel = processClassInput(reg_indel_class_input,names(myClasses))\n    myClassesFJIndel = processClassInput(FJ_indel_class_input,names(myClasses))\n}\n\nprint(paste(\"class info processed\", dim(myClasses)))\n\ncirc_reads = myClasses[(tolower(class) %like% 'circ'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\ncirc_reads = addDerivedFields(circ_reads, 1)\ncirc_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished circ_reads\")\n\ndecoy_reads = myClasses[(tolower(class) %like% 'decoy'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\ndecoy_reads = addDerivedFields(decoy_reads, 0)\ndecoy_reads [, is.anomaly:=1] ######## this IS an anomaly type\n\nprint (\"finished decoy_reads\")\n## was\nlinear_reads = myClasses[(tolower(class) %like% 'linear'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\nlinear_reads = addDerivedFields(linear_reads, 1)\nlinear_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished linear_reads\")\n\nanomaly_reads = myClasses[(tolower(class) %like% 'anomaly'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\nanomaly_reads [, is.anomaly:=1]\nprint (\"finished anomaly_reads\")\n\nif (use.indels==1){\n    ## in analogy, we first define all indels, then assign good and bad\n    ## we will use anomaly field as a general term for 'anomaly mapping and indel'\n    reg_indel_reads = myClassesRegIndel[, list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\n    reg_indel_reads [, is.anomaly:=1]\n    print (\"Finished reg indels\")\n\n    compatible_indel_reads = myClassesRegIndel[(tolower(class) %like% 'good'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\n    compatible_indel_reads [, is.anomaly:=1]\n\n    incompatible_indel_reads = myClassesRegIndel[(tolower(class) %like% 'bad'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\n    incompatible_indel_reads [, is.anomaly:=1]\n\n    FJ_indel_reads = myClassesFJIndel[, list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\n    FJ_indel_reads [, is.anomaly:=1]\n\n    if (dim(FJ_indel_reads)[1]==0){\n        no.indel.classfile = 1\n    } else{\n        FJ_indel_reads = addDerivedFields(FJ_indel_reads, 1)\n\n    }\n\n}\n\nif (use.fusion==1){\n\n    #was na.omit\n    fusion_reads = (myClassesFusion[(tolower(class) %like% 'fjgood'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),])\n    fusion_reads = addDerivedFields(fusion_reads, 1)\n    fusion_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\n    print (\"ANOMALY fusions defined as FJ bad-- of any variety\")\n    anomaly_fusion_reads = (myClassesFusion[(tolower(class) %like% 'fjbad'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]) # GILLIAN, pls comment here on what FJ bad is for the sake of documentation\n\n    anomaly_fusion_reads = addDerivedFields(anomaly_fusion_reads, 1)\n    anomaly_fusion_reads [, is.anomaly:=1] ## this is not an anomaly type so WILL NOT have p value ajustment\n}\n###############################################################################################\n## CANNOT ADD DERIVED FIELDS HERE BECAUSE WE DON'T KNOW WHICH ANOMALIES ARE GOOD AND/OR BAD\n##################### DERIVED FIELDS ADDED LATER ##############################################\n###############################################################################################\n\n# set up data structure to hold per-junction predictions\njunctionPredictions = linear_reads[, .N, by = junction] # get number of reads per junction\nsetnames(junctionPredictions, \"N\", \"numReads\")\nsetkey(junctionPredictions, junction)\n\n#### TRAIN EM ####\n## this should be a function of any two classes; and the output will be the model\n\n##\n\nn.row= dim(linear_reads)[1]\nn.sample=min(n.row,10000)\n\n#syntax example decoy_reads[,p_predicted:=NULL]\nprint (\"calling linear decoy model\")\nlinearDecoyGLMoutput = my.glm.model (6, linear_reads[ sample(n.row,n.sample,replace=FALSE),], decoy_reads, 1, max.iter, factor) ## 0 does not use R2 info\n\nsaves = linearDecoyGLMoutput[[1]]\nlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\n#save(saves, file=glm_out)  # save models\nlinearDecoyGLM = saves[[max.iter]] ##### this is the glm model\n\n## after fitting the GLM to linear vs. decoy, we want to store linear junction predictions in order to subset anomalies\n######## JS ADDITION: NOTE- NOT stratifying on permutation p value, although could add this too\n\n\n############################################################################\n### START LINEARS\n################# predict on anomaly reads -- AND TEST HOW THIS IMPACTS LINEAR PREDICTIONS\n############################ linear predictions ONLY ON THE BASIS of anomalies...\n\npreds = predict(linearDecoyGLM, newdata=linear_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\nlinear_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\nlinear_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n## for null\nprint (\"Assigning null distribution for all linear reads\")\nnull=linear_reads$p_predicted\n\n### ASSIGN p value:\nlinearJunctionPredictionsForModels = predictNewClassP(linear_reads, null)\n\npGoodThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.8,na.rm=TRUE)\ngood.linear=linearJunctionPredictionsForModels[p_value> pGoodThresh,]\n\npBadThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.2,na.rm=TRUE)\nbad.linear=linearJunctionPredictionsForModels[p_value< pBadThresh,]\n#####################################\n\n\n############## done with linears\n\n# define two classes of anomalies: those from good vs. bad junctions\n\n\ngood_anomaly_reads= anomaly_reads[!is.na(match(junction, good.linear$junction)),]\nbad_anomaly_reads= anomaly_reads[!is.na(match(junction, bad.linear$junction)),]\n## NOW add derived fields\n\nif (use.indels==1){\n    # define two classes of regular INDELS for training: those from good vs. bad junctions\n\n    good_indel_reads= compatible_indel_reads[!is.na(match(junction, good.linear$junction)),]\n    bad_indel_reads= incompatible_indel_reads[!is.na(match(junction, bad.linear$junction)),]\n\n    ## if either class is empty, change use.indels to zero\n    if (min(dim(good_indel_reads)[1],dim(bad_indel_reads)[1])<20){\n        print (\"CHANGING TO INDELS=0 becuase too few reads\")\n        use.indels=0\n    }\n\n\n}\n\n##### now, re-run script training on anomalies from good vs. bad\n\nuse.anomaly = 1\n\nif (dim(good_anomaly_reads)[1]==0 & dim(bad_anomaly_reads)[1]==0){\n    use.anomaly = 0\n}\n\nif (min(dim(good_anomaly_reads)[1], dim(bad_anomaly_reads)[1]) > 0){\n    ## The \"1\" belowneeds to be 0 and 1 for good and bad anomalies\n    good_anomaly_reads = addDerivedFields(good_anomaly_reads, 1) ####\n    bad_anomaly_reads = addDerivedFields(bad_anomaly_reads, 0) ####\n    all_anomaly_reads=rbind(good_anomaly_reads,bad_anomaly_reads)\n\n    ######## now, RECALL GLM  FOR ANOMALY READ MAPPERS\n    print (\"calling good anomaly bad anomaly model with .8 and .2 as thresholds\")\n    AnomInfo = my.glm.model (6, good_anomaly_reads, bad_anomaly_reads,1, max.iter, factor) ## JS these are the outputs and done with function\n    ANOMALYsaves=AnomInfo[[1]]\n    ANOMALYjunctionPredictions=AnomInfo[[2]]\n    AnomalyGLM = ANOMALYsaves[[max.iter]] ##### this is the glm model\n\n    preds = predict(AnomalyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n    all_anomaly_reads[, p_predicted:= AnomalyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    all_anomaly_reads[, p_predicted_2:= AnomalyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    use.anomaly = 2\n\n} else{\n    if(dim(good_anomaly_reads)[1]>0){\n        all_anomaly_reads = addDerivedFields(good_anomaly_reads, 1)\n\n        preds = predict(linearDecoyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n\n        lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n        lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n        all_anomaly_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n        all_anomaly_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n    }\n    if(dim(bad_anomaly_reads)[1]>0){\n        all_anomaly_reads = addDerivedFields(bad_anomaly_reads, 1)\n\n        preds = predict(linearDecoyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n\n        lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n        lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n        all_anomaly_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n        all_anomaly_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n    }\n}\n\n## in anaolgy, same for INDELS\nif (use.indels==1){\n    good_indel_reads = addDerivedFields(good_indel_reads, 1) ####\n    bad_indel_reads = addDerivedFields(bad_indel_reads, 0) ####\n    all_indel_reads=rbind(good_indel_reads,bad_indel_reads)\n}\n\nif (use.indels==1){\n    print (\"calling INDEL model with .8 and .2 as thresholds\")\n    IndelInfo = my.glm.model (1, good_indel_reads, bad_indel_reads,1, max.iter, factor) ## JS these are the outputs and done with function\n    INDELsaves=IndelInfo[[1]]\n    INDELjunctionPredictions=IndelInfo[[2]]\n    IndelGLM = INDELsaves[[max.iter]] ##### this is the glm model\n}\nif (use.indels==0){\n    print (\"USING GLM MODEL for INDEL MODEL\")\n    INDELsaves = linearDecoyGLMoutput[[1]]\n    INDELlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\n    IndelGLM = linearDecoyGLM\n}\n\n## save GLMS\n#save(AnomalyGLM, file=anomaly_glm_out)  # save models\nif (use.indels==1){\n    save(IndelGLM, file=indel_glm_out)  # save models\n}\n#save(linearDecoyGLM, file=glm_out)  # save models\n\npreds = predict(linearDecoyGLM, newdata=decoy_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\nlwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\ndecoy_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ndecoy_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n\n## need to rbind anomaly junctions\nif (use.anomaly != 0){\n    linear_and_anomaly=rbind(all_anomaly_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], linear_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n} else{\n    linear_and_anomaly = linear_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)]\n}\n\n\nlinearWithAnomalyJunctionPredictions = predictNewClassP(linear_and_anomaly, null)\n\n################# DONE WITH LINEARS\n#########################################################################\n\n#### PREDICT CIRCULAR JUNCTIONS #### SHOULD MAKE THIS MODULAR AND A FUNCTION so Farjunction and Anomalies can be used\n## SIMPLE PREDICT ON CIRCLES\npreds = predict(linearDecoyGLM, newdata=circ_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\ncirc_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ncirc_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\ncircularJunctionPredictions = predictNewClassP(circ_reads, null)\n\n#########################################################################\n## start fusions ############################################################################\n############################################################################\n################# NOTE: Here, we are only using fusion reads not fusion anomaly reads and treating the prediction just like circle\n############################################################################\n############################################################################\n## start prediction on good far junctions\n\nif (use.fusion==1){\n    fusion_reads$overlap=as.numeric(as.vector(fusion_reads$overlap))\n    preds = predict(linearDecoyGLM, newdata=fusion_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n    lwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\n    fusion_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    fusion_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    fusionJunctionPredictions = predictNewClassP( fusion_reads, null)\n\n\n    if(use.anomaly == 2){\n        # start prediction on BAD=Anomaly mapping\n        print (\"done with fusion normals, starting anomalies\")\n\n        preds = predict(AnomalyGLM, newdata=anomaly_fusion_reads, type = \"link\", se.fit = TRUE)\n        lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n        lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n        anomaly_fusion_reads[, p_predicted:= AnomalyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n        anomaly_fusion_reads[, p_predicted_2:= AnomalyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n        linear_and_anomaly_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n        linear_and_anomaly_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_fusions$overlap))\n        linearWithAnomalyFusionPredictions = predictNewClassP(linear_and_anomaly_fusions, null)\n\n        # start prediction on INDELS mapping\n        print (\"done with fusion anomalies starting indels\")\n    } else{\n        preds = predict(linearDecoyGLM, newdata=anomaly_fusion_reads, type = \"link\", se.fit = TRUE)\n        lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n        lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n        anomaly_fusion_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n        anomaly_fusion_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n        linear_and_anomaly_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n        linear_and_anomaly_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_fusions$overlap))\n        linearWithAnomalyFusionPredictions = predictNewClassP(linear_and_anomaly_fusions, null)\n    }\n}\n\nif (use.indels==1 & no.indel.classfile==0){\n    FJ_indel_reads$overlap=as.numeric(as.vector(FJ_indel_reads$overlap))\n    preds = predict(IndelGLM, newdata=FJ_indel_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\n    FJ_indel_reads[, p_predicted:= IndelGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    FJ_indel_reads[, p_predicted_2:= IndelGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n    linear_and_anomaly_and_indel_fusions=rbind(FJ_indel_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)],anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n}\n\n\n\nif (use.indels==0 & no.indel.classfile==0){\n    ## if not using indels, we assign indel reads according to the linear decoy model\n    preds = predict(linearDecoyGLM, newdata=FJ_indel_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n    FJ_indel_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    FJ_indel_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n    linear_and_anomaly_and_indel_fusions=rbind(FJ_indel_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)],anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n\n}\n\nif (no.indel.classfile==1){\n    linear_and_anomaly_and_indel_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n\n}\n\nlinear_and_anomaly_and_indel_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_and_indel_fusions$overlap))\nlinearWithAnomalyAndIndelFusionPredictions = predictNewClassP(linear_and_anomaly_and_indel_fusions, null)\n\nconsolidated_fusion=merge(fusionJunctionPredictions,linearWithAnomalyFusionPredictions , all=TRUE,by=\"junction\")\nconsolidated_fusion[,p_diff:=(p_predicted.x-p_predicted.y)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\nconsolidated_fusion=data.table(unique(consolidated_fusion))\n\n####### now add indels\n#verbose adds extra output and extra info to indel table\nverbose=0\n\nprint (\"now adding indels and changing names to reflect accurate terminology\")\nconsolidated_fusion_windel=merge(linearWithAnomalyFusionPredictions ,linearWithAnomalyAndIndelFusionPredictions, all=TRUE,by=\"junction\")\nconsolidated_fusion_windel[,p_diff_indel:=(p_predicted.y-p_predicted.x)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\nconsolidated_fusion_windel=data.table(unique(consolidated_fusion_windel))\n\nsetnames(consolidated_fusion_windel,\"p_predicted.x\", \"productPhat.x\")\nsetnames(consolidated_fusion_windel,\"p_predicted.y\", \"productPhat.y\")\nsetnames(consolidated_fusion_windel,\"p_value.x\", \"junction_cdf.x\")\nsetnames(consolidated_fusion_windel,\"p_value.y\", \"junction_cdf.y\")\n\n\nsetnames(consolidated_fusion_windel,\"p_predicted_2.x\", \"productPhat_lower.x\")\nsetnames(consolidated_fusion_windel,\"p_predicted_2.y\", \"productPhat_lower.y\")\nsetnames(consolidated_fusion_windel,\"p_value_2.x\", \"junction_cdf_lower.x\")\nsetnames(consolidated_fusion_windel,\"p_value_2.y\", \"junction_cdf_lower.y\")\n\nsetnames(consolidated_fusion_windel,\"p_diff_indel\", \"junction_cdf_windel_diff\")\nif (verbose==0){\n    consolidated_fusion_windel[,q_1.y:=NULL]\n    consolidated_fusion_windel[,q_2.y:=NULL]\n    consolidated_fusion_windel[,q_1.x:=NULL]\n    consolidated_fusion_windel[,q_2.x:=NULL]\n    consolidated_fusion_windel[,logsum.x:=NULL]\n    consolidated_fusion_windel[,logsum.y:=NULL]\n}\n\n## fusion_reads merging\n## JS ADD 8/14\nfusion_reads[strand!=0,maxNegStrandOverlap:=max(overlap),by=junction]\nfusion_reads[strand==0,maxPosStrandOverlap:=max(overlap),by=junction]\nout_fusions=merge(merge(consolidated_fusion_windel, unique(fusion_reads[strand==0,list(junction,maxPosStrandOverlap)]),by=\"junction\",add.x=TRUE), unique(fusion_reads[strand!=0,list(junction,maxNegStrandOverlap)]),by=\"junction\",add.x=TRUE)\n\nout_fusions_left_joint=merge(merge(consolidated_fusion_windel, unique(fusion_reads[strand==0,list(junction,maxPosStrandOverlap)]),by=\"junction\",all.x=TRUE), unique(fusion_reads[strand!=0,list(junction,maxNegStrandOverlap)]),by=\"junction\",all.x=TRUE)\n\nfusionwanomaly_and_indel_juncp_out_left_joint= paste(output_dir,srr,\"_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_SPORK_LEFT_JOIN\", sep=\"\")\n\nwrite.table(unique(out_fusions)[order(-junction_cdf.y),], fusionwanomaly_and_indel_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\nwrite.table(unique(out_fusions_left_joint)[order(-junction_cdf.y),], fusionwanomaly_and_indel_juncp_out_left_joint, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\ncir.verbose=0\n####################################################################################\n####################################################################################\nif (cir.verbose==1){\n    ## write circle prediction\n\n    setnames(circularJunctionPredictions,\"p_predicted\", \"productPhat.x\")\n    setnames(circularJunctionPredictions,\"p_predicted_2\", \"productPhat_lower.x\")\n    setnames(circularJunctionPredictions,\"p_value_2\", \"junction_cdf_lower.x\")\n    setnames(circularJunctionPredictions,\"p_value\", \"junction_cdf\")\n\n    write.table(unique(linearJunctionPredictions), linear_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n    write.table(unique(circularJunctionPredictions), circ_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\n    ## with anomalies, p value should be smaller so p_diff should always be negative...\n    consolidated_linear=merge(linearWithAnomalyJunctionPredictions,linearJunctionPredictions,by=\"junction\",all=TRUE)\n    consolidated_linear[,p_diff:=(p_predicted.x-p_predicted.y)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\n    consolidated_linear=data.table(unique(consolidated_linear))\n    write.table(unique(consolidated_linear), linearwanomaly_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\n    ##\n    my.null.quantiles=quantile(linear_reads$p_predicted,probs=c(0:10)/10,na.rm=TRUE)\n    ## refer fusions to these quantiles; 'falsely called' vs. true will be fraction of linears (conservative estimate) ; error at this quantile can be evaluated.\n\n    write.table(unique(fusionJunctionPredictions[order(-p_predicted),]),fusion_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n    write.table(unique(consolidated_fusion)[order(-p_predicted.y),], fusionwanomaly_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\n}",
                "filename": "GLM_script_UseIndel_SPORK.r"
              }
            ],
            "class": "CreateFileRequirement"
          },
          {
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#reg_indel_class_input",
            "inputBinding": {
              "separate": true,
              "position": 5,
              "sbg:cmdInclude": true
            },
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_class_input",
            "inputBinding": {
              "separate": true,
              "position": 1,
              "sbg:cmdInclude": true
            },
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#class_input",
            "inputBinding": {
              "separate": true,
              "position": 2,
              "sbg:cmdInclude": true
            },
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#FJ_indel_class_input",
            "inputBinding": {
              "separate": true,
              "loadContents": true,
              "position": 6,
              "sbg:cmdInclude": true
            },
            "required": false
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_LINEAR_W_ANOMALY_JUNCP_OUT_SPORK"
            },
            "id": "#linear_w_anomaly_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_LINEARJUNCP_UPDATED_OUT_SPORK"
            },
            "id": "#linear_juncp_updated_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_LINEARJUNCP_OUT_SPORK"
            },
            "id": "#linear_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_IndelDATAOUT_SPORK"
            },
            "id": "#indel_data_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_JUNCPOUT_SPORK"
            },
            "id": "#fusion_w_anomaly_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_SPORK_LEFT_JOIN"
            },
            "id": "#fusion_w_anomaly_and_indel_juncp_out_lef_join",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_SPORK"
            },
            "id": "#fusion_w_anomaly_and_indel_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_JUNCP_OUT_SPORK"
            },
            "id": "#fusion_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#class_input",
              "glob": "*_DATAOUT_SPORK"
            },
            "id": "#data_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_CIRC_JUNCP_OUT_SPORK"
            },
            "id": "#circ_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_AnomalyDATAOUT_SPORK"
            },
            "id": "#anomaly_data_out",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/machete_glm:r"
          }
        ],
        "baseCommand": [
          "chmod",
          "+x",
          "GLM_script_UseIndel_SPORK.r",
          "&&",
          "Rscript",
          "GLM_script_UseIndel_SPORK.r"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "position": 3,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.FJ_indel_class_input.metadata && $job.inputs.FJ_indel_class_input.metadata.sample_id)\n    \tcmd = $job.inputs.FJ_indel_class_input.metadata.sample_id\n\treturn cmd\n}\n",
              "class": "Expression"
            }
          },
          {
            "separate": true,
            "position": 4,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "script": "{\n\treturn \"./\"\n}",
              "class": "Expression"
            }
          }
        ],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fusion_class_input": {
              "class": "File",
              "size": 0,
              "path": "/path/to/fusion_class_input.ext",
              "secondaryFiles": []
            },
            "reg_indel_class_input": {
              "class": "File",
              "size": 0,
              "path": "/path/to/reg_indel_class_input.ext",
              "secondaryFiles": []
            },
            "FJ_indel_class_input": {
              "metadata": {
                "sample_id": "sample_name"
              },
              "class": "File",
              "size": 0,
              "path": "/path/to/FJ_indel_class_input.ext",
              "secondaryFiles": []
            },
            "class_input": {
              "metadata": {
                "sample_id": "sample_name"
              },
              "class": "File",
              "size": 0,
              "path": "/path/to/class_input.ext",
              "secondaryFiles": []
            }
          }
        },
        "sbg:cmdPreview": "chmod +x GLM_script_UseIndel_SPORK.r && Rscript GLM_script_UseIndel_SPORK.r  sample_name  ./",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:image_url": null,
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434169,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434188,
            "sbg:revisionNotes": "revision 7 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529581779,
            "sbg:revisionNotes": "which_formula added"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529584415,
            "sbg:revisionNotes": "Formula 4 for linear_decoy and anomaly"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529585800,
            "sbg:revisionNotes": "which_formula = 5"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529587381,
            "sbg:revisionNotes": "which_formula = 6"
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529835223,
            "sbg:revisionNotes": "FJ_indel_reads junctionR2 added"
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529850688,
            "sbg:revisionNotes": "use.anomaly = 0"
          },
          {
            "sbg:revision": 8,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529852885,
            "sbg:revisionNotes": "predict on all anomaly reads"
          },
          {
            "sbg:revision": 9,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529854691,
            "sbg:revisionNotes": "use.anomaly = 0 for real"
          },
          {
            "sbg:revision": 10,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529855432,
            "sbg:revisionNotes": "use.anomaly = 0 for real"
          },
          {
            "sbg:revision": 11,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529856579,
            "sbg:revisionNotes": "use.anomaly = 0 fixed"
          },
          {
            "sbg:revision": 12,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529877961,
            "sbg:revisionNotes": "back to revision 6"
          },
          {
            "sbg:revision": 13,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531043197,
            "sbg:revisionNotes": "is.anomaly:=0"
          },
          {
            "sbg:revision": 14,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531135017,
            "sbg:revisionNotes": "factor = 0.5 added"
          },
          {
            "sbg:revision": 15,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531139651,
            "sbg:revisionNotes": "factor = 1"
          },
          {
            "sbg:revision": 16,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531147269,
            "sbg:revisionNotes": "factor = 2"
          },
          {
            "sbg:revision": 17,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531178381,
            "sbg:revisionNotes": "factor = 1"
          },
          {
            "sbg:revision": 18,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536954135,
            "sbg:revisionNotes": "qual feature removed"
          },
          {
            "sbg:revision": 19,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536960993,
            "sbg:revisionNotes": "IndelGLM formula 6"
          },
          {
            "sbg:revision": 20,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536961128,
            "sbg:revisionNotes": "qual feature added and IndelGLM formula 6"
          },
          {
            "sbg:revision": 21,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537004214,
            "sbg:revisionNotes": "factor = 2"
          },
          {
            "sbg:revision": 22,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537004298,
            "sbg:revisionNotes": "factor = 0.5"
          },
          {
            "sbg:revision": 23,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537132794,
            "sbg:revisionNotes": "which_formula = 1, factor = 1"
          },
          {
            "sbg:revision": 24,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537136627,
            "sbg:revisionNotes": "which_formula = 2"
          },
          {
            "sbg:revision": 25,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537223713,
            "sbg:revisionNotes": "which_formula = 6, use.indels = 0"
          },
          {
            "sbg:revision": 26,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537226660,
            "sbg:revisionNotes": "use.indels = 2"
          },
          {
            "sbg:revision": 27,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537310058,
            "sbg:revisionNotes": "use.anomaly = 0"
          },
          {
            "sbg:revision": 28,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537481840,
            "sbg:revisionNotes": "back to rev 22"
          },
          {
            "sbg:revision": 29,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537562744,
            "sbg:revisionNotes": "back to rev 21"
          },
          {
            "sbg:revision": 30,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537606329,
            "sbg:revisionNotes": "rev: 22 + factor = 0.1"
          },
          {
            "sbg:revision": 31,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537654439,
            "sbg:revisionNotes": "factor = 1, logsum=+ 1*is.anomaly"
          },
          {
            "sbg:revision": 32,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1543711662,
            "sbg:revisionNotes": "rev17 + anomaly instead of decoy reads"
          },
          {
            "sbg:revision": 33,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550787385,
            "sbg:revisionNotes": "back to revision 17"
          },
          {
            "sbg:revision": 34,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550963560,
            "sbg:revisionNotes": "uniformity_pvalue added"
          },
          {
            "sbg:revision": 35,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550977566,
            "sbg:revisionNotes": "back to 33"
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/glm-script-useindel-spork/35",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/glm-script-useindel-spork/35",
        "sbg:revision": 35,
        "sbg:revisionNotes": "back to 33",
        "sbg:modifiedOn": 1550977566,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520434169,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos",
          "milos_jordanski"
        ],
        "sbg:latestRevision": 35,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ada534f673323d2ed2d5eb8cb788d024e617a7dbf77690feeadbc07fd1d7f2179",
        "x": 6253.336186382613,
        "y": 86.66676674949187
      },
      "inputs": [
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.reg_indel_class_input",
          "source": [
            "#MACHETE_RegIndels_ClassIDFile.output_RegIndel"
          ]
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.fusion_class_input",
          "source": [
            "#SPORK_FarJuncNaiveReport.IDs"
          ]
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.class_input",
          "source": [
            "#KNIFE_filterFDR.output"
          ]
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.FJ_indel_class_input",
          "source": [
            "#SPORK_FJIndels_ClassIDFile.temp_output_FJIndels"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.linear_w_anomaly_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.linear_juncp_updated_out"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.linear_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.indel_data_out"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.fusion_w_anomaly_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.fusion_w_anomaly_and_indel_juncp_out_lef_join"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.fusion_w_anomaly_and_indel_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.fusion_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.data_out"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.circ_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_SPORK_With_Building_Reads.anomaly_data_out"
        }
      ],
      "sbg:x": 6253.336186382613,
      "sbg:y": 86.66676674949187
    },
    {
      "id": "#SPORK_GLM_script_UseIndel",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK_GLM_script_UseIndel",
        "description": "",
        "requirements": [
          {
            "fileDef": [
              {
                "fileContent": "########## FUNCTIONS ##########\n\nrequire(data.table)\nlibrary(base)\nset.seed(1, kind = NULL, normal.kind = NULL)\n\n# allows for variable read length (for trimmed reads)\ngetOverlapForTrimmed <- function(x, juncMidpoint=150){\n    if (as.numeric(x[\"pos\"]) > juncMidpoint){\n        overlap = 0\n    } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n        overlap = 0\n    } else {\n        overlap = min(30,as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint, juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n    }\n    return(overlap)\n}\n\n#define islowquality parameter\ngetIsLowQual <- function(x){\n  if (as.numeric(x[\"qual\"]) <= 3){\n    IsLowQual = 1\n  } else {\n    IsLowQual = 0\n  }\n  \n  return(IsLowQual)\n}\n\n\ngetMaxOverlap <- function(x, juncMidpoint=150){\n  if (as.numeric(x[\"pos\"]) > juncMidpoint){\n    overlap = 0\n  } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n    overlap = 0\n  } else {\n    overlap = max(as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint, juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n  }\n  \n  return(overlap)\n}\n\nprocessScoreInput <- function(scoreFile){\n    setkey(scores, id)\n    return(scores)\n}\n\naddDerivedFields <- function(dt, useClass){\n    # correction 4/2016 of class files\n    if(nrow(dt) > 0){\n        # calculate and add on cols for junction overlap, score adjusted for N penalties,\n        ########## now, we have info for read1 and read2\n        # calculate and add on cols for junction overlap, score adjusted for N penalties,\n        dt[,`:=`(is.pos=useClass,overlap=apply(dt, 1, getOverlapForTrimmed), Maxoverlap=apply(dt, 1, getMaxOverlap))]  # syntax for multiple :=\n        dt[,IsLowQual:=apply(dt,1,getIsLowQual)]\n        # and length-adjusted alignment score (laplace smoothing so alignment score of 0 treated different for different length reads)\n        dt[, lenAdjScore:=(as.numeric(aScore) - 0.001)/as.numeric(readLen)]\n        \n        dt[Maxoverlap <= 50 ,Low_MaxOverlap := 1]\n        dt[Maxoverlap > 50 & Maxoverlap <= 70,Med_MaxOverlap := 1]\n        dt[Maxoverlap > 70,High_MaxOverlap := 1]\n        dt[is.na(Low_MaxOverlap),Low_MaxOverlap := 0]\n        dt[is.na(Med_MaxOverlap),Med_MaxOverlap := 0]\n        dt[is.na(High_MaxOverlap),High_MaxOverlap := 0]\n\n        quantiles_overlap = quantile(dt$Maxoverlap)\n        dt[Maxoverlap <= quantiles_overlap[[2]],MaxOverlap_Cat := 0]\n        dt[Maxoverlap > quantiles_overlap[[2]] & Maxoverlap <= quantiles_overlap[[4]],MaxOverlap_Cat := 1]\n        dt[Maxoverlap > quantiles_overlap[[4]],MaxOverlap_Cat := 2]\n\n        dt[tolower(junctionR2) %like% 'reg',is.JuncR2 := 1]\n        dt[tolower(junctionR2) %like% 'rev',is.JuncR2 := 1]\n        dt[is.na(is.JuncR2),is.JuncR2 := 0]\n\n        dt[,`:=`(pos=NULL, aScore=NULL, numN=NULL, readLen=NULL)]\n        ################# repeat for read2\n        ## therefore, only add length adjusted alignment score for R2 !!\n        # and length-adjusted alignment score (`` smoothing\" so alignment score of 0 treated different for different length reads)\n        dt[, lenAdjScoreR2:=(aScoreR2 - 0.001)/readLenR2]\n        dt[,`:=`(pos=NULL, aScoreR2=NULL, numNR2=NULL, readLenR2=NULL, adjScoreR2=NULL, aScore=NULL, numN=NULL, readLen=NULL, adjScore=NULL)]\n        }\n    return(dt)\n}\n\n# the input file is just the file output by the circularRNApipeline under /ids\nprocessClassInput <- function(classFile,my.names){\n\n    cats = fread(classFile,  sep=\"\\t\")\n    # cats = fread(classFile,  sep=\"\\t\")\n    ############################################################\n    if ( my.names!=\"none\"){\n        names(cats)=my.names\n    }\n\n    # syntax for changing names setnames(cats, names(cats), c(\"id\", \"R1\", \"R2\", \"class\"))\n    setkey(cats, id)\n    return(cats)\n}\n\n# To avoid integer underflow issue when we have too many very small or very large probabilities.\n# Take inverse of posterior probability, then take log, which simplifies to sum(log(q) - /sum(log(p))\n# and then reverse operations to convert answer back to a probability.\n# param p: vector of p values for all reads aligning to junction\n# return posterior probability that this is a circular junction based on all reads aligned to it\ngetPprodByJunction <- function(p ){\n    out = tryCatch(\n    {\n     x = sum(log(p))  # use sum of logs to avoid integer underflow\n     return(exp(x))\n    },\n    error = function(cond){\n     print(cond)\n     print(p)\n     return(\"?\")\n    },\n    warning = function(cond){\n     print(cond)\n     print(p)\n     return(\"-\")\n    }\n    )\n    return(out)\n}\n\napplyToClass <- function(dt, expr) {\n    e = substitute(expr)\n    dt[,eval(e),by=is.pos]\n}\n\napplyToJunction <- function(dt, expr) {\n    e = substitute(expr)\n    dt[,eval(e),by=junction]\n}\n\n\n#######################################################################\n######################## BEGIN JS ADDITION ############################\n####################### FIRST JS FUNCTION #############################\n########################################################################\n################# JS added function to FIT the GLM using arbitrary two-classes\n\nmy.glm.model<-function(which_formula, linear_reads, decoy_reads,use_R2 , max.iter, factor){\n  ### FUNCTION TO FIT GLM TO linear READS, returns the GLM and junction predictions,\n  saves = list()  # to hold all of the glms for future use\n  #max.iter = 2  # number of iterations updating weights and retraining glm\n  \n  # set up structure to hold per-read predictions\n  n.neg = nrow(decoy_reads)\n  n.pos = nrow(linear_reads)\n  n.reads = n.neg+n.pos\n  class.weight = min(n.pos, n.neg)\n  \n  ## note that this is coded as linear_reads and decoy_reads but applies to any pair class\n  \n  readPredictions = rbindlist(list(linear_reads, decoy_reads))\n  \n  # set initial weights uniform for class sum off all weights within any class is equal\n  if (n.pos >= n.neg){\n    readPredictions[,cur_weight:=c(rep(n.neg/n.pos, n.pos), rep(1*factor, n.neg))]\n  } else {\n    readPredictions[,cur_weight:=c(rep(1, n.pos), rep((factor*n.pos)/n.neg, n.neg))]\n  }\n  \n  # glm\n  \n  \n  \n  \n  for(i in 1:max.iter){\n    # M step: train model based on current read assignments, down-weighting the class with more reasourcds\n    \n    if (use_R2==1){\n      \n      if (which_formula==1){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==2){\n        x=glm( is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==3){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + Low_MaxOverlap:Maxoverlap + Med_MaxOverlap:Maxoverlap+ High_MaxOverlap:Maxoverlap, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==4){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2  + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==5){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2  + IsLowQual + is.JuncR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==6){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + is.JuncR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      }\n      \n    }\n    if (use_R2==0){\n      \n      if (which_formula==1){\n        x=glm(is.pos~overlap+lenAdjScore+qual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==2){\n        x=glm( is.pos~overlap+lenAdjScore+qual + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==3){\n        x=glm(is.pos~overlap+lenAdjScore+qual + Low_MaxOverlap:Maxoverlap + Med_MaxOverlap:Maxoverlap+ High_MaxOverlap:Maxoverlap, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==4){\n        x=glm(is.pos~overlap+lenAdjScore+qual + as.factor(MaxOverlap_Cat + 0), data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } \n      \n    }\n    saves[[i]] = x\n    \n    # get CI on the output probabilities and use 95% CI\n    preds = predict(x, type = \"link\", se.fit = TRUE)\n    critval = 1.96 # ~ 95% CI\n    upr = preds$fit + (critval * preds$se.fit)\n    lwr = preds$fit - (critval * preds$se.fit)\n    upr2 = x$family$linkinv(upr)\n    lwr2 = x$family$linkinv(lwr)\n    \n    # use the upper 95% value for decoys and lower 95% for linear\n    adj_vals = c(rep(NA, n.reads))\n    adj_vals[which(readPredictions$is.pos == 1)] = lwr2[which(readPredictions$is.pos == 1)]\n    adj_vals[which(readPredictions$is.pos == 0)] = upr2[which(readPredictions$is.pos == 0)]\n    x$fitted.values = adj_vals  # so I don't have to modify below code\n    \n    # report some info about how we did on the training predictions\n    totalerr = sum(abs(readPredictions[,is.pos] - round(x$fitted.values)))\n    print (paste(i,\"total reads:\",n.reads))\n    print(paste(\"both negative\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==0), \"out of \", n.neg))\n    print(paste(\"both positive\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==2), \"out of \", n.pos))\n    print(paste(\"classification errors\", totalerr, \"out of\", n.reads, totalerr/n.reads ))\n    #print(coef(summary(x)))\n    readPredictions[, cur_p:=x$fitted.values] # add this round of predictions to the running totals\n    \n    # calculate junction probabilities based on current read probabilities and add to junction predictions data.table\n    \n    tempDT = applyToJunction(subset(readPredictions, is.pos == 1), getPprodByJunction(cur_p))\n    setnames(tempDT, \"V1\", paste(\"iter\", i, sep=\"_\")) # iter_x is the iteration of product of ps\n    setkey(tempDT, junction)\n    junctionPredictions = junctionPredictions[tempDT]  # join junction predictions and the new posterior probabilities\n    rm(tempDT)  # clean up\n    \n    # E step: weight the reads according to how confident we are in their classification. Only if we are doing another loop\n    if(i < max.iter){\n      posScale = class.weight/applyToClass(readPredictions,sum(cur_p))[is.pos == 1,V1]\n      negScale = class.weight/(n.neg - applyToClass(readPredictions,sum(cur_p))[is.pos == 0,V1])\n      readPredictions[is.pos == 1,cur_weight:=cur_p*posScale]\n      readPredictions[is.pos == 0,cur_weight:=((1 - cur_p)*negScale*factor)]\n    }\n    setnames(readPredictions, \"cur_p\", paste(\"iter\", i, sep=\"_\")) # update names\n  }\n  \n  # calculate mean and variance for null distribution\n  ## this uses a normal approximation which holds only in cases with large numbers of reads, ie the CLT only holds as the number of reads gets very large\n  \n  ## should be called p-predicted\n  #read_pvals = readPredictions[,max.iter]\n  \n  # rename cols to be consistent with circular glmReports, syntax below removes col. \"ITER_1\"\n  if (max.iter>1){\n    # cleaning up\n    for (myi in c(1:(max.iter-1))){\n      junctionPredictions[, paste(\"iter_\",myi,sep=\"\"):=NULL]\n    }\n  }\n  setnames(junctionPredictions, paste(\"iter_\",max.iter,sep=\"\"), \"p_predicted\")\n  list(saves, junctionPredictions) ## JS these are the outputs and done with function\n}\n\n########################################################################\n###################### prediction from model ##########################\n##### as a function, needs input data and model\n\npredictNewClassP <- function(my_reads, null){ ## need not be circ_reads, just easier syntax\n    ######### up until this point, every calculation is PER READ, now we want a function to collapse\n    ######### want to do hypothesis testing\n    # calculate junction probabilities based on predicted read probabilities\n    ## Use simple function-- NOTE: \"p predicted\" is a CI bound not the point estimate. It is still technically a consistent estimate of p predicted\n    ## prob of an anomaly by glm is phat/(1+phat) under 'real' 1/(1+phat) under 'decoy' junction, so the ratio of these two reduces to 1/phat. as phat -> 1, no penalty is placed on anomaly.\n\n    #merge\n    junctionPredictions = my_reads[, .N, by = junction] # get number of reads per junction\n    setnames(junctionPredictions, \"N\", \"numReads\")\n    setkey(junctionPredictions, junction)\n\n    my_reads[, logproduct:=sum( log (p_predicted) * (1-is.anomaly) + log( 1/(1+p_predicted) *is.anomaly)), by=junction]\n    my_reads[,means_qual:=mean(qual), by=junction]    #Roozbeh added this new column for the average of mapping qualities to the report file\n    means = my_reads[,list(junction,means_qual)]\n    junctionPredictions = merge(junctionPredictions,means)\n\n    ## is anomaly adjusted log sum scoremm\n    logsum=my_reads[,sum( log ( p_predicted / (1+p_predicted*is.anomaly))), by=junction]\n    logsum_2=my_reads[,sum( log ( p_predicted_2 / (1+p_predicted_2*is.anomaly))), by=junction]\n    print (\"Logsum is reported which is equal to the sum of the logs of phats-- if exponentiated, corresponds to product of ps\")\n\n    ## merge these new variables to the dataframe\n    junctionPredictions=merge(junctionPredictions,logsum)\n    setnames(junctionPredictions, \"V1\", \"logsum\")\n\n    junctionPredictions=merge(junctionPredictions,logsum_2)\n    setnames(junctionPredictions, \"V1\", \"logsum_2\")\n\n    print (names(junctionPredictions))\n\n    ########### adding quantiles of p_predicted\n    n.quant=2\n    for (qi in 1:n.quant){\n        my_quantiles = my_reads[,round(10*quantile(p_predicted/(1+is.anomaly* p_predicted),probs=c(0:n.quant)/n.quant,na.rm=TRUE)[qi])/10,by=junction]\n\n        # merge into junctionPredictions\n        #print (head(my_quantiles))\n        setkey(my_quantiles,junction)\n        junctionPredictions=merge(junctionPredictions,my_quantiles)\n        setnames(junctionPredictions, \"V1\", paste(\"q_\",qi,sep=\"\"))\n    }\n\n    ##################################\n    ##  tempDT, to collapse across junctions\n    # p_predicteds are the exponentiation\n    junctionPredictions [ ,p_predicted_2:=exp(logsum_2),by=junction]\n    junctionPredictions [ ,p_predicted:=exp(logsum),by=junction]\n\n    #print (head(junctionPredictions[order(junction),]))\n\n    ## NOTE: P VALUE IS probability of observing a posterior as extreme as it is, \"getPvaluebyJunction\" is a bayesian posterior\n    junctionPredictionsWP=assignP(junctionPredictions,null)\n\n    rm(tempDT)  # clean up\n    ## adding here:\n\n    unique(junctionPredictionsWP) ## returned\n\n}\n########################################################################################### ASSIGN p values through permutation\n###################################\nassignP<-function(junctionPredictions,null) {\n    # logsum is the logged sum\n    # add p-value to junctionPredictions (see GB supplement with logic for this)\n\n    lognull=log(null)\n\n    use_mu = mean(lognull) # this is actually the mean of the read level predictions\n    use_var=var(lognull)\n    ## for large n,\n    #print (\"using cdf of null distribution as \"p_value\" which is misnomer for convenient and replaced below \")\n    n.thresh.exact=15\n    print (n.thresh.exact)\n\n    junctionPredictions[ (numReads>n.thresh.exact) , p_value :=  pnorm((logsum - numReads*use_mu)/sqrt(numReads*use_var))]\n\n    junctionPredictions[ (numReads>n.thresh.exact) , p_value_2 :=  pnorm((logsum_2 - numReads*use_mu)/sqrt(numReads*use_var))]\n\n    ## make empirical distribution of posteriors:\n\n    print (\"exact calculation through sampling 10K p predicted\")\n    my.dist=list(n.thresh.exact)\n    for ( tempN in 1:n.thresh.exact){ #### get distributions to convolve in next loop\n        n.sampled=1000 # used to compute the null distribution of posteriors\n        my.dist[[tempN]]=sample(lognull, n.sampled, replace=T)\n    }\n\n    for ( tempN in 1:n.thresh.exact){ ## use this loop to assign jncts w/ tempN\n        sim.readps=my.dist[[1]]\n        if (tempN>1){\n            for (tj in 2: tempN){ # loop, taking products\n            sim.readps=my.dist[[tj]] +  sim.readps\n        }\n    }\n    # convert to posterior\n    ## fraction of time p_predicted is smaller than -- so if p_predicted is very large, the fraction of time it is smaller is big\n    ## use the null to compute p_vals\n    #print (head(junctionPredictions))\n    #print (paste(tempN, \"is value of readcount for exact calculation and length of sim reads is \",length(sim.readps)))\n\n    junctionPredictions [ (numReads == tempN ), p_value:= sum( exp(sim.readps)<p_predicted)/length(sim.readps),by=junction]\n\n    #print (\"if below table is not empty, ERROR\")\n    #print (junctionPredictions[p_value>1])\n\n\n    junctionPredictions [ (numReads == tempN ), p_value_2:= sum( exp(sim.readps)<p_predicted_2)/length(sim.readps), by=junction]\n\n    }\n    return(junctionPredictions)\n}\n###########################################################################################\n###########################################################################################\n###########################################################################################\n###########################################################################################\n######## END FUNCTIONS, BEGIN WORK #########\n\n## command line inputs\nuser.input=0\n\nno.indel.classfile=0\n\nif (user.input==0){\n    args = commandArgs(trailingOnly = TRUE)\n    fusion_class_input=args[1]\n    class_input=args[2]\n    srr= args[3]\n    output_dir=args[4]\n    reg_indel_class_input = args[5]\n    FJ_indel_class_input = args[6]\n    print (paste(\"outputdir\", output_dir))\n    ## should be:\n    #FJ_indel_class_input = paste(parentdir,srr,\"_output_FJIndels.txt\",sep=\"\")\n    #reg_indel_class_input = paste(parentdir,srr,\"_output_RegIndel.txt\",sep=\"\")\n}\n\nmax.iter=2 ## iterations for glm\nfactor = 1\n\nif (user.input==1){\n output_dir=\"\"}\n\nuse.indels=1\nuse.fusion=1\n\n## define output class files\nglm_out = paste(output_dir,srr,\"_DATAOUT\",sep=\"\")\nanomaly_glm_out = paste(output_dir,srr,\"_AnomalyDATAOUT\",sep=\"\")\n\nindel_glm_out = paste(output_dir,srr,\"_IndelDATAOUT_SPORK\",sep=\"\")\nlinear_juncp_out = paste(output_dir,srr,\"_LINEARJUNCP_OUT_SPORK\",sep=\"\")\ncirc_juncp_out = paste(output_dir,srr,\"_CIRC_JUNCP_OUT_SPORK\",sep=\"\")\nfusion_juncp_out = paste(output_dir,srr,\"_FUSION_JUNCP_OUT_SPORK\",sep=\"\")\nlinearwanomaly_juncp_out = paste(output_dir,srr,\"_LINEAR_W_ANOMALY_JUNCP_OUT_SPORK\",sep=\"\")\nfusionwanomaly_juncp_out= paste(output_dir,srr,\"_FUSION_W_ANOM_JUNCPOUT_SPORK\", sep=\"\")\nfusionwanomaly_and_indel_juncp_out= paste(output_dir,srr,\"_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_SPORK\", sep=\"\")\n####### CURRENT GOAL IS TO UPDATE LINEAR pvalues w/ anomaly reads\nlinear_juncp_update_out = paste(output_dir,srr,\"_LINEARJUNCP_UPDATED_OUT_SPORK\",sep=\"\")\n##### SINK THE SUMMARY OF THIS SCRIPT\nprint (paste(\"OUtput dir\", fusionwanomaly_and_indel_juncp_out))\n#sink(paste(output_dir,srr,\"_glmInformation_\",sep=\"\"))\n\n### DONE W/ LOOP\n\n\nmy.names=\"none\" ## this is bc Gillians fields are not names like Lindas are\nmyClasses = processClassInput(class_input, my.names)\n\nif (use.fusion==1){\n    print (paste(\"using \", fusion_class_input))\n    myClassesFusion = processClassInput(fusion_class_input,names(myClasses))\n}\nif (use.indels==1){\n    print (paste(\"using \", reg_indel_class_input,\" and \" , FJ_indel_class_input))\n    myClassesRegIndel = processClassInput(reg_indel_class_input,names(myClasses))\n    myClassesFJIndel = processClassInput(FJ_indel_class_input,names(myClasses))\n}\n\nprint(paste(\"class info processed\", dim(myClasses)))\n\ncirc_reads = myClasses[(tolower(class) %like% 'circ'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\ncirc_reads = addDerivedFields(circ_reads, 1)\ncirc_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished circ_reads\")\n\ndecoy_reads = myClasses[(tolower(class) %like% 'decoy'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\ndecoy_reads = addDerivedFields(decoy_reads, 0)\ndecoy_reads [, is.anomaly:=1] ######## this IS an anomaly type\n\nprint (\"finished decoy_reads\")\n## was\nlinear_reads = myClasses[(tolower(class) %like% 'linear'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\nlinear_reads = addDerivedFields(linear_reads, 1)\nlinear_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished linear_reads\")\n\nanomaly_reads = myClasses[(tolower(class) %like% 'anomaly'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\nanomaly_reads [, is.anomaly:=1]\nprint (\"finished anomaly_reads\")\n\nif (use.indels==1){\n    ## in analogy, we first define all indels, then assign good and bad\n    ## we will use anomaly field as a general term for 'anomaly mapping and indel'\n    reg_indel_reads = myClassesRegIndel[, list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\n    reg_indel_reads [, is.anomaly:=1]\n    print (\"Finished reg indels\")\n\n    compatible_indel_reads = myClassesRegIndel[(tolower(class) %like% 'good'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\n    compatible_indel_reads [, is.anomaly:=1]\n\n    incompatible_indel_reads = myClassesRegIndel[(tolower(class) %like% 'bad'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\n    incompatible_indel_reads [, is.anomaly:=1]\n\n    FJ_indel_reads = myClassesFJIndel[, list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]\n    FJ_indel_reads [, is.anomaly:=1]\n\n    if (dim(FJ_indel_reads)[1]==0){\n        no.indel.classfile = 1\n    } else{\n        FJ_indel_reads = addDerivedFields(FJ_indel_reads, 1)\n\n    }\n\n}\n\nif (use.fusion==1){\n\n    #was na.omit\n    fusion_reads = (myClassesFusion[(tolower(class) %like% 'fjgood'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),])\n    fusion_reads = addDerivedFields(fusion_reads, 1)\n    fusion_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\n    print (\"ANOMALY fusions defined as FJ bad-- of any variety\")\n    anomaly_fusion_reads = (myClassesFusion[(tolower(class) %like% 'fjbad'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand, junctionR2),]) # GILLIAN, pls comment here on what FJ bad is for the sake of documentation\n\n    anomaly_fusion_reads = addDerivedFields(anomaly_fusion_reads, 1)\n    anomaly_fusion_reads [, is.anomaly:=1] ## this is not an anomaly type so WILL NOT have p value ajustment\n}\n###############################################################################################\n## CANNOT ADD DERIVED FIELDS HERE BECAUSE WE DON'T KNOW WHICH ANOMALIES ARE GOOD AND/OR BAD\n##################### DERIVED FIELDS ADDED LATER ##############################################\n###############################################################################################\n\n# set up data structure to hold per-junction predictions\njunctionPredictions = linear_reads[, .N, by = junction] # get number of reads per junction\nsetnames(junctionPredictions, \"N\", \"numReads\")\nsetkey(junctionPredictions, junction)\n\n#### TRAIN EM ####\n## this should be a function of any two classes; and the output will be the model\n\n##\n\nn.row= dim(linear_reads)[1]\nn.sample=min(n.row,10000)\n\n#syntax example decoy_reads[,p_predicted:=NULL]\nprint (\"calling linear decoy model\")\nlinearDecoyGLMoutput = my.glm.model (6, linear_reads[ sample(n.row,n.sample,replace=FALSE),], decoy_reads, 1, max.iter, factor) ## 0 does not use R2 info\n\nsaves = linearDecoyGLMoutput[[1]]\nlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\n#save(saves, file=glm_out)  # save models\nlinearDecoyGLM = saves[[max.iter]] ##### this is the glm model\n\n## after fitting the GLM to linear vs. decoy, we want to store linear junction predictions in order to subset anomalies\n######## JS ADDITION: NOTE- NOT stratifying on permutation p value, although could add this too\n\n\n############################################################################\n### START LINEARS\n################# predict on anomaly reads -- AND TEST HOW THIS IMPACTS LINEAR PREDICTIONS\n############################ linear predictions ONLY ON THE BASIS of anomalies...\n\npreds = predict(linearDecoyGLM, newdata=linear_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\nlinear_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\nlinear_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n## for null\nprint (\"Assigning null distribution for all linear reads\")\nnull=linear_reads$p_predicted\n\n### ASSIGN p value:\nlinearJunctionPredictionsForModels = predictNewClassP(linear_reads, null)\n\npGoodThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.8,na.rm=TRUE)\ngood.linear=linearJunctionPredictionsForModels[p_value> pGoodThresh,]\n\npBadThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.2,na.rm=TRUE)\nbad.linear=linearJunctionPredictionsForModels[p_value< pBadThresh,]\n#####################################\n\n\n############## done with linears\n\n# define two classes of anomalies: those from good vs. bad junctions\n\n\ngood_anomaly_reads= anomaly_reads[!is.na(match(junction, good.linear$junction)),]\nbad_anomaly_reads= anomaly_reads[!is.na(match(junction, bad.linear$junction)),]\n## NOW add derived fields\n\nif (use.indels==1){\n    # define two classes of regular INDELS for training: those from good vs. bad junctions\n\n    good_indel_reads= compatible_indel_reads[!is.na(match(junction, good.linear$junction)),]\n    bad_indel_reads= incompatible_indel_reads[!is.na(match(junction, bad.linear$junction)),]\n\n    ## if either class is empty, change use.indels to zero\n    if (min(dim(good_indel_reads)[1],dim(bad_indel_reads)[1])<20){\n        print (\"CHANGING TO INDELS=0 becuase too few reads\")\n        use.indels=0\n    }\n\n\n}\n\n##### now, re-run script training on anomalies from good vs. bad\n\nuse.anomaly = 1\n\nif (dim(good_anomaly_reads)[1]==0 & dim(bad_anomaly_reads)[1]==0){\n    use.anomaly = 0\n}\n\nif (min(dim(good_anomaly_reads)[1], dim(bad_anomaly_reads)[1]) > 0){\n    ## The \"1\" belowneeds to be 0 and 1 for good and bad anomalies\n    good_anomaly_reads = addDerivedFields(good_anomaly_reads, 1) ####\n    bad_anomaly_reads = addDerivedFields(bad_anomaly_reads, 0) ####\n    all_anomaly_reads=rbind(good_anomaly_reads,bad_anomaly_reads)\n\n    ######## now, RECALL GLM  FOR ANOMALY READ MAPPERS\n    print (\"calling good anomaly bad anomaly model with .8 and .2 as thresholds\")\n    AnomInfo = my.glm.model (6, good_anomaly_reads, bad_anomaly_reads,1, max.iter, factor) ## JS these are the outputs and done with function\n    ANOMALYsaves=AnomInfo[[1]]\n    ANOMALYjunctionPredictions=AnomInfo[[2]]\n    AnomalyGLM = ANOMALYsaves[[max.iter]] ##### this is the glm model\n\n    preds = predict(AnomalyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n    all_anomaly_reads[, p_predicted:= AnomalyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    all_anomaly_reads[, p_predicted_2:= AnomalyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    use.anomaly = 2\n\n} else{\n    if(dim(good_anomaly_reads)[1]>0){\n        all_anomaly_reads = addDerivedFields(good_anomaly_reads, 1)\n\n        preds = predict(linearDecoyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n\n        lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n        lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n        all_anomaly_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n        all_anomaly_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n    }\n    if(dim(bad_anomaly_reads)[1]>0){\n        all_anomaly_reads = addDerivedFields(bad_anomaly_reads, 1)\n\n        preds = predict(linearDecoyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n\n        lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n        lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n        all_anomaly_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n        all_anomaly_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n    }\n}\n\n## in anaolgy, same for INDELS\nif (use.indels==1){\n    good_indel_reads = addDerivedFields(good_indel_reads, 1) ####\n    bad_indel_reads = addDerivedFields(bad_indel_reads, 0) ####\n    all_indel_reads=rbind(good_indel_reads,bad_indel_reads)\n}\n\nif (use.indels==1){\n    print (\"calling INDEL model with .8 and .2 as thresholds\")\n    IndelInfo = my.glm.model (1, good_indel_reads, bad_indel_reads,1, max.iter, factor) ## JS these are the outputs and done with function\n    INDELsaves=IndelInfo[[1]]\n    INDELjunctionPredictions=IndelInfo[[2]]\n    IndelGLM = INDELsaves[[max.iter]] ##### this is the glm model\n}\nif (use.indels==0){\n    print (\"USING GLM MODEL for INDEL MODEL\")\n    INDELsaves = linearDecoyGLMoutput[[1]]\n    INDELlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\n    IndelGLM = linearDecoyGLM\n}\n\n## save GLMS\n#save(AnomalyGLM, file=anomaly_glm_out)  # save models\nif (use.indels==1){\n    save(IndelGLM, file=indel_glm_out)  # save models\n}\n#save(linearDecoyGLM, file=glm_out)  # save models\n\npreds = predict(linearDecoyGLM, newdata=decoy_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\nlwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\ndecoy_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ndecoy_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n\n## need to rbind anomaly junctions\nif (use.anomaly != 0){\n    linear_and_anomaly=rbind(all_anomaly_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], linear_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n} else{\n    linear_and_anomaly = linear_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)]\n}\n\n\nlinearWithAnomalyJunctionPredictions = predictNewClassP(linear_and_anomaly, null)\n\n################# DONE WITH LINEARS\n#########################################################################\n\n#### PREDICT CIRCULAR JUNCTIONS #### SHOULD MAKE THIS MODULAR AND A FUNCTION so Farjunction and Anomalies can be used\n## SIMPLE PREDICT ON CIRCLES\npreds = predict(linearDecoyGLM, newdata=circ_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\ncirc_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ncirc_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\ncircularJunctionPredictions = predictNewClassP(circ_reads, null)\n\n#########################################################################\n## start fusions ############################################################################\n############################################################################\n################# NOTE: Here, we are only using fusion reads not fusion anomaly reads and treating the prediction just like circle\n############################################################################\n############################################################################\n## start prediction on good far junctions\n\nif (use.fusion==1){\n    fusion_reads$overlap=as.numeric(as.vector(fusion_reads$overlap))\n    preds = predict(linearDecoyGLM, newdata=fusion_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n    lwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\n    fusion_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    fusion_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    fusionJunctionPredictions = predictNewClassP( fusion_reads, null)\n\n\n    if(use.anomaly == 2){\n        # start prediction on BAD=Anomaly mapping\n        print (\"done with fusion normals, starting anomalies\")\n\n        preds = predict(AnomalyGLM, newdata=anomaly_fusion_reads, type = \"link\", se.fit = TRUE)\n        lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n        lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n        anomaly_fusion_reads[, p_predicted:= AnomalyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n        anomaly_fusion_reads[, p_predicted_2:= AnomalyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n        linear_and_anomaly_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n        linear_and_anomaly_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_fusions$overlap))\n        linearWithAnomalyFusionPredictions = predictNewClassP(linear_and_anomaly_fusions, null)\n\n        # start prediction on INDELS mapping\n        print (\"done with fusion anomalies starting indels\")\n    } else{\n        preds = predict(linearDecoyGLM, newdata=anomaly_fusion_reads, type = \"link\", se.fit = TRUE)\n        lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n        lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n\n        anomaly_fusion_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n        anomaly_fusion_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n        linear_and_anomaly_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n        linear_and_anomaly_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_fusions$overlap))\n        linearWithAnomalyFusionPredictions = predictNewClassP(linear_and_anomaly_fusions, null)\n    }\n}\n\nif (use.indels==1 & no.indel.classfile==0){\n    FJ_indel_reads$overlap=as.numeric(as.vector(FJ_indel_reads$overlap))\n    preds = predict(IndelGLM, newdata=FJ_indel_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\n    FJ_indel_reads[, p_predicted:= IndelGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    FJ_indel_reads[, p_predicted_2:= IndelGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n    linear_and_anomaly_and_indel_fusions=rbind(FJ_indel_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)],anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n}\n\n\n\nif (use.indels==0 & no.indel.classfile==0){\n    ## if not using indels, we assign indel reads according to the linear decoy model\n    preds = predict(linearDecoyGLM, newdata=FJ_indel_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n    FJ_indel_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    FJ_indel_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n    linear_and_anomaly_and_indel_fusions=rbind(FJ_indel_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)],anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n\n}\n\nif (no.indel.classfile==1){\n    linear_and_anomaly_and_indel_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n\n}\n\nlinear_and_anomaly_and_indel_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_and_indel_fusions$overlap))\nlinearWithAnomalyAndIndelFusionPredictions = predictNewClassP(linear_and_anomaly_and_indel_fusions, null)\n\nconsolidated_fusion=merge(fusionJunctionPredictions,linearWithAnomalyFusionPredictions , all=TRUE,by=\"junction\")\nconsolidated_fusion[,p_diff:=(p_predicted.x-p_predicted.y)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\nconsolidated_fusion=data.table(unique(consolidated_fusion))\n\n####### now add indels\n#verbose adds extra output and extra info to indel table\nverbose=0\n\nprint (\"now adding indels and changing names to reflect accurate terminology\")\nconsolidated_fusion_windel=merge(linearWithAnomalyFusionPredictions ,linearWithAnomalyAndIndelFusionPredictions, all=TRUE,by=\"junction\")\nconsolidated_fusion_windel[,p_diff_indel:=(p_predicted.y-p_predicted.x)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\nconsolidated_fusion_windel=data.table(unique(consolidated_fusion_windel))\n\nsetnames(consolidated_fusion_windel,\"p_predicted.x\", \"productPhat.x\")\nsetnames(consolidated_fusion_windel,\"p_predicted.y\", \"productPhat.y\")\nsetnames(consolidated_fusion_windel,\"p_value.x\", \"junction_cdf.x\")\nsetnames(consolidated_fusion_windel,\"p_value.y\", \"junction_cdf.y\")\n\n\nsetnames(consolidated_fusion_windel,\"p_predicted_2.x\", \"productPhat_lower.x\")\nsetnames(consolidated_fusion_windel,\"p_predicted_2.y\", \"productPhat_lower.y\")\nsetnames(consolidated_fusion_windel,\"p_value_2.x\", \"junction_cdf_lower.x\")\nsetnames(consolidated_fusion_windel,\"p_value_2.y\", \"junction_cdf_lower.y\")\n\nsetnames(consolidated_fusion_windel,\"p_diff_indel\", \"junction_cdf_windel_diff\")\nif (verbose==0){\n    consolidated_fusion_windel[,q_1.y:=NULL]\n    consolidated_fusion_windel[,q_2.y:=NULL]\n    consolidated_fusion_windel[,q_1.x:=NULL]\n    consolidated_fusion_windel[,q_2.x:=NULL]\n    consolidated_fusion_windel[,logsum.x:=NULL]\n    consolidated_fusion_windel[,logsum.y:=NULL]\n}\n\n## fusion_reads merging\n## JS ADD 8/14\nfusion_reads[strand!=0,maxNegStrandOverlap:=max(overlap),by=junction]\nfusion_reads[strand==0,maxPosStrandOverlap:=max(overlap),by=junction]\nout_fusions=merge(merge(consolidated_fusion_windel, unique(fusion_reads[strand==0,list(junction,maxPosStrandOverlap)]),by=\"junction\",add.x=TRUE), unique(fusion_reads[strand!=0,list(junction,maxNegStrandOverlap)]),by=\"junction\",add.x=TRUE)\n\nout_fusions_left_joint=merge(merge(consolidated_fusion_windel, unique(fusion_reads[strand==0,list(junction,maxPosStrandOverlap)]),by=\"junction\",all.x=TRUE), unique(fusion_reads[strand!=0,list(junction,maxNegStrandOverlap)]),by=\"junction\",all.x=TRUE)\n\nfusionwanomaly_and_indel_juncp_out_left_joint= paste(output_dir,srr,\"_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_SPORK_LEFT_JOIN\", sep=\"\")\n\nwrite.table(unique(out_fusions)[order(-junction_cdf.y),], fusionwanomaly_and_indel_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\nwrite.table(unique(out_fusions_left_joint)[order(-junction_cdf.y),], fusionwanomaly_and_indel_juncp_out_left_joint, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\ncir.verbose=0\n####################################################################################\n####################################################################################\nif (cir.verbose==1){\n    ## write circle prediction\n\n    setnames(circularJunctionPredictions,\"p_predicted\", \"productPhat.x\")\n    setnames(circularJunctionPredictions,\"p_predicted_2\", \"productPhat_lower.x\")\n    setnames(circularJunctionPredictions,\"p_value_2\", \"junction_cdf_lower.x\")\n    setnames(circularJunctionPredictions,\"p_value\", \"junction_cdf\")\n\n    write.table(unique(linearJunctionPredictions), linear_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n    write.table(unique(circularJunctionPredictions), circ_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\n    ## with anomalies, p value should be smaller so p_diff should always be negative...\n    consolidated_linear=merge(linearWithAnomalyJunctionPredictions,linearJunctionPredictions,by=\"junction\",all=TRUE)\n    consolidated_linear[,p_diff:=(p_predicted.x-p_predicted.y)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\n    consolidated_linear=data.table(unique(consolidated_linear))\n    write.table(unique(consolidated_linear), linearwanomaly_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\n    ##\n    my.null.quantiles=quantile(linear_reads$p_predicted,probs=c(0:10)/10,na.rm=TRUE)\n    ## refer fusions to these quantiles; 'falsely called' vs. true will be fraction of linears (conservative estimate) ; error at this quantile can be evaluated.\n\n    write.table(unique(fusionJunctionPredictions[order(-p_predicted),]),fusion_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n    write.table(unique(consolidated_fusion)[order(-p_predicted.y),], fusionwanomaly_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\n}",
                "filename": "GLM_script_UseIndel_SPORK.r"
              }
            ],
            "class": "CreateFileRequirement"
          },
          {
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#reg_indel_class_input",
            "inputBinding": {
              "separate": true,
              "position": 5,
              "sbg:cmdInclude": true
            },
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_class_input",
            "inputBinding": {
              "separate": true,
              "position": 1,
              "sbg:cmdInclude": true
            },
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#class_input",
            "inputBinding": {
              "separate": true,
              "position": 2,
              "sbg:cmdInclude": true
            },
            "required": false
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#FJ_indel_class_input",
            "inputBinding": {
              "separate": true,
              "loadContents": true,
              "position": 6,
              "sbg:cmdInclude": true
            },
            "required": false
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_LINEAR_W_ANOMALY_JUNCP_OUT_SPORK"
            },
            "id": "#linear_w_anomaly_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_LINEARJUNCP_UPDATED_OUT_SPORK"
            },
            "id": "#linear_juncp_updated_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_LINEARJUNCP_OUT_SPORK"
            },
            "id": "#linear_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_IndelDATAOUT_SPORK"
            },
            "id": "#indel_data_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_JUNCPOUT_SPORK"
            },
            "id": "#fusion_w_anomaly_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_SPORK_LEFT_JOIN"
            },
            "id": "#fusion_w_anomaly_and_indel_juncp_out_lef_join",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_SPORK"
            },
            "id": "#fusion_w_anomaly_and_indel_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_JUNCP_OUT_SPORK"
            },
            "id": "#fusion_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#class_input",
              "glob": "*_DATAOUT_SPORK"
            },
            "id": "#data_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_CIRC_JUNCP_OUT_SPORK"
            },
            "id": "#circ_juncp_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "glob": "*_AnomalyDATAOUT_SPORK"
            },
            "id": "#anomaly_data_out",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/machete_glm:r"
          }
        ],
        "baseCommand": [
          "chmod",
          "+x",
          "GLM_script_UseIndel_SPORK.r",
          "&&",
          "Rscript",
          "GLM_script_UseIndel_SPORK.r"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "position": 3,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.FJ_indel_class_input.metadata && $job.inputs.FJ_indel_class_input.metadata.sample_id)\n    \tcmd = $job.inputs.FJ_indel_class_input.metadata.sample_id\n\treturn cmd\n}\n",
              "class": "Expression"
            }
          },
          {
            "separate": true,
            "position": 4,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "script": "{\n\treturn \"./\"\n}",
              "class": "Expression"
            }
          }
        ],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fusion_class_input": {
              "class": "File",
              "size": 0,
              "path": "/path/to/fusion_class_input.ext",
              "secondaryFiles": []
            },
            "reg_indel_class_input": {
              "class": "File",
              "size": 0,
              "path": "/path/to/reg_indel_class_input.ext",
              "secondaryFiles": []
            },
            "FJ_indel_class_input": {
              "metadata": {
                "sample_id": "sample_name"
              },
              "class": "File",
              "size": 0,
              "path": "/path/to/FJ_indel_class_input.ext",
              "secondaryFiles": []
            },
            "class_input": {
              "metadata": {
                "sample_id": "sample_name"
              },
              "class": "File",
              "size": 0,
              "path": "/path/to/class_input.ext",
              "secondaryFiles": []
            }
          }
        },
        "sbg:cmdPreview": "chmod +x GLM_script_UseIndel_SPORK.r && Rscript GLM_script_UseIndel_SPORK.r  sample_name  ./",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:image_url": null,
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434169,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434188,
            "sbg:revisionNotes": "revision 7 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529581779,
            "sbg:revisionNotes": "which_formula added"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529584415,
            "sbg:revisionNotes": "Formula 4 for linear_decoy and anomaly"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529585800,
            "sbg:revisionNotes": "which_formula = 5"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529587381,
            "sbg:revisionNotes": "which_formula = 6"
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529835223,
            "sbg:revisionNotes": "FJ_indel_reads junctionR2 added"
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529850688,
            "sbg:revisionNotes": "use.anomaly = 0"
          },
          {
            "sbg:revision": 8,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529852885,
            "sbg:revisionNotes": "predict on all anomaly reads"
          },
          {
            "sbg:revision": 9,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529854691,
            "sbg:revisionNotes": "use.anomaly = 0 for real"
          },
          {
            "sbg:revision": 10,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529855432,
            "sbg:revisionNotes": "use.anomaly = 0 for real"
          },
          {
            "sbg:revision": 11,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529856579,
            "sbg:revisionNotes": "use.anomaly = 0 fixed"
          },
          {
            "sbg:revision": 12,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529877961,
            "sbg:revisionNotes": "back to revision 6"
          },
          {
            "sbg:revision": 13,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531043197,
            "sbg:revisionNotes": "is.anomaly:=0"
          },
          {
            "sbg:revision": 14,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531135017,
            "sbg:revisionNotes": "factor = 0.5 added"
          },
          {
            "sbg:revision": 15,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531139651,
            "sbg:revisionNotes": "factor = 1"
          },
          {
            "sbg:revision": 16,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531147269,
            "sbg:revisionNotes": "factor = 2"
          },
          {
            "sbg:revision": 17,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531178381,
            "sbg:revisionNotes": "factor = 1"
          },
          {
            "sbg:revision": 18,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536954135,
            "sbg:revisionNotes": "qual feature removed"
          },
          {
            "sbg:revision": 19,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536960993,
            "sbg:revisionNotes": "IndelGLM formula 6"
          },
          {
            "sbg:revision": 20,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536961128,
            "sbg:revisionNotes": "qual feature added and IndelGLM formula 6"
          },
          {
            "sbg:revision": 21,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537004214,
            "sbg:revisionNotes": "factor = 2"
          },
          {
            "sbg:revision": 22,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537004298,
            "sbg:revisionNotes": "factor = 0.5"
          },
          {
            "sbg:revision": 23,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537132794,
            "sbg:revisionNotes": "which_formula = 1, factor = 1"
          },
          {
            "sbg:revision": 24,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537136627,
            "sbg:revisionNotes": "which_formula = 2"
          },
          {
            "sbg:revision": 25,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537223713,
            "sbg:revisionNotes": "which_formula = 6, use.indels = 0"
          },
          {
            "sbg:revision": 26,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537226660,
            "sbg:revisionNotes": "use.indels = 2"
          },
          {
            "sbg:revision": 27,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537310058,
            "sbg:revisionNotes": "use.anomaly = 0"
          },
          {
            "sbg:revision": 28,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537481840,
            "sbg:revisionNotes": "back to rev 22"
          },
          {
            "sbg:revision": 29,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537562744,
            "sbg:revisionNotes": "back to rev 21"
          },
          {
            "sbg:revision": 30,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537606329,
            "sbg:revisionNotes": "rev: 22 + factor = 0.1"
          },
          {
            "sbg:revision": 31,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537654439,
            "sbg:revisionNotes": "factor = 1, logsum=+ 1*is.anomaly"
          },
          {
            "sbg:revision": 32,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1543711662,
            "sbg:revisionNotes": "rev17 + anomaly instead of decoy reads"
          },
          {
            "sbg:revision": 33,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550787385,
            "sbg:revisionNotes": "back to revision 17"
          },
          {
            "sbg:revision": 34,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550963560,
            "sbg:revisionNotes": "uniformity_pvalue added"
          },
          {
            "sbg:revision": 35,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550977566,
            "sbg:revisionNotes": "back to 33"
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/glm-script-useindel-spork/35",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/glm-script-useindel-spork/35",
        "sbg:revision": 35,
        "sbg:revisionNotes": "back to 33",
        "sbg:modifiedOn": 1550977566,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520434169,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos",
          "milos_jordanski"
        ],
        "sbg:latestRevision": 35,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ada534f673323d2ed2d5eb8cb788d024e617a7dbf77690feeadbc07fd1d7f2179",
        "x": 6242.339441418884,
        "y": -93.98455153509839
      },
      "inputs": [
        {
          "id": "#SPORK_GLM_script_UseIndel.reg_indel_class_input",
          "source": [
            "#SPORK_RegIndels_filter_glm_class_file.filtered_output"
          ]
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.fusion_class_input",
          "source": [
            "#SPORK_FarJunc_filter_glm_class_file.filtered_output"
          ]
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.class_input",
          "source": [
            "#KNIFE_filterFDR.output"
          ]
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.FJ_indel_class_input",
          "source": [
            "#SPORK_FJIndels_filter_glm_class_file.filtered_output"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_GLM_script_UseIndel.linear_w_anomaly_juncp_out"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.linear_juncp_updated_out"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.linear_juncp_out"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.indel_data_out"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.fusion_w_anomaly_juncp_out"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.fusion_w_anomaly_and_indel_juncp_out_lef_join"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.fusion_w_anomaly_and_indel_juncp_out"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.fusion_juncp_out"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.data_out"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.circ_juncp_out"
        },
        {
          "id": "#SPORK_GLM_script_UseIndel.anomaly_data_out"
        }
      ],
      "sbg:x": 6242.339441418884,
      "sbg:y": -93.98455153509839
    },
    {
      "id": "#SPORK_uniformity_pvalue",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK_uniformity_pvalue",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "SPORK_uniformity_pvalue.R",
                "fileContent": "library(data.table)\n\nuniformity_test_no_sim <- function(dt, min_R1_offset,max_R1_offset) {\n  possible_values = data.frame(vals = min_R1_offset:max_R1_offset)\n  t=data.frame(table(dt))\n  possible_values = merge(possible_values,t,by.x = \"vals\",by.y = \"dt\",all.x = TRUE,all.y = FALSE)\n  possible_values = data.table(possible_values)\n  possible_values[is.na(Freq)]$Freq = 0\n  #test = chisq.test(possible_values$Freq,simulate.p.value = TRUE)\n  test = chisq.test(possible_values$Freq)\n  return(test$p.value)\n}\n\n\nuniformity_test <- function(dt, min_R1_offset,max_R1_offset) {\n  possible_values = data.frame(vals = min_R1_offset:max_R1_offset)\n  t=data.frame(table(dt))\n  possible_values = merge(possible_values,t,by.x = \"vals\",by.y = \"dt\",all.x = TRUE,all.y = FALSE)\n  possible_values = data.table(possible_values)\n  possible_values[is.na(Freq)]$Freq = 0\n  test = chisq.test(possible_values$Freq,simulate.p.value = TRUE)\n  #test = chisq.test(possible_values$Freq)\n  return(test$p.value)\n}\n\n\nargs = commandArgs(trailingOnly = TRUE)\n\nclass_input_file=args[1]\nsrr= args[2]\n\nclass_input = fread(class_input_file,sep=\"\\t\",header = TRUE)\nmin_R1_offset = min(class_input$R1_offset)\nmax_R1_offset = max(class_input$R1_offset)\n\nclass_input[,`:=`(class=NULL, R1_MAPQ=NULL, R1_adjAS=NULL, R1_NumN=NULL, R1_Readlength=NULL, R1_strand=NULL, R2_offset=NULL, R2_MAPQ=NULL, R2_adjAS=NULL, R2_NumN=NULL, R2_Readlength=NULL, R2_JuncName=NULL, R2_strand=NULL)]\n\n#class_input[,uniformity_test_pval:=uniformity_test(R1_offset,min_R1_offset,max_R1_offset),by = R1_JuncName]\nclass_input[,uniformity_test_pval_no_sim:=uniformity_test_no_sim(R1_offset,min_R1_offset,max_R1_offset),by = R1_JuncName]\n\nclass_input[,`:=`(ID=NULL, R1_offset=NULL)]\n\n\noutput_name = paste(srr,\"_uniformity_p_value.txt\",sep=\"\")\nwrite.table(unique(class_input), output_name, row.names=FALSE, quote=FALSE, sep=\"\\t\")"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#class_input",
            "required": false
          }
        ],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_uniformity_p_value.txt",
              "sbg:inheritMetadataFrom": "#class_input"
            },
            "id": "#output_file"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/machete_glm:r"
          }
        ],
        "baseCommand": [
          "chmod",
          "+x",
          "SPORK_uniformity_pvalue.R",
          "&&",
          "Rscript",
          "SPORK_uniformity_pvalue.R"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.class_input.metadata && $job.inputs.class_input.metadata.sample_id)\n    \tcmd = $job.inputs.class_input.metadata.sample_id\n\treturn cmd\n}\n"
            },
            "position": 10
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550977227,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550977699,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550978062,
            "sbg:revisionNotes": "chmod +x"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550978909,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550985450,
            "sbg:revisionNotes": "only no_sim"
          }
        ],
        "sbg:image_url": null,
        "sbg:job": {
          "inputs": {
            "class_input": {
              "path": "/path/to/class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "SAMPLE"
              }
            }
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "sbg:cmdPreview": "chmod +x SPORK_uniformity_pvalue.R && Rscript SPORK_uniformity_pvalue.R  SAMPLE",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/spork-uniformity-pvalue/4",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/spork-uniformity-pvalue/4",
        "sbg:revision": 4,
        "sbg:revisionNotes": "only no_sim",
        "sbg:modifiedOn": 1550985450,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1550977227,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 4,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a8fd2122f828e1ee44671fecdaf5b2e31587f2b1b1fde2cf58de0d8714e904e01",
        "x": 6181.667881250424,
        "y": 203.33340766695085
      },
      "inputs": [
        {
          "id": "#SPORK_uniformity_pvalue.class_input",
          "source": [
            "#SPORK_FarJuncNaiveReport.IDs"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_uniformity_pvalue.output_file"
        }
      ],
      "sbg:x": 6181.667881250424,
      "sbg:y": 203.33340766695085
    },
    {
      "id": "#SPORK_uniformity_pvalue_filtered",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK_uniformity_pvalue_filtered",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "SPORK_uniformity_pvalue.R",
                "fileContent": "library(data.table)\n\nuniformity_test_no_sim <- function(dt, min_R1_offset,max_R1_offset) {\n  possible_values = data.frame(vals = min_R1_offset:max_R1_offset)\n  t=data.frame(table(dt))\n  possible_values = merge(possible_values,t,by.x = \"vals\",by.y = \"dt\",all.x = TRUE,all.y = FALSE)\n  possible_values = data.table(possible_values)\n  possible_values[is.na(Freq)]$Freq = 0\n  #test = chisq.test(possible_values$Freq,simulate.p.value = TRUE)\n  test = chisq.test(possible_values$Freq)\n  return(test$p.value)\n}\n\n\nuniformity_test <- function(dt, min_R1_offset,max_R1_offset) {\n  possible_values = data.frame(vals = min_R1_offset:max_R1_offset)\n  t=data.frame(table(dt))\n  possible_values = merge(possible_values,t,by.x = \"vals\",by.y = \"dt\",all.x = TRUE,all.y = FALSE)\n  possible_values = data.table(possible_values)\n  possible_values[is.na(Freq)]$Freq = 0\n  test = chisq.test(possible_values$Freq,simulate.p.value = TRUE)\n  #test = chisq.test(possible_values$Freq)\n  return(test$p.value)\n}\n\n\nargs = commandArgs(trailingOnly = TRUE)\n\nclass_input_file=args[1]\nsrr= args[2]\n\nclass_input = fread(class_input_file,sep=\"\\t\",header = TRUE)\nmin_R1_offset = min(class_input$R1_offset)\nmax_R1_offset = max(class_input$R1_offset)\n\nclass_input[,`:=`(class=NULL, R1_MAPQ=NULL, R1_adjAS=NULL, R1_NumN=NULL, R1_Readlength=NULL, R1_strand=NULL, R2_offset=NULL, R2_MAPQ=NULL, R2_adjAS=NULL, R2_NumN=NULL, R2_Readlength=NULL, R2_JuncName=NULL, R2_strand=NULL)]\n\n#class_input[,uniformity_test_pval:=uniformity_test(R1_offset,min_R1_offset,max_R1_offset),by = R1_JuncName]\nclass_input[,uniformity_test_pval_no_sim:=uniformity_test_no_sim(R1_offset,min_R1_offset,max_R1_offset),by = R1_JuncName]\n\nclass_input[,`:=`(ID=NULL, R1_offset=NULL)]\n\n\noutput_name = paste(srr,\"_uniformity_p_value.txt\",sep=\"\")\nwrite.table(unique(class_input), output_name, row.names=FALSE, quote=FALSE, sep=\"\\t\")"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#class_input",
            "required": false
          }
        ],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_uniformity_p_value.txt",
              "sbg:inheritMetadataFrom": "#class_input"
            },
            "id": "#output_file"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/machete_glm:r"
          }
        ],
        "baseCommand": [
          "chmod",
          "+x",
          "SPORK_uniformity_pvalue.R",
          "&&",
          "Rscript",
          "SPORK_uniformity_pvalue.R"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.class_input.metadata && $job.inputs.class_input.metadata.sample_id)\n    \tcmd = $job.inputs.class_input.metadata.sample_id\n\treturn cmd\n}\n"
            },
            "position": 10
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550977227,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550977699,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550978062,
            "sbg:revisionNotes": "chmod +x"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550978909,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550985450,
            "sbg:revisionNotes": "only no_sim"
          }
        ],
        "sbg:image_url": null,
        "sbg:job": {
          "inputs": {
            "class_input": {
              "path": "/path/to/class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "SAMPLE"
              }
            }
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "sbg:cmdPreview": "chmod +x SPORK_uniformity_pvalue.R && Rscript SPORK_uniformity_pvalue.R  SAMPLE",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/spork-uniformity-pvalue/4",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/spork-uniformity-pvalue/4",
        "sbg:revision": 4,
        "sbg:revisionNotes": "only no_sim",
        "sbg:modifiedOn": 1550985450,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1550977227,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 4,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a8fd2122f828e1ee44671fecdaf5b2e31587f2b1b1fde2cf58de0d8714e904e01",
        "x": 6053.333415216867,
        "y": -235.00000894069686
      },
      "inputs": [
        {
          "id": "#SPORK_uniformity_pvalue_filtered.class_input",
          "source": [
            "#SPORK_FarJunc_filter_glm_class_file.filtered_output"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_uniformity_pvalue_filtered.output_file"
        }
      ],
      "sbg:x": 6053.333415216867,
      "sbg:y": -235.00000894069686
    },
    {
      "id": "#SPORK_Build_Consensus_Sequences",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK Build Consensus Sequences",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import argparse\nimport pickle\nfrom SPORK_SAMEntry import SAMEntry\nfrom SPORK_BinPair import BinPair\nfrom SPORK_consensus_utils import *\nfrom SPORK_utils import *\nimport multiprocessing\nimport math\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('-fp', '--five_prime', help='5prime sam file', required=True)\nparser.add_argument('-tp', '--three_prime', help='3prime sam file', required=True)\nparser.add_argument('-cf', '--combined_fastq', help='combined fastq file', required=True)\nparser.add_argument('-gmc', '--group_member_cutoff', help='minimum number of reads that need to map to a bin pair', required=True)\nparser.add_argument('-csc', '--consensus_score_cutoff', help='relates to the number of mismatches in consensus', required=True)\nparser.add_argument('-bs', '--bin_size', help='size of bins in bps to split ref into', required=True)\nparser.add_argument('-sff', '--splice_finding_flank', help='how long to make the pieces in splice site identification', required=True)\nparser.add_argument('-fmg', '--fusion_max_gap', help='size of splice site gap to allow for fusions', required=True)\nparser.add_argument('-abc', '--at_boundary_cutoff', help='maximum distance to be away from a boundary for fusion classification', required=True)\nparser.add_argument('-sfl', '--splice_flank_len', help='Flanking length on either side of the junction', required=True)\n\nparser.add_argument('-rnri', '--read_num_to_read_id', help='read number to read id', required=True)\nparser.add_argument('-mbpc', '--min_bases_per_col', help='only consider column if it has at least n bases', required=True)\n\n\nparser.add_argument('-s', '--sample', help='base name used in alignment output files', required=True)\nparser.add_argument('-fl', '--flank_len', help='5\\' and 3\\' flank length to use in SPACHETE, defaults to 25')\nparser.add_argument('-cpu', '--number_of_cpus', help='number of cpus')\n\nargs = parser.parse_args()\n\n\nfive_prime_mapped_name = args.five_prime\nthree_prime_mapped_name = args.three_prime\ncombined_fastq = args.combined_fastq\nread_num_to_read_id = args.read_num_to_read_id\nbin_size = int(args.bin_size)\nflank_len = int(args.flank_len)\ncpu = int(args.number_of_cpus)\n\nconstants_dict = {\"bin_size\": int(args.bin_size),\n                  \"group_member_cutoff\": int(args.group_member_cutoff),\n                  \"consensus_score_cutoff\": float(args.consensus_score_cutoff),\n                  \"min_bases_per_col\": int(args.min_bases_per_col),\n                  \"splice_finding_flank\": int(args.splice_finding_flank),\n                  \"fusion_max_gap\": int(args.fusion_max_gap),\n                  \"at_boundary_cutoff\": int(args.at_boundary_cutoff),\n                  \"splice_flank_len\": int(args.splice_flank_len),\n                  \"flank_len\": flank_len\n                  }\n                  #\"splice_finding_allowed_mismatches\":splice_finding_allowed_mismatches,\n                  #\"unaligned_path\":unaligned_path,\n                  #\"read_gap_score\":read_gap_score,\n                  #\"min_score\":min_score,\n                  #\"thirds_len\":thirds_len,\n                  # \"splice_finding_min_score\":splice_finding_min_score,\n                  #\"splice_finding_allowed_mappings\":splice_finding_allowed_mappings,\n                  #\"ref_gap_score\":ref_gap_score,\n                  #\"use_prior\":use_prior,\n                  #\"allowed_mappings\":allowed_mappings,\n                  #\"num_threads\":num_threads,\n                  #\"reference\":reference,\n                  #\"gtf_path\":gtf_path,\n                  #\"collapse_thresh\":collapse_thresh,\n                  #\"span_cutoff\":span_cutoff,\n                  #\"mq_cutoff\":mq_cutoff,\n                  #\"mq_len\":mq_len}\n\nread_num_to_read_id = pickle.load(open(args.read_num_to_read_id,\"rb\"))\n#constants_dict[\"read_num_to_read_id\"] = read_num_to_read_id\n\nid_to_sam_dict = {}\nwith open(five_prime_mapped_name ,\"r\") as five_prime_mapped:\n    sam_line = five_prime_mapped.readline()\n    while sam_line and \"@\" == sam_line[0]:  # Read past the header lines\n        sam_line = five_prime_mapped.readline()\n\n    while sam_line:\n        sam_entry = SAMEntry(sam_line)\n        base_read_id = sam_entry.read_id.replace(\"/5_prime\" ,\"\")\n        if base_read_id in id_to_sam_dict:\n            sys.stderr.write(\"SPORK ERROR: Found duplicate base_read_id in 5_prime mappings\\n\")\n            sys.stderr.write( base_read_id +\"\\n\")\n            sys.exit(1)\n        # Filter out some of the strange chromosomes: (e.g. chrUn_gl000220)\n        if \"_\" not in sam_entry.chromosome:\n            id_to_sam_dict[base_read_id] = sam_entry\n        sam_line = five_prime_mapped.readline()\n\n# Now walk through the three prime mappings creating bin pairs from all shared ids\nbin_pairs = []\nbin_pairs_ids = {}\nwith open(three_prime_mapped_name ,\"r\") as three_prime_mapped:\n    sam_line = three_prime_mapped.readline()\n    while sam_line and \"@\" == sam_line[0]:  # Read past the header lines\n        sam_line = three_prime_mapped.readline()\n\n    while sam_line:\n        three_prime_sam = SAMEntry(sam_line)\n        base_read_id = three_prime_sam.read_id.replace(\"/3_prime\" ,\"\")\n        # Filter out some of the strange chromosomes: (e.g. chrUn_gl000220)\n        if \"_\" not in three_prime_sam.chromosome and base_read_id in id_to_sam_dict:\n            five_prime_sam = id_to_sam_dict[base_read_id]\n            five_prime_bin = int(five_prime_sam.start / bin_size)\n            three_prime_bin = int(three_prime_sam.start / bin_size)\n            bin_pair = BinPair(five_prime_sam ,three_prime_sam ,five_prime_bin ,three_prime_bin)\n            bin_pairs.append(bin_pair)\n            if bin_pair.bin_pair not in bin_pairs_ids:\n                bin_pairs_ids[bin_pair.bin_pair] = 0\n            else:\n                bin_pairs_ids[bin_pair.bin_pair] += 1\n        sam_line = three_prime_mapped.readline()\nid_to_sam_dict = {}  # clearing the dictionary to free up space\n\n# Sort the bin_pairs by bin_pair id to form list w/ groups adjacent\nbin_pairs.sort()\n\nbin_pair_out_file_name = args.sample + \"_bin_pairs.txt\"\nwith open(bin_pair_out_file_name, \"w\") as f:\n    for bin_pair in bin_pairs:\n        f.write(str(bin_pair))\n\nbin_pair_group_ranges = find_bin_pair_group_ranges(bin_pairs, constants_dict, bin_pairs_ids)\n\ndenovo_junctions = []\ndenovo_junctions = build_junction_sequences(bin_pairs, bin_pair_group_ranges, combined_fastq, constants_dict, read_num_to_read_id)\npickle.dump(denovo_junctions, open(args.sample + \"_denovo_junctions.pickle\",\"wb\"), -1)\npickle.dump(bin_pairs_ids, open(args.sample + \"_bin_pairs_ids.pickle\",\"wb\"), -1)\n\n\nbin_pairs = []\n\nused_read_ids_name = args.sample + \"used_read_ids.txt\"\nread_ids_per_jct_name = args.sample + \"reads_in_jcts.txt\"\nsplice_fasta_path = args.sample + \"putative_splices\"\n\nwith open(used_read_ids_name, \"w\") as used_read_ids:\n    with open(read_ids_per_jct_name, 'w') as ids_per_jct:\n        for jct in denovo_junctions:\n            ids_per_jct.write(\"Jct ID: \" + str(jct.jct_ind) + \"\\n\")\n            for bin_pair in jct.bin_pair_group:\n                used_read_id = bin_pair.five_prime_SAM.read_id\n                used_read_id = used_read_id[:-3]  # To get rid of the \" R1\" or \" R2\" added previously\n                used_read_ids.write(used_read_id + \"\\n\")\n                ids_per_jct.write(\"\\t\" + used_read_id + \"\\n\")\n\ndef write_donor_acceptor(denovo_jcts, splice_fasta_path):\n    print len(denovo_jcts)\n    with open(splice_fasta_path, 'w') as splice_fasta:\n        for jct in denovo_jcts:\n            seq = jct.consensus\n            jct_ind = jct.jct_ind\n            for split_ind in range(flank_len, len(seq) - flank_len + 1):\n                don_seq = seq[:split_ind][-flank_len:]\n                acc_seq = seq[split_ind:][:flank_len]\n                base_header = '>' + str(jct_ind) + '_' + str(split_ind)\n\n                splice_fasta.write(base_header + '_don\\n' + don_seq + '\\n')\n                splice_fasta.write(base_header + '_acc\\n' + acc_seq + '\\n')\n\n\ndenovo_junctions_length = len(denovo_junctions)\nbatch_size = int(math.floor(denovo_junctions_length/cpu))\nprocs = []\nprint denovo_junctions_length\nfor i, batch_start in enumerate(range(0, denovo_junctions_length, batch_size)):\n    try:\n        my_process = multiprocessing.Process(target=write_donor_acceptor, args=(denovo_junctions[batch_start:batch_start+batch_size],splice_fasta_path + \"_\" + str(i) + \".fa\"))\n        procs.append(my_process)\n        my_process.start()\n\n        for p in procs:\n            p.join()\n\n    except Exception as e:\n        print \"Exception:\", e",
                "filename": "bin_pairs.py"
              },
              {
                "fileContent": "# General Imports\nfrom collections import defaultdict\nimport subprocess\nimport itertools\nimport zlib\nimport time\nimport sys\nimport os\nimport re\n\n# Specific Imports\nfrom SPORK_consensus_utils import *\nfrom SPORK_Junction import Junction\nfrom SPORK_BinPair import BinPair\nfrom SPORK_GTFEntry import GTFEntry\nfrom SPORK_SAMEntry import SAMEntry\nfrom SPORK_FastQEntry import FastQEntry\n\n\n\ndef get_ref_seq(read_seq, MD):\n\n    cur_pos = 0\n    reference_string = \"\"\n    k = 0\n    for i, c in enumerate(MD):\n        if c.isdigit():\n            continue\n        if cur_pos != i:\n            num_matches = int(MD[cur_pos:i])\n        else:\n            num_matches = 0\n        reference_string += read_seq[k: k + num_matches]\n        reference_string += c\n        cur_pos = i + 1\n        k = k + num_matches + 1\n    reference_string += read_seq[k:]\n\n    return reference_string\n\n#######################################\n#   Get Reference and GTF from Mode   #\n#######################################\n# Finding the correct reference index based on the mode\n# Human defaults are used and currently the only supported mode\n# Could imagine lots of if else statements with other supported references though\n# Putting this in the utils file should allow for easy reference addition\ndef get_reference_and_gtf_from_mode(ref_dir, abs_path, mode=\"hg19\"):\n    \"\"\"\n    Goal: take in the desired mode and return the index and gtf path\n    Arguments:\n        the path to the circ_ref directory that MACHETE also uses\n        the mode (currently only allows hg19, so this function is mostly for show)\n        will become an 'elif' tree as more and more indicies are added\n\n    Returns:\n        a tuple of (reference_path,gtf_path)\n    \"\"\"\n    # index_path = \"/scratch/PI/horence/rob/index/\"\n    # reference = index_path+\"hg19\"\n    reference = ref_dir\n    gtf_path = \"\"\n    if mode == \"hg19\":\n        sys.stdout.write('SPORK: Reference using hg19\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"hg19_gtfs\")\n        reference = os.path.join(reference, \"hg19_genome\")\n\n    elif mode == \"grch38\":\n        sys.stdout.write('SPORK: Reference using grch38\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"grch38_gtfs\")\n        reference = os.path.join(reference, \"grch38_genome\")\n\n    elif mode == \"mm10\":\n        sys.stdout.write('SPORK: Reference using mm10\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"mm10_gtfs\")\n        reference = os.path.join(reference, \"mm10_genome\")\n\n    return reference, gtf_path\n\n\n#################################\n#   Find Bin Pair Group Ranges  #\n#################################\n# Run through the bin pair groupings to find the end index of each group\n# Example bin pair list:\n# [0] chr10:45_chr10:55\n# [2] chr10:45_chr10:55\n# [3] chr10:98_chr10:99\n# [4] chr10:145_chr10:155\n# [5] chr10:145_chr10:155\n# [6] chr10:145_chr10:155\n#\n# Output: [2,3,6]\ndef find_bin_pair_group_ranges(bin_pairs, constants_dict, bin_pairs_ids):\n    \"\"\"\n    Goal: take in a sorted list of bin_pairs and collapse them to ranges\n    Arguments:\n        bin_pairs is a list[BinPair] of the bin pairs\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        bin_pair_group_ranges which is a list[[start0,stop0],[start1,stop1],...]\n        also filters out groups that have less then a cutoff of members\n    \"\"\"\n    bin_pair_group_ends = []\n    prev_bin_pair = \"\"\n    for bin_pair_ind in range(len(bin_pairs)):\n        curr_bin_pair = bin_pairs[bin_pair_ind].bin_pair\n        if curr_bin_pair != prev_bin_pair:\n            bin_pair_group_ends.append(bin_pair_ind)\n            prev_bin_pair = curr_bin_pair\n\n    # Remove the 0 at the front of the bin_pair list\n    bin_pair_group_ends = bin_pair_group_ends[1:]\n\n    # Add on the last bin_pair end which will necessarily be the end of the bin_pair list\n    bin_pair_group_ends.append(len(bin_pairs))\n\n    # Find the bin pair ranges\n    bin_pair_group_ranges = []\n    to_remove_bin_pairs = []\n    to_keep_bin_pairs = []\n    for bin_pair_ind in range(len(bin_pair_group_ends) - 1):\n        start_ind = bin_pair_group_ends[bin_pair_ind]\n        stop_ind = bin_pair_group_ends[bin_pair_ind + 1]\n        if stop_ind - start_ind >= (constants_dict[\"group_member_cutoff\"]):  # The \"-1\" is for inclusive counting\n            bin_pair_group_ranges.append([start_ind, stop_ind])\n        else:\n            org_bin_pair = bin_pairs[start_ind].bin_pair\n            left_chr = org_bin_pair.split(\":\")[0]\n            left_pos = org_bin_pair.split(\":\")[1].split(\"_\")[0]\n            right_chr = \"_\".join(org_bin_pair.split(\":\")[1].split(\"_\")[1:])\n            right_pos = org_bin_pair.split(\":\")[2].split(\"_\")[0]\n            strand_left = \"+\" if org_bin_pair.split(\":\")[2].split(\"_\")[1][1] == \"-\" else \"-\"\n            strand_right = \"+\" if org_bin_pair.split(\":\")[2].split(\"_\")[1][3] == \"-\" else \"-\"\n\n            reverse_bin_pair = right_chr + \":\" + right_pos + \"_\" + left_chr + \":\" + left_pos + \"_(\" + strand_right + \",\" + strand_left + \")\"\n            if reverse_bin_pair in bin_pairs_ids:\n                bin_pair_group_ranges.append([start_ind, stop_ind])\n                to_keep_bin_pairs.append(org_bin_pair)\n            else:\n                to_remove_bin_pairs.append(org_bin_pair)\n    # print bin_pair_group_ends\n    # print bin_pair_group_ranges\n    # sys.stdout.flush()\n\n    #with open(\"to_remove_bin_pairs.txt\", \"w\") as f:\n    #    for bin_pair in to_remove_bin_pairs:\n    #        f.write(bin_pair + \"\\n\")\n\n    #with open(\"to_keep_bin_pairs.txt\", \"w\") as f:\n    #    for bin_pair in to_keep_bin_pairs:\n    #        f.write(bin_pair + \"\\n\")\n\n    return bin_pair_group_ranges\n\n\n\n################################\n#   Build Junction Sequences   #\n################################\n# Run through the bin_pair_group_ends to perform:\n# (1) checking if there are enough in each group\n# (2) padding the sequences in the first bin\n# (3) creating a consensus in the first bin\n# (4) scoring the consensus in the first bin\n# (5) repeat (2)-(4) for the second bin\n# (6) average the two consensus scores and see if they are below a cutoff\ndef build_junction_sequences(bin_pairs, bin_pair_group_ranges, full_path_name, constants_dict, read_num_to_read_id):\n    \"\"\"\n    Goal: convert the bin_pairs into a junction object for each bin_pair\n    Arguments:\n        bin_pairs is a list[BinPairs]\n        bin_pair_group_ranges is a list[[start0,stop0],[start1,stop1],...] so its a list of list\n        full_path_name is the 'spaces-removed' file that is looked at to get the full sequences\n            -> this is used to build the consensus for the junction\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        denovo_junctions which is a list[Junction]\n    \"\"\"\n    group_member_cutoff = constants_dict[\"group_member_cutoff\"]\n    consensus_score_cutoff = constants_dict[\"consensus_score_cutoff\"]\n    bin_size = constants_dict[\"bin_size\"]\n    #reference = constants_dict[\"reference\"]\n    denovo_junctions = []\n\n    # Look back at the original full path to get seq lines\n    unaligned_file = open(full_path_name, \"r\")\n    unaligned_reads = unaligned_file.readlines()\n    unaligned_file.close()\n    unaligned_reads = [unaligned_reads[ind] for ind in range(len(unaligned_reads)) if ind % 4 == 0 or ind % 4 == 1]\n    id_to_seq = {}\n\n    # Build the dictionary of read_id to the full read\n    for ind in range(0, len(unaligned_reads), 2):\n        key = unaligned_reads[ind].strip()\n        value = unaligned_reads[ind + 1].strip()\n        id_to_seq[key] = value\n\n    # walk through each bin_pair_group\n    #write_time(\"Working on the bin-pairs :\" + str(len(bin_pair_group_ranges)), time.time(), constants_dict[\"timer_file_path\"])\n\n    num_fail_size = 0\n    num_fail_score = 0\n    jct_ind = 0\n    for bin_pair_group_range in bin_pair_group_ranges:\n        # junction_num = \"(\"+str(bin_pair_group_ranges.index(bin_pair_group_range)+1)+\"/\"+str(len(bin_pair_group_ranges))+\")\"\n        # print junction_num\n        # sys.stdout.flush()\n\n        # start_build_junction = time.time()\n        start_ind = bin_pair_group_range[0]\n        stop_ind = bin_pair_group_range[1]\n        group_members = bin_pairs[start_ind:stop_ind]\n\n        # If there are not enough group members then skip this group\n        #if len(group_members) < group_member_cutoff:\n            # sys.stderr.write(\"Skipped group in build junction seqs\\n\") #expecting to have filtered out before this\n            # sys.stderr.write(\"len(group_members) == \"+str(len(group_members))+\"\\n\")\n            #num_fail_size += 1\n            #continue\n\n        # Otherwise start thinking about getting strandedness\n        five_prime_strand = group_members[0].five_prime_strand\n        three_prime_strand = group_members[0].three_prime_strand\n\n        # Find the consensus sequence and score\n        # Takes just the 5' ends to get the pos\n        # the full original unaligned seq\n        mapped_reads = [member.five_prime_SAM for member in group_members]\n        bin_consensus, bin_score = build_and_score_consensus(mapped_reads, five_prime_strand, id_to_seq, bin_size, constants_dict, read_num_to_read_id)\n        took_reverse_compliment = False\n\n        \"\"\"\n        # TODO what do I do if the five and three prime strands are not the same? (this represents a translocation)\n        # If the reverse compliment was taken above then take the rev compliment of the consensus too\n        # NOTE currently just taking reverse compliment whenever the 5' strand is negative to help groupings\n        #   i.e. if have 5' - and 3' + of a jct and 5' + and 3' - of the same jct, they should be collapsed, but won't be\n        #   unless I implement this\n        #if five_prime_strand == \"-\" and three_prime_strand == \"-\":\n        if five_prime_strand == \"-\":\n            group_members = [member.take_reverse_compliment() for member in group_members]\n            bin_consensus = reverse_compliment(bin_consensus)\n            took_reverse_compliment = True\n\n        \"\"\"\n        # If the bin score is good enough then add it\n        if bin_score < consensus_score_cutoff:\n            denovo_junction = Junction(bin_consensus, bin_score, group_members, jct_ind, took_reverse_compliment, constants_dict)\n            denovo_junctions.append(denovo_junction)\n            jct_ind += 1\n        else:\n            num_fail_score += 1\n\n    #write_time(\"Filtered out bin-pairs by size < \" + str(group_member_cutoff) + \" :\" + str(num_fail_size), time.time(), constants_dict[\"timer_file_path\"])\n    #write_time(\"Filtered out bin-pairs by score < \" + str(consensus_score_cutoff) + \" :\" + str(num_fail_score), time.time(), constants_dict[\"timer_file_path\"])\n    #write_time(\"Number of jcts after build jcts: \" + str(jct_ind), time.time(), constants_dict[\"timer_file_path\"])\n    return denovo_junctions\n\n\n##########################\n#   Find Splice Inds V2  #\n##########################\n# Runs bowtie on all of the possible splice sites of all possible junctions\n# Returns a dict keyed by jct_id and valued by a list of cut sites\ndef find_splice_inds_v2(denovo_junctions, constants_dict):\n    \"\"\"\n    Goal: find where in the consensus sequence to make and donor and acceptor cut\n    Arguments:\n        denovo_junctions is a list[Junction]\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        returns a tuple of (jcts_with_splice,jcts_without_splice)\n        to allow for continuing with only jcts that had a splice site found\n\n    Program flow:\n        1. Write all possible splice cuts for all possible\n           consensus seq jcts to a fasta file\n\n        2. Map this file to the genome reference\n           --> Don't allow gaps\n           --> Report the best k unique multiple mappings for each read\n\n        3. Look through the mapping file for each junction to find the best splice site\n           --> Preference should primarily be given to splits that map close to each other\n           --> Next preference is the most amount of the consensus successfully mapped\n    \"\"\"\n\n    # Get parameters from the constants_dict\n    splice_fasta_path = os.path.join(constants_dict[\"output_dir\"], \"putative_splices.fa\")\n    splice_mapped_path = os.path.join(constants_dict[\"output_dir\"], \"putative_splices.sam\")\n    flank_len = constants_dict[\"splice_finding_flank\"]\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    max_mismatches = int(constants_dict[\"splice_finding_allowed_mismatches\"])\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n    n_multimap = \"10\"\n\n    # 1. Write all possible splice cuts for all possible jcts to a fasta\n    #   if seq is abcdefghijklmnopqrstuvwxyz and thirds_len = 10 then you would want:\n    #       [abcdefghij]|[klmnopqrst]uvwxyz\n    #       a[bcdefghijk]|[lmnopqrstu]vwxyz\n    #       ab[cdefghijkl]|[mnopqrstuv]wxyz\n    #       abc[defghijklm]|[nopqrstuvw]xyz\n    #       abcd[efghijklmn]|[opqrstuvwx]yz\n    #       abcde[fghijklmno]|[pqrstuvwxy]z\n    #       abcdef[ghijklmnop]|[qrstuvwxyz]\n    #   where the first [] group is don and second [] group is acc\n    with open(splice_fasta_path, 'w') as splice_fasta:\n        for jct in denovo_junctions:\n            seq = jct.consensus\n            jct_ind = jct.jct_ind\n            for split_ind in range(flank_len, len(seq) - flank_len + 1):\n                don_seq = seq[:split_ind][-flank_len:]\n                acc_seq = seq[split_ind:][:flank_len]\n                base_header = '>' + str(jct_ind) + '_' + str(split_ind)\n\n                splice_fasta.write(base_header + '_don\\n' + don_seq + '\\n')\n                splice_fasta.write(base_header + '_acc\\n' + acc_seq + '\\n')\n\n    # 2. Map the splice fasta to the genome reference\n    with open(splice_mapped_path, \"w\") as splice_mapped:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-hd\", \"--no-unal\", min_score, read_gap_score,\n             ref_gap_score, \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, splice_fasta_path],\n            stdout=splice_mapped)\n\n    # 3. Look through the mapping file for each junction to find the best splice site\n    #   no sorting guarantees so have to read all in at once\n    #   (could pre-sort if this is too mem intensive)\n\n    # Maybe this is poor coding, but splice_dict is a 3-deep default dictionary\n    #   the 1st level is the jct_index\n    #   the 2nd level is the splice_index\n    #   the 3rd level is either 'don' or 'acc'\n    # Could have made a flat dict with a combination key of the levels\n    #   but then I would have to keep track of what the jct and splice indices are\n    splice_dict = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))\n    with open(splice_mapped_path, \"r\") as splice_mapped:\n        for line in splice_mapped:\n            sam = SAMEntry(line)\n            jct_ind, split_ind, kind = sam.read_id.split('_')\n            splice_dict[jct_ind][split_ind][kind].append(sam)\n\n    # Internal splice comparing function\n    def compare_don_acc(best_don, best_acc, test_don, test_acc):\n        # None case\n        if best_don == None and best_acc == None:\n            return test_don, test_acc\n\n        # If one pair is on the same chr and the other is not\n        best_same_chr = best_don.chromosome == best_acc.chromosome\n        test_same_chr = test_don.chromosome == test_acc.chromosome\n        if test_same_chr and not best_same_chr:\n            return test_don, test_acc\n        if best_same_chr and not test_same_chr:\n            return best_don, best_acc\n\n        # NOTE could extend this to do strand comparisons\n\n        # Now the pairs share chr status determine by which dropped less sequence\n        best_len = len(best_don.seq) + len(best_acc.seq)\n        test_len = len(test_don.seq) + len(test_acc.seq)\n        if best_len > test_len:\n            return best_don, best_acc\n        if test_len > best_len:\n            return test_don, test_acc\n\n        # Now determine by number of mismatches\n        best_mismatches = best_don.num_mismatches + best_acc.num_mismatches\n        test_mismatches = test_don.num_mismatches + test_acc.num_mismatches\n        if best_mismatches > test_mismatches:\n            return test_don, test_acc\n        else:\n            return best_don, best_acc\n\n    # Loop through the jcts looking throughout the entire splice_dict\n    jcts_with_splice = []\n    jcts_wout_splice = []\n\n    for jct in denovo_junctions:\n        best_don, best_acc = None, None\n        jct_ind = str(jct.jct_ind)\n        for splice_ind in splice_dict[jct_ind]:\n            dons = splice_dict[jct_ind][splice_ind]['don']\n            accs = splice_dict[jct_ind][splice_ind]['acc']\n\n            # NOTE Just a print out to check for multimappings\n            # if len(dons) > 1 or len(accs) > 1:\n            #    sys.stdout.write('MULTIMAPPING: '+jct_ind+'_'+splice_ind+'\\n')\n\n            for don, acc in itertools.product(dons, accs):\n                best_don, best_acc = compare_don_acc(best_don, best_acc, don, acc)\n\n        # If there is no splice\n        if best_don == None or best_acc == None:\n            jcts_wout_splice.append(jct)\n            continue\n\n        # Otherwise update jct data\n        jct.consensus = best_don.seq + best_acc.seq\n        jct.donor_sam = best_don\n        jct.acceptor_sam = best_acc\n        jcts_with_splice.append(jct)\n\n    # Return the jcts\n    sys.stdout.write('WITH SPLICE: ' + str(len(jcts_with_splice)) + ' WOUT SPLICE:' + str(len(jcts_wout_splice)) + '\\n')\n    return jcts_with_splice, jcts_wout_splice\n\n\n########################\n#   Find Splice Inds   #\n########################\n# Runs bowtie on all of the possible splice sites of all possible junctions\n# Returns a dict keyed by jct_id and valued by a list of cut sites\ndef find_splice_inds(denovo_junctions, constants_dict):\n    \"\"\"\n    Goal: find where in the consensus sequence to make and donor and acceptor cut\n    Arguments:\n        denovo_junctions is a list[Junction]\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        returns a tuple of (jcts_with_splice,jcts_without_splice)\n        to allow for continuing with only jcts that had a splice site found\n    \"\"\"\n    # Gather info from the constants dictionary\n    splice_finder_temp_name = os.path.join(constants_dict[\"output_dir\"], \"splice_finder_temp_\")\n    thirds_len = constants_dict[\"thirds_len\"]\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    max_mismatches = int(constants_dict[\"splice_finding_allowed_mismatches\"])\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    allowed_mappings = constants_dict[\"splice_finding_allowed_mappings\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n\n    # Handle temporary files\n    five_prime_mapped_name = splice_finder_temp_name + \"5_prime.sam\"\n    three_prime_mapped_name = splice_finder_temp_name + \"3_prime.sam\"\n    five_prime_fa_file = splice_finder_temp_name + \"5_prime.fa\"\n    three_prime_fa_file = splice_finder_temp_name + \"3_prime.fa\"\n    five_temp_file = open(five_prime_fa_file, \"w\")\n    three_temp_file = open(three_prime_fa_file, \"w\")\n\n    # Do all the aligning work only if there are no mapped files already\n    if use_prior and os.path.isfile(five_prime_mapped_name) and os.path.isfile(three_prime_mapped_name):\n        write_time(\"--Using existing files in splice ind id\", time.time(), constants_dict[\"timer_file_path\"])\n    else:\n        # Write out all the possible splice sites for every jct out to a 5' and 3' file\n        num_size_excluded = 0\n        avg_cons_len = 0\n        for jct_ind in range(len(denovo_junctions)):\n            sys.stdout.flush()\n            junction = denovo_junctions[jct_ind]\n            cons_len = len(junction.consensus)\n            avg_cons_len = (float(jct_ind * avg_cons_len) / (jct_ind + 1)) + (float(cons_len) / (jct_ind + 1))\n            # splice_map_size = len(junction.consensus)/3\n            # NOTE found that I was forcinng splice sites to be too central if I used the thirds len\n            # NOTE and lost BCR-ABL this way, so instead I'll stick with using 1/3 of the consensus\n            splice_map_size = thirds_len\n            # sys.stderr.write(\"Cons len \"+str(cons_len)+\" and thirds_len \"+str(splice_map_size)+\"\\n\")\n\n            five_prime_list = [junction.consensus[ind:ind + splice_map_size]\n                               for ind in range(0, cons_len - 2 * splice_map_size + 1)]\n\n            three_prime_list = [junction.consensus[ind:ind + splice_map_size]\n                                for ind in range(splice_map_size, cons_len - splice_map_size + 1)]\n\n            # Oh this is my problem, sometimes the consensus length is too small\n            # to try and find splice inds from, so I should just throw that out and iterate,\n            # otherwise I'll have blank lines added to my splice ind fa files and they will be\n            # incorrectly formatted\n            if len(five_prime_list) == 0 or len(three_prime_list) == 0:\n                num_size_excluded += 1\n                continue\n\n            five_prime_fa_list = [\">jct_\" + str(jct_ind) + \"_ind_\" + str(ind) + \"\\n\"\n                                  + five_prime_list[ind] for ind in range(len(five_prime_list))]\n\n            three_prime_fa_list = [\">jct_\" + str(jct_ind) + \"_ind_\" + str(ind) + \"\\n\"\n                                   + three_prime_list[ind] for ind in range(len(three_prime_list))]\n\n            five_temp_file.write(\"\\n\".join(five_prime_fa_list) + \"\\n\")\n            three_temp_file.write(\"\\n\".join(three_prime_fa_list) + \"\\n\")\n\n        # Don't forget to close the files :)\n        five_temp_file.close()\n        three_temp_file.close()\n        sys.stdout.write(\"SPORK: Average consensus length [\" + str(avg_cons_len) + \"]\\n\")\n        sys.stdout.write(\"SPORK: Splitting fqs, size excluded [\" + str(num_size_excluded) + \"] of [\" + str(\n            len(denovo_junctions)) + \"]\\n\")\n\n        # Map the temp files above to the reference and save in temp sam files\n        # Need to specify the -f flag because the inputs are fasta files\n        with open(five_prime_mapped_name, \"w\") as five_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-x\", reference, five_prime_fa_file], stdout=five_prime_mapped)\n\n        with open(three_prime_mapped_name, \"w\") as three_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-x\", reference, three_prime_fa_file], stdout=three_prime_mapped)\n\n        # Map the temp files above to the reference and save in temp sam files\n        # Need to specify the -f flag because the inputs are fasta files\n        \"\"\"\n        n_multimap = \"10\"\n        with open(five_prime_mapped_name,\"w\") as five_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, five_prime_fa_file], stdout=five_prime_mapped)\n\n        with open(three_prime_mapped_name,\"w\") as three_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, three_prime_fa_file], stdout=three_prime_mapped)\n        \"\"\"\n\n        # Sort the temp output files after removing the header lines\n        p1 = subprocess.Popen([\"grep\", \"-v\", \"@\", five_prime_mapped_name], stdout=subprocess.PIPE)\n        p2 = subprocess.Popen([\"sort\", \"-o\", five_prime_mapped_name], stdin=p1.stdout)\n        p2.communicate()\n\n        p3 = subprocess.Popen([\"grep\", \"-v\", \"@\", three_prime_mapped_name], stdout=subprocess.PIPE)\n        p4 = subprocess.Popen([\"sort\", \"-o\", three_prime_mapped_name], stdin=p3.stdout)\n        p4.communicate()\n\n    # Open the mapped, sorted, headerless files\n    five_prime_sam_file = open(five_prime_mapped_name, \"r\")\n    three_prime_sam_file = open(three_prime_mapped_name, \"r\")\n\n    # Try and find the best splice sites walking through both files at once\n    best_splices = {}\n    sam_five_list = []\n    sam_three_list = []\n    prev_jct_ind = 0\n    five_sam_line = five_prime_sam_file.readline()\n    three_sam_line = three_prime_sam_file.readline()\n    while five_sam_line and three_sam_line:\n        sys.stdout.flush()\n        five_sam_entry = SAMEntry(five_sam_line)\n        three_sam_entry = SAMEntry(three_sam_line)\n\n        five_jct_ind = int(five_sam_entry.read_id.split(\"_\")[1])\n        three_jct_ind = int(three_sam_entry.read_id.split(\"_\")[1])\n\n        # Both the 5' and 3' sam are the prev_jct_ind\n        if five_jct_ind == prev_jct_ind and three_jct_ind == prev_jct_ind:\n            if five_sam_entry.num_mismatches <= max_mismatches:\n                sam_five_list.append(five_sam_entry)\n            if three_sam_entry.num_mismatches <= max_mismatches:\n                sam_three_list.append(three_sam_entry)\n            five_sam_line = five_prime_sam_file.readline()\n            three_sam_line = three_prime_sam_file.readline()\n\n        # Only the 5' sam is at the prev_jct_ind\n        elif five_jct_ind == prev_jct_ind:\n            if five_sam_entry.num_mismatches <= max_mismatches:\n                sam_five_list.append(five_sam_entry)\n            five_sam_line = five_prime_sam_file.readline()\n\n        # Only the 3' sam is at the prev_jct_ind\n        elif three_jct_ind == prev_jct_ind:\n            if three_sam_entry.num_mismatches <= max_mismatches:\n                sam_three_list.append(three_sam_entry)\n            three_sam_line = three_prime_sam_file.readline()\n\n        # Niether the 5' nor 3' sam is at the prev_jct_ind\n        else:\n            # RB 11/18/16 Filter out 5' and 3' sams if chroms are not the same as the unsplit\n            # RB 11/21/16 Also imposing a radius on the same chromosome filter (start at 30, very tight)\n            # RB 05/26/17 Actually I don't want to impose this restriction, would be ok with\n            #            different alignments than the original\n            #            this boils down to just commenting out this 'extra' filtering\n            radius = 30\n            pj = denovo_junctions[prev_jct_ind]\n\n            \"\"\"\n            sam_five_list = [sam for sam in sam_five_list\n                             if (sam.chromosome == pj.donor_sam.chromosome and \n                                 abs(pj.donor_sam.start-sam.start) < radius)]\n\n            sam_three_list = [sam for sam in sam_three_list\n                              if (sam.chromosome == pj.acceptor_sam.chromosome and \n                                  abs(pj.acceptor_sam.start-sam.start) < radius)]\n            \"\"\"\n\n            # Get the best 5' and 3' pair of Sams\n            prev_consensus = pj.consensus\n            # best_five,best_three = get_best_splice(sam_five_list,sam_three_list,prev_consensus,max_mismatches)\n            best_five, best_three = get_multi_best_splice(sam_five_list, sam_three_list, prev_consensus, max_mismatches)\n\n            best_splices[prev_jct_ind] = [best_five, best_three]\n            sam_five_list = []\n            sam_three_list = []\n            prev_jct_ind = min(five_jct_ind, three_jct_ind)\n\n    # Have to push the last jct lists into the shared_dict\n    pj = denovo_junctions[prev_jct_ind]\n    prev_consensus = pj.consensus\n    sam_five_list = [sam for sam in sam_five_list if sam.chromosome == pj.donor_sam.chromosome]\n    sam_three_list = [sam for sam in sam_three_list if sam.chromosome == pj.acceptor_sam.chromosome]\n\n    # best_five,best_three = get_best_splice(sam_five_list,sam_three_list,prev_consensus,max_mismatches)\n    best_five, best_three = get_multi_best_splice(sam_five_list, sam_three_list, prev_consensus, max_mismatches)\n    best_splices[prev_jct_ind] = [best_five, best_three]\n\n    # Close the 5' and 3' sam files\n    five_prime_sam_file.close()\n    three_prime_sam_file.close()\n\n    # Loop through the jcts assigning the splice site info\n    jcts_with_splice = []\n    jcts_without_splice = []\n    for jct_ind in range(len(denovo_junctions)):\n        sys.stdout.flush()\n        jct = denovo_junctions[jct_ind]\n\n        # Use calculted best splice if was previously found and both the\n        # donor and acceptor elements exist\n        if jct_ind in best_splices and all([sam.exists for sam in best_splices[jct_ind]]):\n            donor_sam, acceptor_sam = best_splices[jct_ind]\n\n            # Need to include the donor seq not used in splitting\n            # gets complicated by + and - strand\n            donor_ind = int(donor_sam.read_id.split(\"_ind_\")[1])\n            donor_len = len(donor_sam.seq)\n            up_remaining = jct.consensus[:donor_ind]\n            if donor_sam.strand == \"+\":\n                donor_sam.seq = up_remaining + donor_sam.seq\n                donor_sam.start -= len(up_remaining)\n            elif donor_sam.strand == \"-\":\n                donor_sam.seq = up_remaining + reverse_compliment(donor_sam.seq)\n                donor_sam.stop += len(up_remaining)\n            jct.donor_sam = donor_sam\n\n            # Need to include the acceptor seq not used in splitting\n            # gets complicated by + and - strand\n            acceptor_ind = int(acceptor_sam.read_id.split(\"_ind_\")[1])\n            acceptor_len = len(acceptor_sam.seq)\n            down_remaining = jct.consensus[acceptor_ind + 2 * acceptor_len:]\n            if acceptor_sam.strand == \"+\":\n                acceptor_sam.seq = acceptor_sam.seq + down_remaining\n                acceptor_sam.stop += len(down_remaining) - 1\n            elif acceptor_sam.strand == \"-\":\n                acceptor_sam.seq = reverse_compliment(acceptor_sam.seq) + down_remaining\n                acceptor_sam.start -= len(down_remaining)\n            jct.acceptor_sam = acceptor_sam\n\n            jcts_with_splice.append(jct)\n\n        # If either the donor or acceptor doesn't map (or both), add it to the\n        # jcts_without_splice list instead NOTE this list is currently not used\n        else:\n            jcts_without_splice.append(jct)\n\n    # Choose either the forward or reverse form of the junction that yields\n    # the smaller donor site since this will help collapsing in the next step\n    # (could have chosen larger donor etc, just to flip them all same way)\n\n    write_time(\"Num Jcts w/ splice = \" + str(len(jcts_with_splice)), time.time(), timer_file_path)\n    write_time(\"Num Jcts w/out splice = \" + str(len(jcts_without_splice)), time.time(), timer_file_path)\n\n    small_don_jcts_with_splice = []\n    for jct in jcts_with_splice:\n        if jct.donor_sam.donor() < jct.acceptor_sam.acceptor():\n            small_don_jcts_with_splice.append(jct)\n        else:\n            small_don_jcts_with_splice.append(jct.yield_reverse())\n\n    # Return the jcts w/ and w/out splice separately\n    return small_don_jcts_with_splice, jcts_without_splice\n\n\n#######################\n#   Get Best Splice   #\n#######################\n# This is a helper function for the splice site finder\n# If there are multiple found splice, return the best from the shared sams dict from the two sam lists\ndef get_best_splice(sam_five_list, sam_three_list, consensus, max_mismatches):\n    \"\"\"\n    Goal: given a list of possible splice, return the best one for a junction\n    Arguments:\n        sam_five_list is a list[SAMEntry] for possible 5' cuts\n        sam_three_list is a list[SAMEntry] for possible 3' cuts\n        consensus is a str and the consensus sequence of this junction\n        max_mismatches is the maximum allowed mismatches in total for the 5' and 3' sides\n\n    Returns:\n        a tuple of the (best_5'_sam,best_3'_sam) to then be stored in the junction\n    \"\"\"\n    shared_dict = {}\n    id_dict = {}\n    best_sam_five = SAMEntry()\n    best_sam_five_len = 0\n    best_sam_three = SAMEntry()\n    best_sam_three_len = 0\n\n    # Populate the id_dict to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 5' mapping\n    for sam_five in sam_five_list:\n        id_dict[sam_five.read_id] = sam_five\n        if len(sam_five.seq) > best_sam_five_len:\n            best_sam_five_len = len(sam_five.seq)\n            best_sam_five = sam_five\n\n    # Check the id_dict to see if the 3' has a perfect 5' match\n    # Also keep track of the best (longest) 3' mapping\n    for sam_three in sam_three_list:\n        if len(sam_three.seq) > best_sam_three_len:\n            best_sam_three_len = len(sam_three.seq)\n            best_sam_three = sam_three\n        if sam_three.read_id in id_dict:\n            sam_five = id_dict[sam_three.read_id]\n            shared_dict[sam_three.read_id] = [sam_five, sam_three]\n\n    # Now pick out the best sam's to use\n    # If there is at least one shared perfect splice ind find the one w/ least mismatches\n    # then choose the perfect pair that has the least mismatches\n    if len(shared_dict) > 0:\n        best_key = \"\"\n        min_mismatches = max_mismatches + 1\n        for key in shared_dict:\n            sam1, sam2 = shared_dict[key]\n            num_mismatches = sam1.num_mismatches + sam2.num_mismatches\n            if best_key == \"\" or num_mismatches < min_mismatches:\n                best_key = key\n                min_mismatches = num_mismatches\n        best_five_sam, best_three_sam = shared_dict[best_key]\n        return best_five_sam, best_three_sam\n\n    # Otherwise there is a mapping for the left and right pieces, although there is space in between\n    # NOTE is it possible that the best 5' and 3' seqs have overlap in the middle?\n    else:\n        return best_sam_five, best_sam_three\n\n\n#############################\n#   Get Multi Best Splice   #\n#############################\n# This is a helper function for the splice site finder that takes into account\n# If there are multiple found splice, return the best from the shared sams dict from the two sam lists\ndef get_multi_best_splice(sam_five_list, sam_three_list, consensus, max_mismatches):\n    \"\"\"\n    Goal: given a list of possible splice, return the best one for a junction\n    Arguments:\n        sam_five_list is a list[SAMEntry] for possible 5' cuts\n        sam_three_list is a list[SAMEntry] for possible 3' cuts\n        consensus is a str and the consensus sequence of this junction\n        max_mismatches is the maximum allowed mismatches in total for the 5' and 3' sides\n\n    Returns:\n        a tuple of the (best_5'_sam,best_3'_sam) to then be stored in the junction\n    \"\"\"\n    shared_dict = defaultdict(list)\n    sam_fives = defaultdict(list)\n    sam_threes = defaultdict(list)\n    best_sam_five = SAMEntry()\n    best_sam_five_len = 0\n    best_sam_three = SAMEntry()\n    best_sam_three_len = 0\n\n    # Populate the sam_fives to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 5' mapping\n    for sam_five in sam_five_list:\n        sam_fives[sam_five.read_id].append(sam_five)\n        if len(sam_five.seq) > best_sam_five_len:\n            best_sam_five_len = len(sam_five.seq)\n            best_sam_five = sam_five\n\n    # Populate the sam_threes to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 3' mapping\n    for sam_three in sam_three_list:\n        sam_threes[sam_three.read_id].append(sam_three)\n        if len(sam_three.seq) > best_sam_three_len:\n            best_sam_three_len = len(sam_three.seq)\n            best_sam_three = sam_three\n\n    # Check the id_dict to see if the 5' has a perfect 3' match\n    # Within the perfect match, if there are multi maps choose the one that is closest together\n    # NOTE the internal loop is O(n^2) but n = 10 right now so not too bad\n    for id_key in sam_fives:\n        if id_key in sam_threes:\n            fives = sam_threes[id_key]\n            threes = sam_threes[id_key]\n\n            # For each split index propose the one where the 5' and 3' are the closest\n            # and put this in the shared_dict\n            best_five = fives[0]\n            best_three = threes[0]\n            for five in fives[1:]:\n                for three in threes[1:]:\n                    # If the current best are on different chroms\n                    if best_five.chromosome != best_three.chromosome:\n                        if five.chromosome == three.chromosome:\n                            best_five = five\n                            best_three = three\n\n                    # If the current best are on the same chroms\n                    else:\n                        if five.chromosome == three.chromosome:\n                            if abs(five.start - three.start) < abs(best_five.start - best_three.start):\n                                best_five = five\n                                best_three = three\n\n            shared_dict[id_key] = [best_five, best_three]\n\n    # Now pick out the best sam's to use\n    # If there is at least one shared perfect splice ind find the one w/ least mismatches\n    # then choose the perfect pair that has the least mismatches\n    if len(shared_dict) > 0:\n        best_key = \"\"\n        min_mismatches = max_mismatches + 1\n        for key in shared_dict:\n            sam1, sam2 = shared_dict[key]\n            num_mismatches = sam1.num_mismatches + sam2.num_mismatches\n            if best_key == \"\" or num_mismatches < min_mismatches:\n                best_key = key\n                min_mismatches = num_mismatches\n        best_five_sam, best_three_sam = shared_dict[best_key]\n        return best_five_sam, best_three_sam\n\n    # Otherwise there is a mapping for the left and right pieces, although there is space in between\n    # NOTE is it possible that the best 5' and 3' seqs have overlap in the middle?\n    else:\n        return best_sam_five, best_sam_three\n\n\n##########################\n#   Filter Map Quality   #\n##########################\n# Function to take in Junctions after Splice Ind finding and map pieces right around ind\n# to filter out degenerate or multiple mapping pieces. Currently uses a hard threshold\ndef filter_map_quality(jcts, constants_dict):\n    \"\"\"\n    Goal: Map left and right 25-mers of splice ind and filter out jcts by mapping score\n    Arguments:\n        jcts is a list of type Junction\n        constants dict has all the constants used in the program\n\n    Returns:\n        (pass_jcts,fail_jcts, anom_jcts) is a tuple of \n            (1) list of type Junction of jcts that passed\n            (2) list of type Junction of jcts that failed\n            (3) list of type Junction of jcts that had some other error\n    \"\"\"\n\n    # Add map qualities and only keep those above the cutoff\n    mq_cutoff = constants_dict[\"mq_cutoff\"]\n    mq_len = constants_dict[\"mq_len\"]\n\n    # mqmallg=unique(mallg[(!is.na(match( paste(mallg$junction),paste(mq[mq3+mq5>lower.mq]$junction))))])\n\n    # Write out temp fasta for Bowtie2 calls\n    temp_fasta_name = os.path.join(constants_dict[\"output_dir\"], \"mapq_temp.fasta\")\n    with open(temp_fasta_name, \"w\") as temp_fasta:\n        for ind, jct in enumerate(jcts):\n            seq = jct.consensus\n            don_seq = seq[:jct.splice_ind()][-mq_len:]  # Get the last mq_len bases before splice\n            acc_seq = seq[jct.splice_ind():][:mq_len]  # Get the first mq_len bases after splice\n            temp_fasta.write(\">jct_\" + str(ind) + \"_don\" + \"\\n\" + don_seq + \"\\n\")\n            temp_fasta.write(\">jct_\" + str(ind) + \"_acc\" + \"\\n\" + acc_seq + \"\\n\")\n\n    # Get bowtie2 parameter constants\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n    mq_mapped_name = os.path.join(constants_dict[\"output_dir\"], \"mapq_mapped.sam\")\n\n    # Call bowtie2 to get map qualities\n    with open(mq_mapped_name, \"w\") as mq_mapped:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n             \"-x\", reference, temp_fasta_name], stdout=mq_mapped)\n\n    # Go through the mapped output file\n    pass_jcts = []\n    fail_jcts = []\n    anom_jcts = []\n    with open(mq_mapped_name, \"r\") as mq_mapped:\n        sam_line = mq_mapped.readline()\n\n        while sam_line:\n            # Skip header lines\n            if \"@\" in sam_line:\n                sam_line = mq_mapped.readline()\n                continue\n\n            # Get sam entry 1\n            sam_entry_1 = SAMEntry(sam_line)\n            x, jct_ind_1, don = sam_entry_1.read_id.split(\"_\")\n            jct_ind_1 = int(jct_ind_1)\n\n            # Get sam entry 2\n            sam_line = mq_mapped.readline()\n            sam_entry_2 = SAMEntry(sam_line)\n            if not sam_line:\n                anom_jcts.append(jcts[jct_ind_1])\n                continue\n            x, jct_ind_2, acc = sam_entry_2.read_id.split(\"_\")\n            jct_ind_2 = int(jct_ind_2)\n\n            # Check for different anomalous cases where a don/acc doesn't appear in output\n            # If any anomally is hit we start w/ sam_entry_2 next loop, don't advance\n            if don != \"don\" or acc != \"acc\" or jct_ind_1 != jct_ind_2:\n                anom_jcts.append(jcts[jct_ind_1])\n                continue\n\n            # Otherwise if they are don/acc from the same jct check if they passed mq_cutoff\n            jct_mapq = sam_entry_1.mapping_quality + sam_entry_2.mapping_quality\n            jcts[jct_ind_1].mapq = jct_mapq\n            if jct_mapq > mq_cutoff:\n                pass_jcts.append(jcts[jct_ind_1])\n            else:\n                fail_jcts.append(jcts[jct_ind_1])\n\n            # Move on to the next line\n            sam_line = mq_mapped.readline()\n\n    # Return the passed, failed, and anomalous jcts\n    return (pass_jcts, fail_jcts, anom_jcts)\n\n\n#####################\n#   Generate GTFS   #\n#####################\n# Helper function to generate a list of gtf objects from a gtf path full of gtf files\ndef generate_gtfs(gtf_path, allowed_feature_types=[\"exon\"]):\n    \"\"\"\n    Goal: open all the gtf_files and put all gtf objects in a list from the given path\n    Arguments:\n        gtf_file_name is the full path to the gtf files\n        allowed_feature_types is a list of string specifiying which feature types to add (default 'exon' only)\n\n    Returns:\n        gtfs is a list[GTFEntry]\n    \"\"\"\n    gtfs = []\n    gtf_file_names = [gtf_name for gtf_name in os.listdir(gtf_path) if \"gtf\" in gtf_name]\n    for gtf_file_name in gtf_file_names:\n        abs_gtf_file_path = os.path.join(gtf_path, gtf_file_name)\n        # sys.stdout.write(\"Reading in GTF file \"+abs_gtf_file_path+\"\\n\")\n        with open(abs_gtf_file_path, \"r\") as gtf_file:\n            for gtf_line in gtf_file.readlines():\n                # RB 6/6/17: Try to skip common header lines to avoid parsing error\n                if gtf_line[0] == '#' or gtf_line[0] == '@':\n                    continue\n                gtf = GTFEntry(gtf_line)\n                if gtf.feature in allowed_feature_types:\n                    gtfs.append(gtf)\n\n    sys.stdout.write('Len GTFs: ' + str(len(gtfs)) + '\\n')\n    return gtfs\n\n\n########################\n#   Get JCT GTF info   #\n########################\ndef get_jct_gtf_info(junctions, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs):\n    \"\"\"\n    Goal: for each junction find the closest gtf for donor and acceptor\n    Arguments:\n        junctions is a list[Junction]\n        gtfs is a list[GTF]\n\n    Returns:\n        nothing (just updates the junction objects as pass-by-reference)\n    \"\"\"\n    # Separate the gtfs by chromosome into a dictionary\n\n\n    for junction in junctions:\n        closest_results = find_closest_gtf(junction, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs)\n        if closest_results[\"donor\"] and not junction.best_don_list and not junction.rev_best_don_list:\n            junction.donor_sam.gtf = closest_results[\"donor\"]\n        elif closest_results[\"donor\"] and not junction.rev_best_don_list:\n            for index in range(len(closest_results[\"donor\"])):\n                junction.best_don_list[index].gtf = closest_results[\"donor\"][index]\n        elif closest_results[\"donor\"] and not junction.best_don_list:\n            for index in range(len(closest_results[\"donor\"])):\n                junction.rev_best_don_list[index].gtf = closest_results[\"donor\"][index]\n\n        if closest_results[\"acceptor\"] and not junction.best_acc_list and not junction.rev_best_acc_list:\n            junction.acceptor_sam.gtf = closest_results[\"acceptor\"]\n        elif closest_results[\"acceptor\"] and not junction.rev_best_acc_list:\n            for index in range(len(closest_results[\"acceptor\"])):\n                junction.best_acc_list[index].gtf = closest_results[\"acceptor\"][index]\n        elif closest_results[\"acceptor\"] and not junction.best_acc_list:\n            for index in range(len(closest_results[\"acceptor\"])):\n                junction.rev_best_acc_list[index].gtf = closest_results[\"acceptor\"][index]\n\n\n#################################\n#        Find Closest GTF       #\n#################################\ndef find_closest_gtf(jct, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs):\n    \"\"\"\n    Goal: make it easier to call find closest gtf of donor and acceptor w/out code duplication\n    Arguments:\n        takes in a single junction\n        takes in chrom_gtfs_don which is a dict[\"chrom\":list[GTFEntry]] sorted by donor\n        takes in chrom_gtfs_acc which is a dict[\"chrom\":list[GTFEntry]] sorted by acceptor\n\n    Returns:\n        closest_results which is a dictionary keyed by\n        -> closest_results[\"donor\"] -> GTFEntry\n        -> closest_results[\"acceptor\"] -> GTFEntry\n    \"\"\"\n    closest_results = {\"donor\": None, \"acceptor\": None}\n\n    # Find the closest donor sam gtf\n    if jct.donor_sam.exists and not jct.best_don_list and not jct.rev_best_don_list:\n        query = jct.donor_sam.donor()\n        chrom = jct.donor_sam.chromosome\n        chrom_key = chrom + jct.donor_sam.strand\n        if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(chrom_don_libs[chrom_key])>0 and len(chrom_gtfs_don[chrom_key])>0:\n            gtfs_don = chrom_gtfs_don[chrom_key]\n            don_lib = chrom_don_libs[chrom_key]\n            # closest_don_ind,its = bin_search_gtf(query,don_lib)\n\n            closest_don_ind = brute_search_gtf(query, don_lib)  # <-- RB trying brute force\n            closest_results[\"donor\"] = gtfs_don[closest_don_ind]\n\n    elif jct.donor_sam.exists and not jct.rev_best_don_list:\n        closest_results[\"donor\"] = []\n        for index in range(len(jct.best_don_list)):\n            query = jct.best_don_list[index].donor()\n            chrom = jct.best_don_list[index].chromosome\n            chrom_key = chrom + jct.best_don_list[index].strand\n            if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(chrom_don_libs[chrom_key]) > 0 and len(\n                    chrom_gtfs_don[chrom_key]) > 0:\n                gtfs_don = chrom_gtfs_don[chrom_key]\n                don_lib = chrom_don_libs[chrom_key]\n                closest_don_ind = brute_search_gtf(query, don_lib)\n                closest_results[\"donor\"].append(gtfs_don[closest_don_ind])\n\n    elif jct.donor_sam.exists and not jct.best_don_list:\n        closest_results[\"donor\"] = []\n        for index in range(len(jct.rev_best_don_list)):\n            query = jct.rev_best_don_list[index].donor()\n            chrom = jct.rev_best_don_list[index].chromosome\n            chrom_key = chrom + jct.rev_best_don_list[index].strand\n            if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(\n                    chrom_don_libs[chrom_key]) > 0 and len(\n                    chrom_gtfs_don[chrom_key]) > 0:\n                gtfs_don = chrom_gtfs_don[chrom_key]\n                don_lib = chrom_don_libs[chrom_key]\n                closest_don_ind = brute_search_gtf(query, don_lib)\n                closest_results[\"donor\"].append(gtfs_don[closest_don_ind])\n\n    # Find the closest acceptor sam gtf\n    if jct.acceptor_sam.exists and not jct.best_acc_list and not jct.rev_best_acc_list:\n        query = jct.acceptor_sam.acceptor()\n        chrom = jct.acceptor_sam.chromosome\n        chrom_key = chrom + jct.acceptor_sam.strand\n        if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(chrom_gtfs_acc[chrom_key])>0 and len(chrom_acc_libs[chrom_key])>0:\n            gtfs_acc = chrom_gtfs_acc[chrom_key]\n            acc_lib = chrom_acc_libs[chrom_key]\n            # closest_acc_ind,its = bin_search_gtf(query,acc_lib)\n            closest_acc_ind = brute_search_gtf(query, acc_lib)  # <-- RB trying brute force\n            closest_results[\"acceptor\"] = gtfs_acc[closest_acc_ind]\n    elif jct.acceptor_sam.exists and not jct.rev_best_acc_list:\n        closest_results[\"acceptor\"] = []\n        for index in range(len(jct.best_acc_list)):\n            query = jct.best_acc_list[index].acceptor()\n            chrom = jct.best_acc_list[index].chromosome\n            chrom_key = chrom + jct.best_acc_list[index].strand\n            if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(\n                    chrom_gtfs_acc[chrom_key]) > 0 and len(chrom_acc_libs[chrom_key]) > 0:\n                gtfs_acc = chrom_gtfs_acc[chrom_key]\n                acc_lib = chrom_acc_libs[chrom_key]\n                closest_acc_ind = brute_search_gtf(query, acc_lib)\n                closest_results[\"acceptor\"].append(gtfs_acc[closest_acc_ind])\n\n    elif jct.acceptor_sam.exists and not jct.best_acc_list:\n        closest_results[\"acceptor\"] = []\n        for index in range(len(jct.rev_best_acc_list)):\n            query = jct.rev_best_acc_list[index].acceptor()\n            chrom = jct.rev_best_acc_list[index].chromosome\n            chrom_key = chrom + jct.rev_best_acc_list[index].strand\n            if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(\n                    chrom_gtfs_acc[chrom_key]) > 0 and len(chrom_acc_libs[chrom_key]) > 0:\n                gtfs_acc = chrom_gtfs_acc[chrom_key]\n                acc_lib = chrom_acc_libs[chrom_key]\n                closest_acc_ind = brute_search_gtf(query, acc_lib)\n                closest_results[\"acceptor\"].append(gtfs_acc[closest_acc_ind])\n\n    return closest_results\n\n\n#################################\n#    Binary Search Closest GTF  #\n#################################\n# Recursive binary search function\n# NOTE this could probably be sped up using bisectleft, but I doubt by much\ndef bin_search_gtf(query, library, start_ind=0, end_ind=-1, its=1, disp=False):\n    \"\"\"\n    Goal: do a binary search through the library for the closest ind\n    Arguments:\n        query is an int\n        library is a list[int] of genomic positions to look through\n        start_ind is defaulted to 0 and keeps track of where to look\n        end_ind is defaulted to -1 and keeps track of where to look\n\n    Returns:\n        the index of the closest matching library value to the query\n    \"\"\"\n    # First iteration\n    if its == 1 and end_ind == -1:\n        end_ind = len(library) - 1\n\n    # Base case\n    if end_ind - start_ind <= 1:\n        sys.stdout.flush()\n        start_dist = abs(query - library[start_ind])\n        end_dist = abs(library[end_ind] - query)\n        ret_ind = start_ind if start_dist <= end_dist else end_ind\n        if disp:\n            sys.stdout.write(str(its) + \")\" + \" Found closest to:[\" + library[ret_ind] + \"]\\n\")\n        return ret_ind, its\n    # Recursive case\n    else:\n        mid_ind = (start_ind + end_ind) / 2\n        # Determine whether or not to print this line\n        # (almost never want to except when debugging)\n        if disp:\n            print str(its) + \")\", library[start_ind], \"--\", library[mid_ind], \"--\", library[end_ind]\n\n        # Check to see how to recurse\n        if query < library[mid_ind]:\n            return bin_search_gtf(query, library, start_ind, mid_ind, its + 1, disp=disp)\n        else:\n            return bin_search_gtf(query, library, mid_ind, end_ind, its + 1, disp=disp)\n\n            #####################################\n\n\n# Brute Force Closest GTF        #\n#####################################\ndef brute_search_gtf(query, library):\n    \"\"\"\n    Goal: do brute search through the library for the closest ind\n    Arguments:\n        query is an int\n        library is a list[int] of genomic positions to look through\n\n    Returns:\n        the index of the closest matching library value to the query\n    \"\"\"\n\n    closest_ind = 0\n    closest_dist = abs(library[0] - query)\n    for ind, val in enumerate(library[1:]):\n        if abs(val - query) < closest_dist:\n            closest_ind = ind + 1  # <-- have to add 1 since skipping first ind\n            closest_dist = abs(val - query)\n\n    return closest_ind\n\n\n#####################################\n#         Identify Fusions          #\n#####################################\n# Takes junctions that already have gtf info\n# If a junction has the following properties call it a 'fusion':\n#   IF donor and acceptor sams are at_boundary:\n#       IF donor and acceptor are on different chromosomes\n#           [yes fusion]\n#       ELIF donor and acceptor are on different strands\n#       ELIF distance between donor and acceptor > threshold\n#           [yes fusion]\n#       ELSE\n#           [no fusion]\n#   ELSE:\n#       [no fusion]\n#\n# Returns a list of junctions that are deemed 'fusions'\ndef identify_fusions(junctions):\n    \"\"\"\n    Goal: take the junctions and find the ones that could be fusions\n    Arguments:\n        junctions is a list[Junction] objects\n        span_cutoff is an optional int or float defining min distance for a fusion\n            on the same chromosome\n    Returns:\n        fusion_jcts as a list[Junction] with the junctions defined as fusions\n    \"\"\"\n    #span_cutoff = constants_dict[\"span_cutoff\"]\n    fusion_jcts = []\n    for jct in junctions:\n        fusion_type = jct.get_fusion_type()\n        if \"fusion\" in fusion_type and \"no_fusion\" not in fusion_type:\n            fusion_jcts.append(jct)\n    return fusion_jcts\n\n\n####################\n#   Assign Class   #\n####################\n# Assigns a pair of R1 and R2 to a class based on certain factors. These are both SAMEntry objects.\n# Possible classes. R1 always maps to a denovo jct, and R2 somewhere else.\n# NOTE I currently have no confidence that this function works\n# TODO update the logic to allow 'Fusion' classification\n# TODO use regex to parse the chromosome rather than all this messy splitting (it looks terrible)\n# [1] Linear\n# [2] Linear Anomally\n# [3] Circular\n# [4] Circular Anomally\n# [5] None <-- kind of in the place of fusions for now\ndef assign_class(sam_R1, sam_R2):\n    \"\"\"\n    Goal: take the donor and acceptor sam and categorize them\n    Arguments:\n        sam_R1 is of type SAMEntry\n        sam_R2 is of type SAMEntry\n\n    Returns:\n        a string of the generated type\n    \"\"\"\n    jct_chrom_1 = sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[1]\n    jct_chrom_2 = sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[0]\n\n    # If the jct splices 2 chromosomes together just skip it for now\n    if jct_chrom_1 != jct_chrom_2:\n        return \"None\"\n    # If the R1 and R2 are on different chromosomes just skip it for now\n    if jct_chrom_1 != sam_R2.chromosome:\n        return \"None\"\n\n    span = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[5].split(\":\")[1])\n\n    # Linear case\n    if span > 0:\n        if sam_R1.strand != sam_R2.strand:\n            return \"Linear\"\n        else:\n            return \"Linear_Anomaly\"\n\n    # Circular case\n    else:\n        start_1 = int(sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[3].split(\":\")[1])\n        stop_1 = int(sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[4].split(\":\")[1])\n        start_2 = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[2].split(\":\")[1])\n        stop_2 = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[3].split(\":\")[1])\n        if sam_R1.strand == sam_R2.strand:\n            return \"Circular_Anomaly\"\n        elif start_2 <= sam_R2.start <= stop_1:\n            return \"Circular\"\n        else:\n            return \"Circular_Anomaly\"\n\n\n############################\n#   Write GLM Class File   #\n############################\n# Simple function to print out GLM class file in the right format\n# NOTE I don't think this function currently works\ndef write_glm_class_file(class_file_name, sam_list):\n    \"\"\"\n    Goal: print out a class file for the GLM\n    Arguments:\n        class_file_name is the name of the save file for the GLM\n        sam_list is a list[[SAMEntry,SAMEntry,str,list[string],list[string]],...]\n\n    Returns:\n        nothing (just prints to the file instead)\n    \"\"\"\n    header = \"\"\n    header += \"id\\t\"\n    header += \"class\\t\"\n    header += \"pos\\t\"\n    header += \"qual\\t\"\n    header += \"aScore\\t\"\n    header += \"numN\\t\"\n    header += \"readLen\\t\"\n    header += \"junction\\t\"\n    header += \"strand\\t\"\n    header += \"posR2\\t\"\n    header += \"qualR2\\t\"\n    header += \"aScoreR2\\t\"\n    header += \"numNR2\\t\"\n    header += \"readLenR2\\t\"\n    header += \"junctionR2\\t\"\n    header += \"strandR2\\n\"\n    with open(class_file_name, \"w\") as class_file:\n        class_file.write(header)\n        for read_pair in sam_list:\n            sam_R1, sam_R2, pair_class, sam_R1_genes, sam_R2_genes = read_pair\n\n            # Add general info to the out_line\n            out_line = \"\"\n            out_line += str(sam_R1.read_id.split(\"/\")[0]) + \"\\t\"\n            out_line += str(pair_class) + \"\\t\"\n\n            # Add R1 info to the out_line\n            out_line += str(sam_R1.start) + \"\\t\"\n            out_line += str(sam_R1.mapping_quality) + \"\\t\"\n            out_line += str(sam_R1.alignment_score) + \"\\t\"\n            out_line += str(sam_R1.num_Ns) + \"\\t\"\n            out_line += str(len(sam_R1.seq)) + \"\\t\"\n            out_line += str(sam_R1.junction()) + \"|\" + sam_R1_genes + \"\\t\"\n            out_line += str(sam_R1.strand) + \"\\t\"\n\n            # Add R2 info to the out_line\n            out_line += str(sam_R2.start) + \"\\t\"\n            out_line += str(sam_R2.mapping_quality) + \"\\t\"\n            out_line += str(sam_R2.alignment_score) + \"\\t\"\n            out_line += str(sam_R2.num_Ns) + \"\\t\"\n            out_line += str(len(sam_R2.seq)) + \"\\t\"\n            out_line += str(sam_R2.junction()) + \"|\" + sam_R2_genes + \"\\t\"\n            out_line += str(sam_R2.strand) + \"\\n\"\n\n            # Write the built up out_line to the glm input class file\n            class_file.write(out_line)\n\n\n##################\n#   Write Time   #\n##################\n# Helper function to write out the timing of something\n# Takes in the message, a start time in seconds, and a timer_file_path\n# Appends to the timer file by default, first call should overwrite\ndef write_time(message, start_time, timer_file_path, append=True, uniform_len=70):\n    \"\"\"\n    Goal: write a timed event out to a file\n    Arguments:\n        message is the text of the job to put next to the time (i.e. 'Time to align reads')\n        start_time is the start of the job gotten by time.time()\n        time_file_path is the full path to the timer store file\n        append is a boolean saying whether or not to append to the file vs. overwriting (default append)\n        uniform_len is the max message length to allow aligning the timer output file\n\n    Returns:\n        nothing (just writes to the timer file)\n    \"\"\"\n    seconds_duration = float(time.time() - start_time)\n    minutes_duration = seconds_duration / 60\n    hours_duration = seconds_duration / 3600\n    seconds_str = (\"{:3.2f}\".format(seconds_duration)).rjust(5, \" \")\n    minutes_str = (\"{:3.2f}\".format(minutes_duration)).rjust(5, \" \")\n    hours_str = (\"{:3.2f}\".format(hours_duration)).rjust(5, \" \")\n\n    if len(message) < uniform_len:\n        message += \" \" * (uniform_len - len(message))\n    else:\n        message = message[:uniform_len]\n    time_out_str = message + \":    \"\n    time_out_str += seconds_str + \":seconds    \"\n    time_out_str += minutes_str + \":minutes    \"\n    time_out_str += hours_str + \":hours\\n\"\n    timer_file = open(timer_file_path, \"a\") if append else open(timer_file_path, \"w\")\n    timer_file.write(time_out_str)\n    timer_file.close()\n\n\n##########################\n#   Collapse Junctions   #\n##########################\ndef collapse_junctions(jcts, collapse_thresh, group_out_file_name=None):\n    \"\"\"\n    Goal: take in the junctions and collapse ones at or near the same\n          splice sites\n    Arguments:\n        junctions is a list[Junction] object\n        full_path_name points to the the combined fastq file\n        constants dict is a dictionary of global constants\n\n    Returns:\n        a tuple with the first element as the singles \"uncollapsed list\"\n        and the second being the collapsed list of junctions list[Junction]\n    \"\"\"\n    # Get the collapsing threshold (radius of donor and acceptor to collapse in)\n    #collapse_thresh = constants_dict[\"collapse_thresh\"]\n\n    # Separate the jcts by chromosome pairs to make later O(N^2) less painful\n    # so will have one entry for chr1:chr2, chr1:chr3 etc\n    # it will be combinations, not permutations (chr1:chr2 == chr2:chr1)\n    splices_by_chroms = {}\n    for jct in jcts:\n        chrom_1 = \"chr\" + str(jct.donor_sam.chromosome)\n        chrom_2 = \"chr\" + str(jct.acceptor_sam.chromosome)\n        if chrom_1 + chrom_2 in splices_by_chroms:\n            splices_by_chroms[chrom_1 + chrom_2].append(jct)\n        #elif chrom_2 + chrom_1 in splices_by_chroms:\n        #    splices_by_chroms[chrom_2 + chrom_1].append(jct)\n        else:\n            splices_by_chroms[chrom_1 + chrom_2] = [jct]\n\n    groupings = {}\n    for chroms in splices_by_chroms:\n        groupings[chroms] = []\n        for jct in splices_by_chroms[chroms]:\n            don = jct.donor_sam.donor()\n            acc = jct.acceptor_sam.acceptor()\n            found_prev_group = False\n\n            # Only compare jct to other jcts if both\n            # don and acc are not None\n            if don and acc:\n                for prev_group in groupings[chroms]:\n                    for prev_jct in prev_group:\n                        prev_don = prev_jct.donor_sam.donor()\n                        prev_acc = prev_jct.acceptor_sam.acceptor()\n                        # If any one of the acceptor/donors are None\n                        if not prev_don or not prev_acc:\n                            continue\n                        if abs(don - prev_don) <= collapse_thresh and abs(acc - prev_acc) <= collapse_thresh:\n                            # sys.stderr.write(\"Found match for:\\n\")\n                            # sys.stderr.write(jct.verbose_fasta_string())\n                            prev_group.append(jct)\n                            found_prev_group = True\n                            break\n\n                    # If found a prev_group, don't need to look through\n                    # other prev groups\n                    if found_prev_group:\n                        break\n\n            # If it didn't find any of the prev_groups, start a new group\n            if not found_prev_group:\n                groupings[chroms].append([jct])\n\n    # Separate singles from groups\n    singles = []\n    groups = []\n    group_out_file = None\n    if group_out_file_name:\n        group_out_file = open(group_out_file_name, \"w\")\n\n    for chroms in groupings:\n        for group in groupings[chroms]:\n            if len(group) <= 1:\n                singles += group\n            else:\n                if group_out_file_name:\n                    group_out_file.write(\"Group info:\\n\")\n                    group_out_file.write(\"\".join([m.verbose_fasta_string() for m in group]) + \"\\n\")\n                counts = [len(member.bin_pair_group) for member in group]\n                max_ind = counts.index(max(counts))\n                repr_jct = group[max_ind]\n                repr_jct.collapsed_num = sum(counts)\n                groups.append(repr_jct)\n\n    if group_out_file_name:\n        group_out_file.close()\n\n\n    return singles, groups\n\n\n########################\n#   Badfj3 fusions     #\n########################\ndef badfj3_fusions(junctions, constants_dict):\n    # Bowtie params\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n\n    # Build up file stems\n    badfj3_stem = os.path.join(constants_dict[\"output_dir\"], \"badfj3_\")\n    don_fasta = badfj3_stem + \"don.fasta\"\n    acc_fasta = badfj3_stem + \"acc.fasta\"\n    badfj3_mapped = badfj3_stem + \"mapped.sam\"\n\n    # Open the R1 and R2\n    don_fasta_f = open(don_fasta, \"w\")\n    acc_fasta_f = open(acc_fasta, \"w\")\n\n    # Build up the \"paired end\" files\n    jct_dict = {}\n    for jct in junctions:\n        jct_dict[jct.jct_ind] = jct\n        header = \">\" + str(jct.jct_ind)\n        break_point = jct.splice_ind()\n        don = jct.consensus[:break_point]\n        acc = jct.consensus[break_point:]\n\n        # RB: 5/26/17 Change this to map just the first and last 20 bases\n        # don_fasta_f.write(header+\"\\n\"+don+\"\\n\")\n        # acc_fasta_f.write(header+\"\\n\"+acc+\"\\n\")\n        don_fasta_f.write(header + \"\\n\" + don[:20] + \"\\n\")\n        acc_fasta_f.write(header + \"\\n\" + acc[-20:] + \"\\n\")\n\n    # Close the R1 and R2 fastqs\n    don_fasta_f.close()\n    acc_fasta_f.close()\n\n    badfj3_gap = \"500000\"  # If the don/acc can map within 1/2 Mb, then jct not fusion\n\n    # Run bowtie2 on the R1 and R2\n    with open(badfj3_mapped, \"w\") as badfj3_mapped_f:\n        subprocess.call([\n            \"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", \"--no-mixed\", \"--no-hd\",\n            min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n            \"-x\", reference, \"-X\", badfj3_gap, \"--ff\", \"-1\",\n            don_fasta, \"-2\", acc_fasta\n        ],\n            stdout=badfj3_mapped_f)\n\n    # Read back the sam file\n    flags = [\"paired\", \"proper\", \"no_align\", \"paired_no_align\", \"minus\", \"mate_minus\", \"R1\", \"R2\"]\n    seen_jct_inds = []\n    with open(badfj3_mapped, \"r\") as badfj3_mapped_f:\n        for line in badfj3_mapped_f:\n            # NOTE this is a sloppy way of parsing a PE SAM file (should use samtools view)\n            split_line = line.split('\\t')\n            jct_ind = int(split_line[0])\n            flag = int(split_line[1])\n\n            # Does sloppy binary flag parsing\n            jct_flags = {flags[ind]: bool(int(bit)) for ind, bit in enumerate(format(flag, \"08b\"))}\n\n            # If it didn't align, then just skip it, it can't be a badfj3\n            if jct_flags[\"no_align\"] or jct_flags[\"paired_no_align\"]:\n                continue\n            # If it did align AND it has already been seen this is a badfj3\n            elif jct_ind in seen_jct_inds:\n                jct_dict[jct_ind].badfj3 = True\n            # If it did align but has not already been seen put it in the see_jct_inds\n            else:\n                seen_jct_inds.append(jct_ind)\n\n    return junctions\n\n\n############################\n#   Old Badfj3 fusions     #\n############################\n\"\"\"\ndef badfj3_fusions(fusion_junctions,constants_dict):\n\n    #Bowtie params\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n\n    #Build up file stems\n    badfj3_stem = os.path.join(constants_dict[\"output_dir\"],\"badfj3_\")\n    don_fasta = badfj3_stem+\"don.fasta\"\n    acc_fasta = badfj3_stem+\"acc.fasta\"\n    badfj3_mapped = badfj3_stem+\"mapped.sam\"\n\n    #Open the R1 and R2\n    don_fasta_f = open(don_fasta,\"w\")\n    acc_fasta_f = open(acc_fasta,\"w\")\n\n    #Build up the \"paired end\" files\n    for fusion in fusion_junctions:\n        header = \">\"+str(fusion.jct_ind)+\"\\n\"\n        break_point = fusion.splice_ind()\n        don = fusion.consensus[:break_point]\n        acc = fusion.consensus[break_point:]\n        don_fasta_f.write(header+don+\"\\n\")\n        acc_fasta_f.write(header+acc+\"\\n\")\n\n    #Close the R1 and R2\n    don_fasta_f.close()\n    acc_fasta_f.close()\n\n    badfj3_gap = \"500000\" #If the don/acc can map within 1/2 Mb, then jct not fusion\n\n    #Run bowtie2 on the R1 and R2\n    with open(badfj3_mapped,\"w\") as badfj3_mapped_f:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n             \"-x\", reference, \"-X\", badfj3_gap, \"--ff\", \"-1\", don_fasta, \"-2\", acc_fasta], stdout=badfj3_mapped_f)\n\n\n    still_fusions = []\n    now_jcts = []\n\n    #Read back the sam file\n    with open(badfj3_mapped,\"r\") as badfj3_mapped_f:\n        for line in badfj3_mapped_f:\n            print line #NOTE!!! need to see how PE output looks\n\n    return still_fusions,now_jcts\n\"\"\"\n\n\n##########################\n#   Reverse Compliment   #\n##########################\n# Just a little helper function to give the reverse compliment of a sequence\ndef reverse_compliment(seq):\n    \"\"\"\n    Goal: take a sequence and return the reverse compliment\n    Arguments:\n        seq is a string of A's,T's,C's,G's, and N's\n\n    Returns:\n        the reverse compliment string\n    \"\"\"\n    comp_dict = {\"A\": \"T\",\n                 \"a\": \"t\",\n                 \"T\": \"A\",\n                 \"t\": \"a\",\n                 \"C\": \"G\",\n                 \"c\": \"g\",\n                 \"G\": \"C\",\n                 \"g\": \"c\",\n                 \"N\": \"N\",\n                 \"n\": \"n\"}\n\n    rev_comp_seq = \"\".join([comp_dict[base] for base in seq])[::-1]\n    return rev_comp_seq\n\n\n################################################################\n#   Print out the constants dict for better version tracking   #\n################################################################\ndef write_constants_dict(constants_dict, params_out_name):\n    \"\"\"\n    Goal: print out the constants dict to inform what parameters were used on the run\n    Arguments:\n        constants_dict is a dict keyed by string and valued by numeric or string\n        params_out_name is the file path to store the constants dict info\n    Returns:\n        None, everything is written to the file\n    \"\"\"\n    uniform_len = max([len(str(key)) for key in constants_dict])\n    spaces = \" \" * uniform_len\n\n    with open(params_out_name, \"w\") as params_out:\n        # Header info with date and time\n        params_out.write(\"Parameter file used for SPORK run\\n\")\n        params_out.write(\"\\tDate \" + time.strftime(\"%d/%m/%y\") + \" (day/month/year)\\n\")\n        params_out.write(\"\\tTime \" + time.strftime(\"%H:%M:%S\") + \"\\n\")\n        params_out.write(\"\\nParameters:\\n\")\n        params_out.write(\"-\" * (uniform_len + 4) + \"\\n\")\n\n        # Loop through the parameters printing nicely\n        len_sorted_params = sorted(constants_dict.keys(), key=lambda k: len(k))\n        for param in len_sorted_params:\n            padded_param = param[:uniform_len] + spaces[:uniform_len - len(param)]\n            param_val = str(constants_dict[param])\n            params_out.write(padded_param + \"    :    \" + param_val + \"\\n\")\n\n\n###################################\n#   Track NUP214 as a test case   #\n###################################\ndef follow_nup214(forward_jct, reverse_jct):\n    \"\"\"\n    Goal: check if forward or reverse nup214 makes more sense in terms\n          of donor and acceptor sites\n    Arguments:\n        forward_jct is of type Junction\n        reverse_jct is of type Junction and is the rev-comp of forward_jct\n\n    Returns:\n        nothing, just writes out info to stdout\n    \"\"\"\n    if (forward_jct.donor_sam.str_gene() == \"NUP214\" or\n                forward_jct.acceptor_sam.str_gene() == \"NUP214\" or\n                reverse_jct.donor_sam.str_gene() == \"NUP214\" or\n                reverse_jct.acceptor_sam.str_gene() == \"NUP214\"):\n        sys.stdout.write(\"Found a NUP214\\n\")\n        sys.stdout.write(forward_jct.verbose_fasta_string())\n        sys.stdout.write(str(forward_jct.donor_sam.gtf) + \"\\n\")\n        sys.stdout.write(str(forward_jct.acceptor_sam.gtf) + \"\\n\")\n        sys.stdout.write(reverse_jct.verbose_fasta_string())\n        sys.stdout.write(str(reverse_jct.donor_sam.gtf) + \"\\n\")\n        sys.stdout.write(str(reverse_jct.acceptor_sam.gtf) + \"\\n\")\n        sys.stdout.write(\"Forward dist: \" + str(forward_dist) + \" reverse_dist: \" + str(reverse_dist) + \"\\n\")\n        sys.stdout.write(\"Forward donor gtf span:\" + str(forward_jct.donor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Forward acceptor gtf span:\" + str(forward_jct.acceptor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Reverse donor gtf span:\" + str(reverse_jct.donor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Reverse acceptor gtf span:\" + str(reverse_jct.acceptor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"\\n\")\n        sys.stdout.flush()\n\n\n###################################\n#   Track NUP214 as a test case   #\n###################################\ndef get_seq_complexity(seq):\n    \"\"\"\n    Goal: take in a string and return the sequence complexity. Makes use of zlib to compress\n          the string and see how much compression occurred. If lots of compression, then seq was low complexity\n\n    Arguments:\n        seq is a sequence (or really any string)\n\n    Return:\n        a float for the string complexity between 0 and 1 (0 is least complex, 1 is most)\n    \"\"\"\n    uncompressed = sys.getsizeof(seq)\n    compressed = sys.getsizeof(zlib.compress(seq))\n    compression = float(compressed) / uncompressed  # 0 is worst, 1 is best (visually making 0.675 cutoff)\n    return compression",
                "filename": "SPORK_utils.py"
              },
              {
                "fileContent": "#Class to store GTF entries\n#TODO give this better documentation\n\n#Imports\nimport re\nimport sys\n\nclass GTFEntry(object):\n    __slots__ = [\"chromosome\",\"source\",\"feature\", \"start\",\"stop\",\"score\",\"strand\", \"frame\",\"gene_name\", \"donor\",\"acceptor\",\"span\", \"synonyms\"]\n\n    def __init__(self,gtf_line='chr\\tsrc\\tfeat\\t-1\\t-1\\t-1\\t+\\t0\\tgene_name \"default\";'):\n        \"\"\"\n        Goal: initialize a GTFEntry\n        Arguments:\n            a gtf_line from a standard gtf file, optional, if none given default made\n\n        Returns:\n            nothing\n        \"\"\"\n        split_gtf_line = gtf_line.split(\"\\t\")\n        self.chromosome = split_gtf_line[0]\n        self.source = split_gtf_line[1]\n        self.feature = split_gtf_line[2]\n        self.start = int(split_gtf_line[3])\n        self.stop = int(split_gtf_line[4])\n        self.score = split_gtf_line[5]\n        self.strand = split_gtf_line[6]\n        self.frame = split_gtf_line[7]\n        self.donor = self.stop if self.strand == \"+\" else self.start\n        self.acceptor = self.start if self.strand == \"+\" else self.stop\n        self.span = abs(self.donor-self.acceptor)\n        group_info = split_gtf_line[8]\n        gene_name_pattern = re.compile('gene_name \"(.*?)\";')\n        gene_name = gene_name_pattern.findall(group_info)\n        if len(gene_name) == 0:\n            gene_id_pattern = re.compile('gene_id \"(.*?)\";')\n            gene_name = gene_id_pattern.findall(group_info)\n            if len(gene_name) == 0:\n                sys.stdout.write(\"SPORK ERROR: in gtf init. No found gene_name or gene_id\")\n                sys.stderr.write(\"SPORK ERROR: in gtf init. No found gene_name or gene_id\")\n                sys.exit(1)\n        self.gene_name = gene_name[0]\n        self.synonyms = set()\n    def __str__(self):\n        \"\"\"\n        Goal: yield a string representation of this GTFEntry\n        Arguments:\n            none\n\n        Returns:\n            a string of important info about this GTFEntry\n        \"\"\"\n        ret_str = \"\"\n        ret_str += \"chromosome: \"+self.chromosome+\"\\t\"\n        ret_str += \"name: \"+self.gene_name+\"\\t\"\n        ret_str += \"donor: \"+str(self.donor)+\"\\t\"\n        ret_str += \"accep: \"+str(self.acceptor)+\"\\t\"\n        ret_str += \"strand: \"+self.strand+\"\\t\"\n        ret_str += \"start: \"+str(self.start)+\"\\t\"\n        ret_str += \"stop: \"+str(self.stop)+\"\\t\"\n        return ret_str\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allows comparison between GTFEntries\n        Arguments:\n            other is also a GTFEntry\n\n        Returns:\n            true if self's chromosome is smaller than other's,\n            or if they are shared and self's start position is smaller\n            false otherwise\n        \"\"\"\n        if self.chromosome != other.chromosome:\n            return self.chromosome < other.chromosome\n        else:\n            return self.start < other.start",
                "filename": "SPORK_GTFEntry.py"
              },
              {
                "fileContent": "# Fastq entry class\n\n# Imports\nimport sys\n\n\nclass FastQEntry(object):\n    __slots__ = [\"read_id\", \"seq\", \"plus_line\", \"quality\"]\n  \n    def __init__(self, read_id, seq, plus_line, quality):\n        \"\"\"\n        Goal: initialize the FastQEntry object with the appropriate info\n        Arguments:\n            all of the fastq lines one at a time\n            read_id, seq, plus_line, and quality\n\n        Returns:\n            nothing\n        \"\"\"\n        self.read_id = read_id\n        self.seq = seq\n        self.plus_line = plus_line\n        self.quality = quality\n        self.clean()\n\n    def get_edge_thirds(self, min_third=20):\n        \"\"\"\n        Goal: split this FastQEntry into a 5' and 3' FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            a tuple of FastQEntry objects [5',3']\n        \"\"\"\n        third_len = len(self.seq) / 3\n        if third_len < min_third:\n            # sys.stderr.write(\"Skipping read too short to split in thirds: \"+self.read_id+\"\\n\")\n            return None, None\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[2 * third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[2 * third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def get_first_last_n(self, third_len=36):\n        \"\"\"\n        Goal: very similar to the edge \n        Arguments:\n            optional length of n to take (defaulted at 36)\n\n        Returns:\n            a tuple of 5' and 3' FastQEntry objects\n        \"\"\"\n        # Check to make sure can at least get the first and last third in length\n        if len(self.seq) <= third_len * 2:\n            # sys.stderr.write(\"SPORK: Skipping read too short to split in thirds: \"+self.read_id+\" len = \"+str(len(self.seq))+\"\\n\")\n            return None, None\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[-third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[-third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def clean(self):\n        \"\"\"\n        Goal: clean up the read id, sequence, plus line, and quality\n        Arguments:\n            none\n\n        Returns:\n            nothing\n        \"\"\"\n        # self.read_id = self.read_id.replace(\" \",\"_\").replace(\"\\t\",\"_\").replace(\"\\n\",\"\")\n        self.read_id = self.read_id.replace(\"\\n\", \"\")\n        self.seq = self.seq.replace(\"U\", \"T\").replace(\"\\n\", \"\")\n        self.plus_line = self.plus_line.replace(\" \", \"_\").replace(\"\\n\", \"\")\n        self.quality = self.quality.replace(\"\\n\", \"\")\n\n    def __str__(self):\n        \"\"\"\n        Goal: return an easy to print string of a FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            An output string\n        \"\"\"\n        ret_str = \"\"\n        ret_str += self.read_id + \"\\n\"\n        ret_str += self.seq + \"\\n\"\n        ret_str += self.plus_line + \"\\n\"\n        ret_str += self.quality + \"\\n\"\n        return ret_str\n\n    def __lt__(self, other):\n        \"\"\"\n        Goal: allow comparison between two FastQEntry objects based on read_id\n        Arguments:\n            other is a FastQEntry to compare to\n\n        Returns:\n            True if the read id of this object is 'less' than that of the other\n        \"\"\"\n        return self.read_id < other.read_id",
                "filename": "SPORK_FastQEntry.py"
              },
              {
                "fileContent": "# Identified junction class\n\n# Imports\nfrom SPORK_SAMEntry import SAMEntry\nimport copy\nimport sys\nimport itertools\nfrom scipy.stats import chisquare\n\n\n# Junction class\nclass Junction(object):\n    __slots__ = [\"consensus\", \"score\", \"bin_pair\", \"bin_pair_group\", \"took_reverse_compliment\", \"constants_dict\",\n                 \"badfj3\", \"donor_sam\", \"acceptor_sam\", \"mapq\", \"jct_ind\", \"best_don_list\", \"best_acc_list\",\n                 \"rev_best_don_list\", \"rev_best_acc_list\", \"is_at_boundary\", \"uniformity_score\", \"collapsed_num\"]\n\n    def __init__(self, consensus, score, bin_pair_group, jct_ind, took_reverse_compliment, constants_dict):\n        \"\"\"\n        Goal: Initialization function of junction\n        Arguments:\n            consensus                -- str\n            score                    -- float\n            bin_pair_group           -- list[bin_pair]\n            took_reverse_coompliment -- bool\n            constants_dict           -- dict[str->multiple types]\n\n        Returns:\n            nothing\n        \"\"\"\n        # Read in arguments\n        self.consensus = consensus\n        self.score = score\n        self.bin_pair_group = bin_pair_group\n        self.jct_ind = jct_ind\n        self.took_reverse_compliment = took_reverse_compliment\n        self.constants_dict = constants_dict\n        self.mapq = 0\n        self.badfj3 = False\n\n        # Find chromosome, bin_pair and strand info from the first mapped read\n        rep_bin_pair = self.bin_pair_group[0]\n        self.bin_pair = rep_bin_pair.bin_pair\n        self.donor_sam = SAMEntry()\n        self.acceptor_sam = SAMEntry()\n\n        # Get some information for the donor sam from the five_prime sam of the bin pair\n        self.donor_sam.chromosome = rep_bin_pair.five_prime_chr\n        self.donor_sam.start = rep_bin_pair.five_prime_SAM.start\n        self.donor_sam.stop = rep_bin_pair.five_prime_SAM.stop\n\n        # Get some information for the acceptor sam from the three_prime sam of the bin pair\n        self.acceptor_sam.chromosome = rep_bin_pair.three_prime_chr\n        self.acceptor_sam.start = rep_bin_pair.three_prime_SAM.start\n        self.acceptor_sam.stop = rep_bin_pair.three_prime_SAM.stop\n\n        self.best_don_list = None\n        self.best_acc_list = None\n        self.rev_best_don_list = None\n        self.rev_best_acc_list = None\n        self.uniformity_score = [-1, 1]\n\n        bin_size = constants_dict[\"bin_size\"]\n        three_prime_loc = [0] * bin_size\n        five_prime_loc = [0] * bin_size\n\n        for bin_pair in bin_pair_group:\n            three_prime_loc[bin_pair.three_prime_SAM.start % bin_size] += 1\n            five_prime_loc[bin_pair.five_prime_SAM.start % bin_size] += 1\n\n        self.uniformity_score = [round(chisquare(three_prime_loc)[1], 5), round(chisquare(five_prime_loc)[1], 5)]\n        self.collapsed_num = 0\n        self.is_at_boundary = False\n\n    # Use the sam's to find the splice index in reference to the concensus\n    def splice_ind(self):\n        \"\"\"\n        Goal: Get the splice site in consensus coordinates [0,len(consensus)-1]\n        Arguments:\n            none\n\n        Returns:\n            the 3' edge of the donor sequence if both sams are defined\n            otherwise returns the middle index of the consensus as a guess\n        \"\"\"\n\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            # NOTE currently doesn't handle gaps well (just returns the donor side index of gap)\n            # comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n            #        \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n            #        \"N\": \"N\", \"n\": \"n\"}\n            acc_seq = self.acceptor_sam.seq\n            # if (self.acceptor_sam.strand == \"-\" and not self.took_reverse_compliment) or (self.acceptor_sam.strand == \"+\" and self.took_reverse_compliment):\n            #    acc_seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n            return self.consensus.find(acc_seq)\n\n        else:\n            return len(self.consensus) / 2\n\n    # Use the sam's again to find the size of the gap between the two pieces\n    def splice_gap(self):\n        \"\"\"\n        Goal: Find the distance between the donor and acceptor splice sites\n              in consensus coordinates [0,len(consensus)-1]\n        Arguments:\n            none\n\n        Returns:\n            the distance between the 3' end of the donor and 5' end of the acceptor\n            if one or both of the sam's are undefined return None\n        \"\"\"\n        # if self.donor_sam.exists and self.acceptor_sam.exists:\n        # RB 5/26/17: Having strange index errors, I think going by lengths is equivalent\n        #    return len(self.consensus) - len(self.donor_sam.seq) - len(self.acceptor_sam.seq)\n\n        # sys.stderr.write(self.consensus+':  '+self.donor_sam.seq+'\\n')\n        # donor_pos = self.consensus.index(self.donor_sam.seq)+len(self.donor_sam.seq)\n        # sys.stderr.write(self.consensus+':  '+self.acceptor_sam.seq+'\\n')\n        # acceptor_pos = self.consensus.index(self.acceptor_sam.seq)\n        # return donor_pos-acceptor_pos\n        # else:\n        #    return None\n        return 0\n\n    # Use the sam's again to find the size of the gap between the two pieces\n    def span(self):\n        \"\"\"\n        Goal: find the genomic span between the sams\n        Arguments:\n            none\n\n        Returns:\n            if both exist subtract the donor and acceptor sites\n            this distance will always be positive\n            if one or both don't exist just return -1\n        \"\"\"\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            span = self.donor_sam.donor() - self.acceptor_sam.acceptor()\n            return abs(span)\n        else:\n            return -1\n\n    # Give a name to the splice type for this junction\n    def splice_type(self):\n        \"\"\"\n        Goal: get the type of splice this junction represents\n        Arguments:\n            none\n\n        Returns:\n            \"Full\" if both sams exist and have zero gaps in the split\n            \"Gapped\" if both sams exist but there is space in the middle\n            \"Five_Only\" if only the donor sam exists\n            \"Three_Only\" if only the acceptor sam exists\n            \"None\" if niether sam exists\n        \"\"\"\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            if self.splice_gap() == 0:\n                return \"Full\"\n            else:\n                return \"Gapped\"\n        elif self.donor_sam.exists:\n            return \"Five_Only\"\n        elif self.acceptor_sam.exists:\n            return \"Three_Only\"\n        else:\n            return \"None\"\n\n    # Check to see if this jct represents a fusion\n    def get_fusion_type(self, span_cutoff=1e5):\n        \"\"\"\n        Goal: check if this junction represents a fusion\n        Arguments:\n            none\n\n        Returns:\n            bool of whether or not the donor and acceptor have different genes\n            if one or more don't exists then return False\n        \"\"\"\n        anonat = \"\"  # Can be 'bot', 'donor', 'acceptor', or 'none'\n        chroms = \"\"  # Can be 'interchrom', 'distant-intrachrom', or 'local-intrachrom'\n        strand = \"\"  # Can be 'inversion', 'plus', or 'minus'\n        revreg = \"\"  # Can be 'rev', 'reg', or 'invert'\n\n        # Get the anonat type\n        if self.at_boundary(\"donor\") and self.at_boundary(\"acceptor\"):\n            anonat = \"both\"\n        elif self.at_boundary(\"donor\"):\n            anonat = \"donor\"\n        elif self.at_boundary(\"acceptor\"):\n            anonat = \"acceptor\"\n        else:\n            anonat = \"niether\"\n\n        # Get the strand type\n        if self.donor_sam.strand != self.acceptor_sam.strand:\n            strand = \"inversion\"\n        elif self.donor_sam.strand == \"+\":\n            strand = \"plus\"\n        elif self.donor_sam.strand == \"-\":\n            strand = \"minus\"\n\n        # Get the chromosomes type\n        if self.donor_sam.chromosome != self.acceptor_sam.chromosome:\n            chroms = \"interchrom\"\n        elif strand == \"inversion\":\n            chroms = \"inversion-intrachrom\"\n        elif self.span() >= span_cutoff:\n            chroms = \"distant-intrachrom\"\n        else:\n            chroms = \"local-intrachrom\"\n\n        # Get the revreg type\n        if strand == \"inversion\":\n            revreg = \"invert\"\n        elif self.donor_sam.donor() < self.acceptor_sam.acceptor() and self.donor_sam.strand == \"+\":\n            revreg = \"reg\"\n        elif self.donor_sam.donor() > self.acceptor_sam.acceptor() and self.donor_sam.strand == \"-\":\n            revreg = \"reg\"\n        else:\n            revreg = \"rev\"\n\n        # Should this be considered a fusion?\n        fusion = \"no_fusion\"\n\n        if anonat == \"both\":\n            if self.splice_gap() != None and abs(self.splice_gap()) <= self.constants_dict[\"fusion_max_gap\"]:\n                #if chroms != \"local-intrachrom\":\n                #    fusion = \"fusion\"\n                fusion = \"fusion\"\n\n        # Concatenate them into one string\n        fusion_type = fusion + \"-\" + anonat + \"_\" + chroms + \"_\" + strand + \"_\" + revreg\n        return fusion_type\n\n    # Get distance to closest splice boundary\n    def boundary_dist(self, splice_site, bowtie_style=True):\n        \"\"\"\n        Goal: get the distance of the specified splice site from the closest exon\n        Arguments:\n            splice_site which is a string and can be either \"donor\" or \"acceptor\"\n            bowtie_style is an optional boolean argument\n                if True (default), then if a donor/acceptor falls to the 'right' of the gtf-site,\n                regardless of strand, it will be a positive distance\n\n                if False, then the strand does matter, and being 5' of gtf is negative and 3' is positive\n\n\n        Returns:\n            the distance to the closest gtf of the specified splice_site\n            the distance being positive or negative means different things based on the bowtie_style parameter\n            explained above\n        \"\"\"\n        # If donor distance is requested\n        if splice_site == \"donor\" and self.donor_sam.gtf:\n            donor_dist = 0\n            if not bowtie_style:\n                if self.donor_sam.strand == \"+\":\n                    donor_dist = self.donor_sam.donor() - self.donor_sam.gtf.donor\n                elif self.donor_sam.strand == \"-\":\n                    donor_dist = self.donor_sam.gtf.donor - self.donor_sam.donor()\n                else:\n                    sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect strand option \\n\")\n                    sys.exit(1)\n            elif bowtie_style:\n                donor_dist = self.donor_sam.donor() - self.donor_sam.gtf.donor\n\n            return donor_dist\n\n        # If acceptor distance is requested\n        elif splice_site == \"acceptor\" and self.acceptor_sam.gtf:\n            acceptor_dist = 0\n            if not bowtie_style:\n                if self.acceptor_sam.strand == \"+\":\n                    acceptor_dist = self.acceptor_sam.acceptor() - self.acceptor_sam.gtf.acceptor\n                elif self.acceptor_sam.strand == \"-\":\n                    acceptor_dist = self.acceptor_sam.gtf.acceptor - self.acceptor_sam.acceptor()\n                else:\n                    sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect strand option \\n\")\n                    sys.exit(1)\n            elif bowtie_style:\n                acceptor_dist = self.acceptor_sam.acceptor() - self.acceptor_sam.gtf.acceptor\n\n            return acceptor_dist\n\n        # If a different string was passed in or the specified gtf doesn't exist\n        else:\n            sys.stderr.write(str(self) + '\\n')\n            sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect str or gtf doesn't exist\\n\")\n            sys.exit(1)\n\n    # Return whether or not an donor and acceptor is at a boundary\n    def at_boundary(self, splice_site):\n        \"\"\"\n        Goal: check to see if the specified sam is at an exon boundary\n        Arguments:\n            splice_site of type string. should be \"donor\" or \"acceptor\"\n            to specify which sam to check\n\n            radius is optional and signifies the maximum distance from\n            an exon boundary to consider a sam. Default is 3\n\n        Returns:\n            a boolean of whether or not the specified sam is within\n            'radius' distance of any exon boundary\n        \"\"\"\n        dist = self.boundary_dist(splice_site)\n        if abs(dist) <= self.constants_dict[\"at_boundary_cutoff\"]:\n            return True\n        else:\n            return False\n\n    # Returns whether or not this junction is linear\n    def linear(self):\n        \"\"\"\n        Goal: check to see if this junction in linear\n        Arguments:\n            none\n\n        Returns:\n            a boolean of whether the junction is linear or not\n        \"\"\"\n        five_prime_bin, three_prime_bin, strand_info = self.bin_pair.split(\"_\")\n        five_prime_chr = five_prime_bin.split(\":\")[0]\n        five_prime_bin = five_prime_bin.split(\":\")[1]\n        three_prime_chr = three_prime_bin.split(\":\")[0]\n        three_prime_bin = three_prime_bin.split(\":\")[1]\n        linear = True if int(five_prime_bin) <= int(three_prime_bin) else False\n        # RB 04/25/17: I'm not sure this is correct, took_reverse_compliment is always False\n        linear = not linear if self.took_reverse_compliment else linear\n        return linear\n\n    # Returns this junction and a reverse compliment of this junction\n    # to facilitate finding the gtf's of each and seeing which form is better\n    def yield_forward_and_reverse(self):\n        \"\"\"\n        Goal: return a copy of self and a reverse compliment of self\n        Arguments:\n            none\n\n        Returns:\n            a tuple of Junction where the first entry is self and the\n            second is a reverse compliment of self\n        \"\"\"\n        # sys.stdout.write(\"Before copy in yield_forward_and_reverse\\n\")\n        rev_self = Junction(self.consensus, self.score, self.bin_pair_group, self.jct_ind, self.took_reverse_compliment,\n                            self.constants_dict)\n        # rev_self = copy.deepcopy(self)\n        # sys.stdout.write(\"After copy in yield_forward_and_reverse\\n\")\n        rev_self.took_reverse_compliment = not rev_self.took_reverse_compliment\n\n        comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n                \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n                \"N\": \"N\", \"n\": \"n\"}\n\n        # Take the reverse compliments of the seqs and switch them between donor and acceptor\n        rev_self.consensus = \"\".join([comp[base] for base in self.consensus])[::-1]\n        rev_self.donor_sam.seq = \"\".join([comp[base] for base in self.donor_sam.seq])[::-1]\n        rev_self.acceptor_sam.seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n        rev_self.donor_sam.seq, rev_self.acceptor_sam.seq = rev_self.acceptor_sam.seq, rev_self.donor_sam.seq\n\n        rev_self.donor_sam.strand = \"-\" if self.acceptor_sam.strand == \"+\" else \"+\"\n        rev_self.acceptor_sam.strand = \"-\" if self.donor_sam.strand == \"+\" else \"+\"\n\n        rev_self.donor_sam.start, rev_self.acceptor_sam.start = self.acceptor_sam.start, self.donor_sam.start\n        rev_self.donor_sam.stop, rev_self.acceptor_sam.stop = self.acceptor_sam.stop, self.donor_sam.stop\n\n        rev_self.donor_sam.md, rev_self.acceptor_sam.md = self.acceptor_sam.md, self.donor_sam.md\n\n        rev_self.donor_sam.chromosome, rev_self.acceptor_sam.chromosome = self.acceptor_sam.chromosome, self.donor_sam.chromosome\n        rev_self.donor_sam.exists = True\n        rev_self.acceptor_sam.exists = True\n\n        if self.best_don_list:\n            rev_self.rev_best_don_list = []\n            rev_self.rev_best_acc_list = []\n            for index in range(len(self.best_don_list)):\n                rev_don = copy.deepcopy(self.best_don_list[index])\n                rev_acc = copy.deepcopy(self.best_acc_list[index])\n\n                rev_don.seq = \"\".join([comp[base] for base in self.best_acc_list[index].seq])[::-1]\n                rev_acc.seq = \"\".join([comp[base] for base in self.best_don_list[index].seq])[::-1]\n\n                rev_don.strand = \"-\" if self.best_acc_list[index].strand == \"+\" else \"+\"\n                rev_acc.strand = \"-\" if self.best_don_list[index].strand == \"+\" else \"+\"\n\n                rev_don.md = self.best_acc_list[index].md\n                rev_acc.md = self.best_don_list[index].md\n\n                rev_don.start = self.best_acc_list[index].start\n                rev_acc.start = self.best_don_list[index].start\n\n                rev_don.stop = self.best_acc_list[index].stop\n                rev_acc.stop = self.best_don_list[index].stop\n\n                rev_don.chromosome = self.best_acc_list[index].chromosome\n                rev_acc.chromosome = self.best_don_list[index].chromosome\n\n                rev_self.rev_best_don_list.append(rev_don)\n                rev_self.rev_best_acc_list.append(rev_acc)\n\n        return self, rev_self\n\n    # Returns this junction and a reverse compliment of this junction\n    # to facilitate finding the gtf's of each and seeing which form is better\n    def yield_reverse(self):\n        \"\"\"\n        Goal: return a reversed self\n        Arguments:\n            none\n\n        Returns:\n            a Junction which is the reverse of self (note does change original)\n        \"\"\"\n        self.took_reverse_compliment = not self.took_reverse_compliment\n\n        comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n                \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n                \"N\": \"N\", \"n\": \"n\"}\n\n        # Take the reverse compliments of the seqs and switch them between donor and acceptor\n        self.consensus = \"\".join([comp[base] for base in self.consensus])[::-1]\n        self.donor_sam.seq = \"\".join([comp[base] for base in self.donor_sam.seq])[::-1]\n        self.acceptor_sam.seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n        self.donor_sam.seq, self.acceptor_sam.seq = self.acceptor_sam.seq, self.donor_sam.seq\n\n        # Flip the strands of both SAMs\n        # NOTE only switch the strands if both are + or -, don't do it otherwise\n        # Interesting that it works this way, but I drew it out and I'm confident\n        if self.donor_sam.strand == self.acceptor_sam.strand:\n            self.donor_sam.strand = \"-\" if self.donor_sam.strand == \"+\" else \"+\"\n            self.acceptor_sam.strand = \"-\" if self.acceptor_sam.strand == \"+\" else \"+\"\n\n        # Trade starts and stops of donor and acceptor and chromosome\n        self.donor_sam.start, self.acceptor_sam.start = self.acceptor_sam.start, self.donor_sam.start\n        self.donor_sam.stop, self.acceptor_sam.stop = self.acceptor_sam.stop, self.donor_sam.stop\n        self.donor_sam.chromosome, self.acceptor_sam.chromosome = self.acceptor_sam.chromosome, self.donor_sam.chromosome\n\n        return self\n\n    # Format the junction for MACHETE in fasta form\n    # NOTE only call this function on 'fusion' identified junctions\n    def fasta_MACHETE(self):\n        \"\"\"\n        Goal: produce a fasta_string for MACHETE\n        Arguments:\n            none\n        Returns:\n            a fasta formatted string (with a newline between header and sequence)\n        \"\"\"\n        # Make the necessary variables\n        chrom1 = self.donor_sam.chromosome\n        chrom2 = self.acceptor_sam.chromosome\n        genes1 = self.donor_sam.str_gene()\n        genes2 = self.acceptor_sam.str_gene()\n        pos1 = self.donor_sam.donor()\n        pos2 = self.acceptor_sam.acceptor()\n        strand1 = self.donor_sam.strand\n        strand2 = self.acceptor_sam.strand\n        fusion_type = self.get_fusion_type()\n\n        # Start building the fasta string\n        fasta_str = \"\"\n        fasta_str += \">\"\n        fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n        fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n        fasta_str += fusion_type\n        fasta_str += \",num=\" + str(len(self.bin_pair_group))\n        fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n        fasta_str += \",score=\" + str(self.score)\n        fasta_str += \",gap=\" + str(self.splice_gap())\n        fasta_str += \",break-point=\" + str(self.splice_ind())\n        fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(self.uniformity_score[1]) + \")\"\n        fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n        fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n        fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n        fasta_str += \",mapq=\" + str(self.mapq)\n        fasta_str += \",badfj3:\" + str(self.badfj3)\n        fasta_str += \",jct_ind=\" + str(self.jct_ind)\n        fasta_str += \"\\n\"\n\n        # Add the actual padded consensus to the output string\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n\n        return fasta_str\n\n    def fasta_header(self):\n        \"\"\"\n        Goal: produce a fasta_string for MACHETE\n        Arguments:\n            none\n        Returns:\n            a fasta formatted string (with a newline between header and sequence)\n        \"\"\"\n        # Make the necessary variables\n        chrom1 = self.donor_sam.chromosome\n        chrom2 = self.acceptor_sam.chromosome\n        genes1 = self.donor_sam.str_gene()\n        genes2 = self.acceptor_sam.str_gene()\n        pos1 = self.donor_sam.donor()\n        pos2 = self.acceptor_sam.acceptor()\n        strand1 = self.donor_sam.strand\n        strand2 = self.acceptor_sam.strand\n        fusion_type = self.get_fusion_type()\n\n        # Start building the fasta string\n        fasta_str = \"\"\n        fasta_str += \">\"\n        fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n        fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n        fasta_str += fusion_type\n        fasta_str += \",num=\" + str(len(self.bin_pair_group))\n        fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n        fasta_str += \",score=\" + str(self.score)\n        fasta_str += \",gap=\" + str(self.splice_gap())\n        fasta_str += \",break-point=\" + str(self.splice_ind())\n        fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n            self.uniformity_score[1]) + \")\"\n        fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n        fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n        fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n        fasta_str += \",mapq=\" + str(self.mapq)\n        fasta_str += \",badfj3:\" + str(self.badfj3)\n        fasta_str += \",jct_ind=\" + str(self.jct_ind)\n\n        return fasta_str\n\n    # Format the junction to print in fasta-esque form\n    def log_string(self):\n        \"\"\"\n        Goal: produce a fasta_string\n        Arguments:\n            optionally include a junction index.\n            if it is included, it will be printed out\n\n        Returns:\n            a description of the junction over multiple lines\n        \"\"\"\n        fasta_str = \"\"\n        fasta_str += \">|\" + str(self.donor_sam.chromosome) + \"|\"\n        fasta_str += str(self.donor_sam.str_gene()) + \" \"\n        fasta_str += str(self.donor_sam.gene_strand()) + \" strand|\"\n        fasta_str += str(self.donor_sam.start) + \"-\"\n        fasta_str += str(self.donor_sam.stop) + \"|\"\n        fasta_str += \"strand1:\" + str(self.donor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist1:\" + str(self.boundary_dist(\"donor\")) + \"|\"\n        fasta_str += \"at_boundary1:\" + str(self.at_boundary(\"donor\")) + \"|\\n\"\n\n        fasta_str += \">|\" + str(self.acceptor_sam.chromosome) + \"|\"\n        fasta_str += str(self.acceptor_sam.str_gene()) + \" \"\n        fasta_str += str(self.acceptor_sam.gene_strand()) + \" strand|\"\n        fasta_str += str(self.acceptor_sam.start) + \"-\"\n        fasta_str += str(self.acceptor_sam.stop) + \"|\"\n        fasta_str += \"strand2:\" + str(self.acceptor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist2:\" + str(self.boundary_dist(\"acceptor\")) + \"|\"\n        fasta_str += \"at_boundary2:\" + str(self.at_boundary(\"acceptor\")) + \"|\\n\"\n\n        fasta_str += \">|splice:\" + str(self.splice_ind()) + \"|\"\n        fasta_str += \"score:\" + str(self.score) + \"|\"\n        fasta_str += \"fusion:\" + str(self.get_fusion_type()) + \"|\"\n        fasta_str += \"num:\" + str(len(self.bin_pair_group)) + \"|\"\n        fasta_str += \"splice:\" + str(self.splice_type()) + \"|\"\n        fasta_str += \"mapq=\" + str(self.mapq) + \"|\"\n        fasta_str += \"badfj3:\" + str(self.badfj3) + \"|\"\n        fasta_str += \"jct_ind:\" + str(self.jct_ind) + \"|\\n\"\n\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n        fasta_str += str(self.donor_sam.seq) + \"\\n\"\n        fasta_str += \" \" * self.splice_ind() + str(self.acceptor_sam.seq) + \"\\n\"\n\n        # Also printing out gtf information\n        # fasta_str += \"Donor_gtf:\"+str(self.donor_sam.gtf)+\"\\n\"\n        # fasta_str += \"Acceptor_gtf:\"+str(self.acceptor_sam.gtf)+\"\\n\"\n        return fasta_str\n\n    # Format the junction to print in fasta form\n    def verbose_fasta_string(self):\n        \"\"\"\n        Goal: produce a fasta formatted string of this junction with lots of header info\n        Arguments:\n            none\n\n        Returns:\n            a fasta string (with a newline between the header and sequence)\n        \"\"\"\n        fasta_str = \"\"\n        fasta_str += \">|chromosome1:\" + str(self.donor_sam.chromosome) + \"|\"\n        fasta_str += \"genes1:\" + str(self.donor_sam.str_gene()) + \"|\"\n        fasta_str += \"start1:\" + str(self.donor_sam.start) + \"|\"\n        fasta_str += \"stop1:\" + str(self.donor_sam.stop) + \"|\"\n        fasta_str += \"strand1:\" + str(self.donor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist1:\" + str(self.boundary_dist(\"donor\")) + \"|\"\n        fasta_str += \"at_boundary1:\" + str(self.at_boundary(\"donor\")) + \"|_\"\n\n        fasta_str += \"|chromosome2:\" + str(self.acceptor_sam.chromosome) + \"|\"\n        fasta_str += \"genes2:\" + str(self.acceptor_sam.str_gene()) + \"|\"\n        fasta_str += \"start2:\" + str(self.acceptor_sam.start) + \"|\"\n        fasta_str += \"stop2:\" + str(self.acceptor_sam.stop) + \"|\"\n        fasta_str += \"strand2:\" + str(self.acceptor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist2:\" + str(self.boundary_dist(\"acceptor\")) + \"|\"\n        fasta_str += \"at_boundary2:\" + str(self.at_boundary(\"acceptor\")) + \"|_|\"\n\n        fasta_str += \"jct_ind:\" + str(self.jct_ind) + \"|\"\n        fasta_str += \"splice:\" + str(self.splice_ind()) + \"|\"\n        fasta_str += \"span:\" + str(self.span()) + \"|\"\n        fasta_str += \"score:\" + str(self.score) + \"|\"\n        fasta_str += \"fusion:\" + str(self.get_fusion_type()) + \"|\"\n        fasta_str += \"num:\" + str(len(self.bin_pair_group)) + \"|\"\n        fasta_str += \"splice-gap:\" + str(self.splice_gap()) + \"|\"\n        fasta_str += \"splice-type:\" + str(self.splice_type()) + \"|\"\n        fasta_str += \"badfj3:\" + str(self.badfj3) + \"|\"\n        fasta_str += \"took-rev-comp:\" + str(self.took_reverse_compliment) + \"|\\n\"\n\n        # Add N padding to the consensus to get a uniform len\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n        return fasta_str\n\n    # Add N padding to the consensus to get a uniform len\n    # With the splice site in the middle\n    def format_consensus(self, splice_flank_len):\n        \"\"\"\n        Goal: return the consensus properly formatted centered and uniform len\n        Arguments:\n            splice_flank_len is an int deciding how long either side should be\n            from the consensus\n        Returns:\n            a string of either the full consensus of None if there is no splice ind\n        \"\"\"\n        full_consensus = None\n        if self.splice_ind() != -1:\n            splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n            left_padding = \"N\" * (splice_flank_len - self.splice_ind())\n            right_padding = \"N\" * (splice_flank_len - (len(self.consensus) - self.splice_ind()))\n            if self.splice_ind() <= splice_flank_len:\n                five_consensus = self.consensus[:self.splice_ind()]\n            else:\n                five_consensus = self.consensus[self.splice_ind() - splice_flank_len:self.splice_ind()]\n            if self.splice_ind() + splice_flank_len >= len(self.consensus):\n                three_consensus = self.consensus[self.splice_ind():]\n            else:\n                three_consensus = self.consensus[self.splice_ind():self.splice_ind() + splice_flank_len]\n            full_consensus = left_padding + five_consensus + three_consensus + right_padding\n        return str(full_consensus)\n\n    # Give back the R1 readIDs used to make this junction\n    def get_read_ids(self):\n        \"\"\"\n        Goal: return a list of the read ids (strings) that made this junction\n        Arguments:\n            none\n        Returns:\n            a list[string] of the read-ids for this junction\n        \"\"\"\n        read_ids = []\n        for bin_pair in self.bin_pair_group:\n            donor_id = bin_pair.five_prime_SAM.read_id.replace(\"/5_prime\", \"\")\n            acceptor_id = bin_pair.five_prime_SAM.read_id.replace(\"/3_prime\", \"\")\n            if donor_id == acceptor_id:\n                read_ids.append(donor_id)\n            else:\n                sys.stderr.write(\"SPORK ERROR, nonmatching ids in jct: [\" + donor_id + \"] vs [\" + acceptor_id + \"]\\n\")\n                sys.exit(1)\n\n        return read_ids\n\n    def add_duplicates(self, duplicate_junctions):\n\n        if self.donor_sam.gtf.synonyms or self.acceptor_sam.gtf.synonyms:\n            chrom1 = self.donor_sam.chromosome\n            chrom2 = self.acceptor_sam.chromosome\n            genes1 = self.donor_sam.str_gene()\n            genes2 = self.acceptor_sam.str_gene()\n            pos1 = self.donor_sam.donor()\n            pos2 = self.acceptor_sam.acceptor()\n            strand1 = self.donor_sam.strand\n            strand2 = self.acceptor_sam.strand\n            fusion_type = self.get_fusion_type()\n\n            # Start building the fasta string\n            fasta_str_org = \"\"\n            fasta_str_org += \">\"\n            fasta_str_org += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n            fasta_str_org += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n            fasta_str_org += fusion_type\n            fasta_str_org += \",num=\" + str(len(self.bin_pair_group))\n            fasta_str_org += \",collapsed_num=\" + str(self.collapsed_num)\n            fasta_str_org += \",score=\" + str(self.score)\n            fasta_str_org += \",gap=\" + str(self.splice_gap())\n            fasta_str_org += \",break-point=\" + str(self.splice_ind())\n            fasta_str_org += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                self.uniformity_score[1]) + \")\"\n            fasta_str_org += \",at_boundary=\" + str(self.is_at_boundary)\n            fasta_str_org += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n            fasta_str_org += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n            fasta_str_org += \",mapq=\" + str(self.mapq)\n            fasta_str_org += \",badfj3:\" + str(self.badfj3)\n            fasta_str_org += \",jct_ind=\" + str(self.jct_ind)\n            fasta_str_org += \"\\n\"\n            if self.donor_sam.gtf.synonyms and self.acceptor_sam.gtf.synonyms:\n                for genes1, genes2 in itertools.product(self.donor_sam.gtf.synonyms, self.acceptor_sam.gtf.synonyms):\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    # genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if self.donor_sam.gtf.synonyms and not self.acceptor_sam.gtf.synonyms:\n                for genes1 in self.donor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if self.donor_sam.gtf.synonyms and not self.acceptor_sam.gtf.synonyms:\n                for genes1 in self.donor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if not self.donor_sam.gtf.synonyms and self.acceptor_sam.gtf.synonyms:\n                for genes2 in self.acceptor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    genes1 = self.donor_sam.str_gene()\n                    # genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n    # More human readable format\n    def __str__(self):\n        \"\"\"\n        Goal: output the junction in an expanded human readable form\n        Arguments:\n            none\n\n        Returns:\n            the string to be printed out\n        \"\"\"\n        out_str = \"\"\n        out_str += \"Junction with bin pair [\" + self.bin_pair + \"] with [\" + str(\n            len(self.bin_pair_group)) + \"] reads mapped\\n\"\n        out_str += \"Linear \" if self.linear() else \"Non-Linear \"\n        out_str += \"Donor on the \" + str(self.donor_sam.strand) + \" strand and acceptor on the \" + str(\n            self.acceptor_sam.strand) + \"\\n\"\n        out_str += \"5' map position [\" + str(self.donor_sam.start) + \"-\" + str(self.donor_sam.stop) + \"]\\n\"\n        out_str += \"3' map position [\" + str(self.acceptor_sam.start) + \"-\" + str(self.acceptor_sam.stop) + \"]\\n\"\n        out_str += \"badfj3:\" + str(self.badfj3) + \"\\n\"\n        out_str += \"Consensus with score [\" + str(self.score) + \"] and donor splice site [\" + str(\n            self.donor_sam.stop) + \"]:\\n\"\n        out_str += str(self.consensus) + \"\\n\"\n        out_str += str(self.donor_sam.seq) + \"\\n\"\n        out_str += \" \" * len(str(self.donor_sam.seq)) + str(self.acceptor_sam.seq) + \"\\n\"\n        out_str += \"Donor genes [\" + str(self.donor_sam.str_gene()) + \"]\\n\"\n        out_str += \"Acceptor genes [\" + str(self.acceptor_sam.str_gene()) + \"]\\n\"\n        return out_str\n\n    # Rank junctions in order of bin_pairs when sorted\n    def __lt__(self, other):\n        \"\"\"\n        Goal: give a comparison operator for the Junction class\n        Arguments:\n            other junction to compare to\n\n        Returns:\n            a boolean of whether or not this bin_pair\n            is smaller than the other bin_pair\n        \"\"\"\n        return self.bin_pair < other.bin_pair",
                "filename": "SPORK_Junction.py"
              },
              {
                "fileContent": "#Imports\nimport sys\n\n#build and score consensus function\n#(1) pads the left and right side of each sequence depending on where it mapped in the bin\n#(2) finds a consensus using a majority vote\n#(3) calculates a consensus score as the (number of mismatches)/(total_possible_mismatches)\ndef build_and_score_consensus(mapped_reads, strand, id_to_seq, bin_size, constants_dict, read_num_to_read_id):\n    #Add padding to the left sides of the reads based on where they fell in the bin pair\n    #Note that for the plus strand, more padding should be added the larger ther pos%bin_size value\n    #while this should have less padding on a minus strand read. This is implemented w/ the ternary expression\n    #read_num_to_read_id = constants_dict[\"read_num_to_read_id\"]\n    padded_seqs = []\n    left_padded_seqs = []\n    for mapped_read in mapped_reads:\n        id_key = mapped_read.read_id\n        id_key = id_key.replace(\"/5_prime\",\"\")\n        id_key = id_key.replace(\"/3_prime\",\"\")\n        id_key = read_num_to_read_id[id_key]\n        #id_key = id_key.replace(\"_\",\" \")\n        if id_key in id_to_seq:\n            full_seq = id_to_seq[id_key]\n        else:\n            sys.stderr.write(\"SPORK ERROR: Couldn't find sequence \"+id_key+\" in consensus building\\n\")\n            sys.exit(1)\n        mapped_read.read_id = id_key\n        left_padding = int(mapped_read.start%bin_size) if strand == \"+\" else int(bin_size-mapped_read.start%bin_size)\n        left_padded_seq = \" \"*left_padding+full_seq\n\n        #Don't allow exact sequence duplicates\n        if left_padded_seq not in left_padded_seqs:\n            left_padded_seqs.append(left_padded_seq)\n\n    #Add padding on the right sides so that every sequence is the same length\n    #Handled the same for plus and minus strand\n    max_len_seq = max([len(seq) for seq in left_padded_seqs])\n    for left_padded_seq in left_padded_seqs:\n        left_padded_len = len(left_padded_seq)\n        padding_to_add = max_len_seq-left_padded_len\n        padded_seq = left_padded_seq+\" \"*padding_to_add\n        padded_seqs.append(padded_seq)\n\n    #Go through each position and get the majority vote as the consensus base\n    #The dictionaries are just to help convert letters into indices and back\n    min_bases_per_col = constants_dict[\"min_bases_per_col\"]\n    consensus = \"\"\n    empty_spaces = 0\n    num_possible_discrepancies = 0\n    num_discrepancies = 0\n    base_dict = {\"A\":0,\"C\":1,\"G\":2,\"T\":3}\n    rev_base_dict = {0:\"A\",1:\"C\",2:\"G\",3:\"T\"}\n    for seq_ind in range(max_len_seq):\n        counts = [0,0,0,0]\n        for seq in padded_seqs:\n            base = seq[seq_ind].upper()\n            if base in base_dict:\n                counts[base_dict[base]] += 1\n        total_bases = sum(counts)\n        if total_bases >= min_bases_per_col:\n            num_possible_discrepancies += total_bases\n            max_count = max(counts)\n            num_discrepancies += total_bases-max_count\n            max_index = counts.index(max_count)\n            consensus += rev_base_dict[max_index]\n        else: empty_spaces += 1\n\n    #Give a terrible score if there are 0 possible discrepancies\n    #This arises most often when a junction only has one unique sequence\n    if int(num_possible_discrepancies) <= 0:\n        consensus_score = 999999\n        #sys.stderr.write(\"Null consensus:\\n\"+\"\\n\".join(padded_seqs)+\"\\n\")\n    else:\n        consensus_score = float(num_discrepancies)/int(num_possible_discrepancies)\n\n    #Print out the consensus's in a nice way\n    print_consensus = False\n    if print_consensus:\n        print \"Strand: \"+strand\n        print \"Discrepancies: \"+str(num_discrepancies)\n        print \"=\"*(len(seq)+2)\n        for seq in padded_seqs:\n            print \"|\"+seq+\"|\"\n        print \"=\"*(len(seq)+2)\n        print \"|\"+\" \"*(len(seq)-len(consensus)-min_bases_per_col)+consensus+\" \"*min_bases_per_col+\"|\"\n        left_score_str = \"|Score: \"+str(consensus_score)+\" \"\n        right_score_str = \" \"*(len(seq)+2-len(left_score_str)-1)+\"|\"\n        print left_score_str+right_score_str\n        print \"=\"*(len(seq)+2)\n        print \"\"\n\n    return consensus,consensus_score",
                "filename": "SPORK_consensus_utils.py"
              },
              {
                "fileContent": "#Import sys to write to sys.stderr sometimes\nimport sys\n\n#Mapped Read class\nclass SAMEntry(object):\n    __slots__ = [\"read_id\",\"strand\",\"chromosome\",\"start\",\"stop\",\"seq\",\"seq_quality\",\"exists\", \"num_gaps\", \"md\", \"num_mismatches\",\"num_Ns\",\"mapping_quality\",\"alignment_score\",\"gtf\"]\n\n    def __init__(self,full_line = None):\n        \"\"\"\n        Goal: initialize a SAMEntry object\n        Arguments:\n            can take in a full sam line (which it then parses),\n            or nothing, in which case a \"null\" SAMEntry is created\n            with None for every member\n\n        Returns:\n            nothing\n        \"\"\"\n        #Create an empty None-Type ish SAMEntry\n        if not full_line:\n            self.exists          = False\n            self.read_id         = None\n            self.strand          = None\n            self.chromosome      = None\n            self.start           = None\n            self.mapping_quality = None\n            self.seq             = None\n            self.seq_quality     = None\n            self.alignment_score = None\n            self.num_Ns          = None\n            self.num_mismatches  = None\n            self.num_gaps        = None\n            self.md              = None\n            self.stop            = None\n            self.gtf             = None\n\n        #Otherwise actually parse the line\n        else:\n            split_line = full_line.split(\"\\t\")\n            #Example bowtie2 SAM line w/ annotation:\n            #[0:read_id               ] K00180:68:H5CF7BBXX:3:1122:4422:11442/5_prime\n            #[1 :strand (0/16)        ] 0\n            #[2 :chromosome           ] chr21\n            #[3 :position             ] 9827122\n            #[4 :map quality          ] 42\n            #[5 :CIGAR string         ] 33M\n            #[6 :name of mate         ] *\n            #[7 :pos of mate          ] 0\n            #[8 :template len         ] 0\n            #[9 :sequence             ] CTTTGGTCGCTCGCTCCTCTCCTACTTGGATAA\n            #[10:quality string       ] <AAAFJJJFJJJJJFJFJJFJJJJJAJJFAFFJ\n            #[11:Alignment score      ] AS:i:0\n            #[12:number of N's        ] XN:i:0\n            #[13:number of mismatches ] XM:i:0\n            #[14:number gap opens     ] XO:i:0\n            #[15:number gap extensions] XG:i:0\n            #[16:edit distance        ] NM:i:0\n            #[17:string for mismatches] MD:Z:33\n            #[18:whether or not paired] YT:Z:UU\n            self.exists          = True\n            self.read_id         = split_line[0]\n            self.strand          = \"+\" if split_line[1] == \"0\" or split_line[1] == \"256\" else \"-\"\n            self.chromosome      = split_line[2]\n            self.start           = int(split_line[3])\n            self.mapping_quality = int(split_line[4])\n            self.seq             = split_line[9]\n            self.seq_quality     = split_line[10]\n            self.alignment_score = int(split_line[11].split(\":\")[-1])\n\n            for value in split_line[11:]:\n                if value[0:3] == \"XN:\":\n                    self.num_Ns          = int(value.split(\":\")[-1])\n                if value[0:3] == \"XM:\":\n                    self.num_mismatches  = int(value.split(\":\")[-1])\n                if value[0:3] == \"XO:\":\n                    self.num_gaps        = int(value.split(\":\")[-1])\n                if value[0:3] == \"MD:\":\n                    self.md = value.split(\":\")[-1]\n\n            self.stop = self.start+len(self.seq)\n            self.gtf = None\n\n    def donor(self):\n        \"\"\"\n        Goal: return the donor position of the SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            The donor position as an integer\n        \"\"\"\n        don = self.stop if self.strand == \"+\" else self.start\n        return don\n\n    def acceptor(self):\n        \"\"\"\n        Goal: return the acceptor position of the SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            The acceptor position as an integer\n        \"\"\"\n        acc = self.start if self.strand == \"+\" else self.stop\n        return acc\n\n    def str_gene(self):\n        \"\"\"\n        Goal: return the gene name associated with this SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            None in string form if no gene, or the gene name in string form\n        \"\"\"\n        if self.gtf:\n            return str(self.gtf.gene_name)\n        else:\n            return str(self.gtf)\n\n    def gene_strand(self):\n        \"\"\"\n        Goal: return the gtf gene strand associated with this SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            None in string form if no gene, or the gene strand in string form\n        \"\"\"\n        if self.gtf:\n            return str(self.gtf.strand)\n        else:\n            return str(self.gtf)\n\n    def junction(self):\n        \"\"\"\n        Goal: get a string of SAMEntry that looks similar to junction fasta headers\n        Arguments:\n            none\n\n        Returns:\n            a string of this SAMEntry\n        \"\"\"\n        out_str = \"\"\n        out_str += \"jct|\"+self.chromosome.split(\"|\")[1] if \"|\" in self.chromosome else self.chromosome\n        out_str += \"|\"+str(self.start)\n        out_str += \"|\"+str(self.stop)\n        out_str += \"|\"+str(self.strand)\n        return out_str\n\n    def __str__(self):\n        \"\"\"\n        Goal: get a human friendly string representation of SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            a string of important information of self\n        \"\"\"\n        ret_str = \"\"\n        ret_str += str(self.read_id)+\"\\t\"\n        ret_str += str(self.seq)+\"\\t\"\n        ret_str += str(self.chromosome)+\"\\t\"\n        ret_str += str(self.start)+\"\\t\"\n        ret_str += str(self.stop)+\"\\n\"\n        return ret_str\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allow comparison between SAMEntries for sorting\n        Arguments:\n            other is of type SAMEntry as well\n\n        Returns:\n            true if self is on a smaller chromosome, or has a smaller\n            start if chromosomes are shared, otherwise false\n        \"\"\"\n        same_chr = self.chromosome == other.chromosome\n        if not same_chr:\n            return self.chromosome < other.chromosome\n        else:\n            return self.start < other.start",
                "filename": "SPORK_SAMEntry.py"
              },
              {
                "fileContent": "#BinPair class\nclass BinPair(object):\n    __slots__ = [\"five_prime_SAM\",\"three_prime_SAM\",\"five_prime_bin\",\"three_prime_bin\",\n                 \"five_prime_strand\",\"three_prime_strand\",\"bin_pair\",\"five_prime_chr\",\"three_prime_chr\"]\n\n    def __init__(self,five_prime_SAM,three_prime_SAM,five_prime_bin,three_prime_bin):\n        \"\"\"\n        Goal: setup a BinPair object\n        Arguments:\n            a 5' SAMEntry object, a 3' SAMEntry object, and a bin from each (bins are ints)\n\n        Returns:\n            nothing\n        \"\"\"\n        self.five_prime_SAM = five_prime_SAM\n        self.three_prime_SAM = three_prime_SAM\n        self.five_prime_bin = int(five_prime_bin)\n        self.three_prime_bin = int(three_prime_bin)\n        self.five_prime_strand = five_prime_SAM.strand\n        self.three_prime_strand = three_prime_SAM.strand\n        self.five_prime_chr = five_prime_SAM.chromosome\n        self.three_prime_chr = three_prime_SAM.chromosome\n        self.bin_pair = self.five_prime_chr+\":\"+str(self.five_prime_bin)+\"_\"+self.three_prime_chr+\":\"+str(self.three_prime_bin)+\"_(\"+self.five_prime_strand+\",\"+self.three_prime_strand+\")\"\n\n    #Schematic of what the reverse compliment aims to do:\n    #================\n    #Before flipping:\n    #================\n    #\n    #(+ strand)-----------------------------------------\n    #\n    #             (*)  (#)                (*)  (#)\n    #              ======                  ======\n    #(- strand)----| 3' |------------------| 5' |-------\n    #              ======                  ======\n    #\n    #(*)'s are the upstream positions and (#)'s are the downstream positions\n    #\n    #===============\n    #After flipping:\n    #===============\n    #\n    #             (*)  (#)                (*)  (#)\n    #              ======                  ======\n    #(+ strand)----| 5' |------------------| 3' |-------\n    #              ======                  ======\n    #\n    #(- strand)-----------------------------------------\n    #\n    #So the 5' box got the orig 3' positions and should have the rev comp seq of the orig 3' seq\n    #the same thing happens to the 3' box\n    def take_reverse_compliment(self):\n        \"\"\"\n        Goal: take the reverse compliment of this bin pair\n        Arguments:\n            none\n\n        Returns:\n            itself for use in list comprehensions\n        \"\"\"\n        #Switch all the strands\n        self.five_prime_SAM.strand = \"-\" if self.five_prime_SAM.strand == \"+\" else \"+\"\n        self.three_prime_SAM.strand = \"-\" if self.three_prime_SAM.strand == \"+\" else \"+\"\n        self.five_prime_strand = \"-\" if self.five_prime_strand == \"+\" else \"+\"\n        self.three_prime_strand = \"-\" if self.three_prime_strand == \"+\" else \"+\"\n\n        #Swap the positions of the five and three prime SAMs\n        hold_five_prime_start = self.five_prime_SAM.start\n        hold_five_prime_stop = self.five_prime_SAM.stop\n        self.five_prime_SAM.start = self.three_prime_SAM.start\n        self.five_prime_SAM.stop = self.three_prime_SAM.stop\n        self.three_prime_SAM.start = hold_five_prime_start\n        self.three_prime_SAM.stop = hold_five_prime_stop\n\n        #Take the reverse compliment of the 5' and 3' seqs\n        #The list comprehensions are complicated but I like doing it in one line:\n        #   The [rev_comp_dict[base] for base in self.five_prime_SAM.seq] builds a list of complimentary bases\n        #   The \"\".join takes that list and turns it into a string\n        #   The [::-1] at the very end reverses the string to turn the compliment string into the rev comp string\n        rev_comp_dict = {\"A\":\"T\",\"a\":\"t\",\"T\":\"A\",\"t\":\"a\",\n                         \"C\":\"G\",\"c\":\"g\",\"G\":\"C\",\"g\":\"c\",\n                         \"N\":\"N\",\"n\":\"n\"}\n        rev_comp_5_prime_seq = \"\".join([rev_comp_dict[base] for base in self.five_prime_SAM.seq])[::-1]\n        rev_comp_3_prime_seq = \"\".join([rev_comp_dict[base] for base in self.three_prime_SAM.seq])[::-1]\n\n        #Then put the orig 3' rev comp into the new 5' and vice versa\n        self.five_prime_SAM.seq = rev_comp_3_prime_seq\n        self.three_prime_SAM.seq = rev_comp_5_prime_seq\n\n        #Switch the chromosomes too in case this is a fusion\n        hold_chromosome = self.five_prime_SAM.chromosome\n        self.five_prime_SAM.chromosome = self.three_prime_SAM.chromosome\n        self.three_prime_SAM.chromosome = hold_chromosome\n\n        #Using this in a list comprehension, so I want it to return itself\n        return self\n\n    def __str__(self):\n        \"\"\"\n        Goal: make this object into a string for easy printing\n        Arguments:\n            none\n\n        Returns:\n            a string representation of a bin pair\n        \"\"\"\n        return \"Bin Pair: \"+self.bin_pair+\" Left: \"+self.five_prime_SAM.read_id+\" Right: \"+self.three_prime_SAM.read_id+\"\\n\"\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allow comparison between two binpair objects\n        Arguments:\n            other is a binpair object just like self\n\n        Returns:\n            true if the bin_pair string of self is less than that of other\n        \"\"\"\n        return self.bin_pair < other.bin_pair",
                "filename": "SPORK_BinPair.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "inputs": [
          {
            "sbg:altPrefix": "--three_prime",
            "label": "3prime sam file",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-tp",
              "separate": true
            },
            "id": "#three_prime",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "SAM",
            "description": "3prime sam file.",
            "required": false
          },
          {
            "sbg:altPrefix": "--splice_flank_len",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "150",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-sfl",
              "separate": true
            },
            "id": "#splice_flank_len",
            "label": "Splice flank len",
            "sbg:stageInput": null,
            "description": "Flanking length on either side of the junction",
            "required": false
          },
          {
            "sbg:altPrefix": "--splice_finding_flank",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "30",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-sff",
              "separate": true
            },
            "id": "#splice_finding_flank",
            "label": "Splice finding flank",
            "sbg:stageInput": null,
            "description": "how long to make the pieces in splice site identification",
            "required": false
          },
          {
            "sbg:altPrefix": "--read_num_to_read_id",
            "label": "Read num to read id",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-rnri",
              "separate": true
            },
            "id": "#read_num_to_read_id",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "PICKLE, pickle",
            "description": "Read num to read id.",
            "required": false
          },
          {
            "sbg:altPrefix": "--number_of_cpus",
            "id": "#number_of_cpus",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-cpu",
              "separate": true
            },
            "sbg:stageInput": null,
            "required": false
          },
          {
            "sbg:altPrefix": "--min_bases_per_col",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-mbpc",
              "separate": true
            },
            "id": "#min_bases_per_col",
            "label": "Min bases per col",
            "sbg:stageInput": null,
            "description": "Only consider column if it has at least n bases.",
            "required": false
          },
          {
            "sbg:altPrefix": "--group_member_cutoff",
            "sbg:toolDefaultValue": "1",
            "label": "Group member cutoff",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-gmc",
              "separate": true
            },
            "id": "#group_member_cutoff",
            "type": [
              "null",
              "int"
            ],
            "description": "Minimum number of reads that need to map to a bin pair.",
            "required": false
          },
          {
            "sbg:altPrefix": "--fusion_max_gap",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fmg",
              "separate": true
            },
            "id": "#fusion_max_gap",
            "label": "Fusion max gap",
            "sbg:stageInput": null,
            "description": "Size of splice site gap to allow for fusions.",
            "required": false
          },
          {
            "sbg:altPrefix": "--flank_len",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "25",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fl",
              "separate": true
            },
            "id": "#flank_len",
            "label": "Flank len",
            "sbg:stageInput": null,
            "description": "Flank len.",
            "required": false
          },
          {
            "sbg:altPrefix": "--five_prime",
            "label": "5prime sam file",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-fp",
              "separate": true
            },
            "id": "#five_prime",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "SAM",
            "description": "5prime sam file",
            "required": false
          },
          {
            "sbg:altPrefix": "--consensus_score_cutoff",
            "type": [
              "null",
              "float"
            ],
            "sbg:toolDefaultValue": "0.5",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-csc",
              "separate": true
            },
            "id": "#consensus_score_cutoff",
            "label": "Consensus score cutoff",
            "sbg:stageInput": null,
            "description": "elates to the number of mismatches in consensus.",
            "required": false
          },
          {
            "sbg:altPrefix": "--combined_fastq",
            "label": "Combined fastq file",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-cf",
              "separate": true
            },
            "id": "#combined_fastq",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "FQ, FASTQ",
            "description": "Combined fastq file.",
            "required": false
          },
          {
            "sbg:altPrefix": "--bin_size",
            "sbg:toolDefaultValue": "50",
            "label": "Bin size",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-bs",
              "separate": true
            },
            "id": "#bin_size",
            "type": [
              "null",
              "int"
            ],
            "description": "Size of bins in bps to split ref into.",
            "sbg:includeInPorts": true,
            "required": false
          },
          {
            "sbg:altPrefix": "--at_boundary_cutoff",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-abc",
              "separate": true
            },
            "id": "#at_boundary_cutoff",
            "label": "At boundary cutoff",
            "sbg:stageInput": null,
            "description": "At boundary cutoff.",
            "required": false
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*used_read_ids.txt"
            },
            "label": "Used read ids",
            "id": "#used_read_ids",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "TXT",
            "description": "Used read ids."
          },
          {
            "outputBinding": {
              "glob": "*reads_in_jcts.txt"
            },
            "label": "Reads in junctions",
            "id": "#reads_in_jcts",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "TXT",
            "description": "Reads in junctions."
          },
          {
            "outputBinding": {
              "glob": "*putative_splices*",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.five_prime && $job.inputs.five_prime.metadata && $job.inputs.five_prime.metadata.sample_id)\n      return $job.inputs.five_prime.metadata.sample_id\n    return \"\"\n}"
                }
              }
            },
            "label": "Putative splices",
            "id": "#putative_splices",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:fileTypes": "FA, FASTA",
            "description": "Putative splices"
          },
          {
            "outputBinding": {
              "glob": "*_denovo_junctions.pickle"
            },
            "label": "Denovo junctions",
            "id": "#denovo_junctions",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "PICKLE, pickle",
            "description": "Denovo junctions."
          },
          {
            "outputBinding": {
              "glob": "*bin_pairs.txt"
            },
            "label": "Bin pairs",
            "id": "#bin_pairs",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "TXT",
            "description": "Bin pairs."
          }
        ],
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "value": "c4.8xlarge;ebs-gp2;1024",
            "class": "sbg:AWSInstanceType"
          }
        ],
        "baseCommand": [
          "python",
          "bin_pairs.py"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\tif($job.inputs.combined_fastq && $job.inputs.combined_fastq.metadata && $job.inputs.combined_fastq.metadata.sample_id)\n      return \"-s \" + $job.inputs.combined_fastq.metadata.sample_id\n    return \"\"\n} "
            },
            "separate": true
          }
        ],
        "sbg:image_url": null,
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520433042,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520433064,
            "sbg:revisionNotes": "revision 17 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1525813910,
            "sbg:revisionNotes": "SPORK_Junction.py and SPORK_SAMEntry.py updated"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527419906,
            "sbg:revisionNotes": "SPORK_Junction updated"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527425050,
            "sbg:revisionNotes": "SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527504863,
            "sbg:revisionNotes": "SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527519694,
            "sbg:revisionNotes": "SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527977899,
            "sbg:revisionNotes": "span_cutoff=1e6"
          },
          {
            "sbg:revision": 8,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528043835,
            "sbg:revisionNotes": "span_cutoff=1e5"
          },
          {
            "sbg:revision": 9,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528207252,
            "sbg:revisionNotes": "SPORK_SAMEntry num_mismatches updated"
          },
          {
            "sbg:revision": 10,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528210604,
            "sbg:revisionNotes": "bin_pairs.py updated"
          },
          {
            "sbg:revision": 11,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528292336,
            "sbg:revisionNotes": "Everything updated"
          },
          {
            "sbg:revision": 12,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529329054,
            "sbg:revisionNotes": "SPORK_utils.py handles multiple alignments"
          },
          {
            "sbg:revision": 13,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529589274,
            "sbg:revisionNotes": "back to revision 11"
          },
          {
            "sbg:revision": 14,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529883052,
            "sbg:revisionNotes": "Handles when num of bin_pairs == 1"
          },
          {
            "sbg:revision": 15,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529884499,
            "sbg:revisionNotes": "do not write \"to_remove_bin_pairs\" and \"to_keep_bin_pairs\""
          },
          {
            "sbg:revision": 16,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529923171,
            "sbg:revisionNotes": "back to revision 11"
          },
          {
            "sbg:revision": 17,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530006522,
            "sbg:revisionNotes": "read_num_to_read_id removed from constant_dist, SPORK_Junction, SPORK_utils updated to handle multiple alignements"
          },
          {
            "sbg:revision": 18,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530010182,
            "sbg:revisionNotes": "the same as 17"
          },
          {
            "sbg:revision": 19,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530012981,
            "sbg:revisionNotes": "build_and_score_consensus fixed"
          },
          {
            "sbg:revision": 20,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530055929,
            "sbg:revisionNotes": "SPORK_utils updated: handles multiple alignments"
          },
          {
            "sbg:revision": 21,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530186830,
            "sbg:revisionNotes": "rev:12 + read_num_to_read_id removed from constant_dict"
          },
          {
            "sbg:revision": 22,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530215952,
            "sbg:revisionNotes": "rev:20 + SPORK_GTFEntry.py synonyms"
          },
          {
            "sbg:revision": 23,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530216333,
            "sbg:revisionNotes": "SPORK_Junction: add_duplicates, SPORK_utils updated"
          },
          {
            "sbg:revision": 24,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530218760,
            "sbg:revisionNotes": "bin_pairs.py updated"
          },
          {
            "sbg:revision": 25,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530225143,
            "sbg:revisionNotes": "SPORK_Junction: .gtf.synonyms"
          },
          {
            "sbg:revision": 26,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530262095,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 27,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531178696,
            "sbg:revisionNotes": "SPORK_Junction: break-point added"
          },
          {
            "sbg:revision": 28,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531209214,
            "sbg:revisionNotes": "SPORK_Junction: break-point added fixed"
          },
          {
            "sbg:revision": 29,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533078516,
            "sbg:revisionNotes": "outputs the list of putative_splices"
          },
          {
            "sbg:revision": 30,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533123246,
            "sbg:revisionNotes": "number_of_cpus input added"
          },
          {
            "sbg:revision": 31,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533125394,
            "sbg:revisionNotes": "import math"
          },
          {
            "sbg:revision": 32,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533645392,
            "sbg:revisionNotes": "SPORK_Junction: add_duplicates: break-point added"
          },
          {
            "sbg:revision": 33,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534781257,
            "sbg:revisionNotes": "SPORK_utils and SPORK_SAMEntry updated"
          },
          {
            "sbg:revision": 34,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534785455,
            "sbg:revisionNotes": "SPORK_SAMEntry fixed"
          },
          {
            "sbg:revision": 35,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534786538,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 36,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534790592,
            "sbg:revisionNotes": "SPORK_SAMEntry fixed"
          },
          {
            "sbg:revision": 37,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534805342,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 38,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534945368,
            "sbg:revisionNotes": "SPORK_Junction updated"
          },
          {
            "sbg:revision": 39,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534955746,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 40,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535201936,
            "sbg:revisionNotes": "SPORK_Junction, get_fusion_type: span_cutoff=1e6"
          },
          {
            "sbg:revision": 41,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535537846,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 42,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535755007,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e0)"
          },
          {
            "sbg:revision": 43,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535846200,
            "sbg:revisionNotes": "def get_fusion_type(self, span_cutoff=1e3)"
          },
          {
            "sbg:revision": 44,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535908552,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 45,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536347541,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind updated"
          },
          {
            "sbg:revision": 46,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536350386,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 47,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536351462,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 48,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536359323,
            "sbg:revisionNotes": "SPORK_Junction format_consensus updated"
          },
          {
            "sbg:revision": 49,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536363536,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 50,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536370338,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e6)"
          },
          {
            "sbg:revision": 51,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536419375,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 52,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536448166,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 53,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536704679,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind() fixed"
          },
          {
            "sbg:revision": 54,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536709945,
            "sbg:revisionNotes": "SPORK_Junction: fasta_header() added"
          },
          {
            "sbg:revision": 55,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536972478,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind() and fasta_header updated"
          },
          {
            "sbg:revision": 56,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537020963,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 57,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537129884,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4)"
          },
          {
            "sbg:revision": 58,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537137870,
            "sbg:revisionNotes": "def get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 59,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537223207,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5), strand"
          },
          {
            "sbg:revision": 60,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537229597,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4), strand"
          },
          {
            "sbg:revision": 61,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537346741,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 62,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1538688821,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4)"
          },
          {
            "sbg:revision": 63,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1539077123,
            "sbg:revisionNotes": "is_at_boundary, get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 64,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545151497,
            "sbg:revisionNotes": "SPORK_utils.py: collapse_junctions"
          },
          {
            "sbg:revision": 65,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545151578,
            "sbg:revisionNotes": "SPORK_utils.py: collapse_junctions"
          },
          {
            "sbg:revision": 66,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545866702,
            "sbg:revisionNotes": "SPORK_Junction.py get_fusion_type fixed"
          },
          {
            "sbg:revision": 67,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1547546896,
            "sbg:revisionNotes": "SPORK_Junction: get_fusion_type fixed"
          },
          {
            "sbg:revision": 68,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550770065,
            "sbg:revisionNotes": "SPORK_utils.py and SPORK_Junction.py updated to support collapsed_num and uniformity score"
          },
          {
            "sbg:revision": 69,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550772994,
            "sbg:revisionNotes": "SPORK_Junction.py fixed _SAM instead of _sam"
          },
          {
            "sbg:revision": 70,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550774918,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: bin_pair. added"
          },
          {
            "sbg:revision": 71,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550779660,
            "sbg:revisionNotes": "SPORK_utils.py fixed: repr_jct"
          },
          {
            "sbg:revision": 72,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550785445,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: self.collapsed_num"
          },
          {
            "sbg:revision": 73,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550791428,
            "sbg:revisionNotes": "SPORK_Junction.py: round uniformity score"
          },
          {
            "sbg:revision": 74,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550795785,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: uniformity_score log"
          },
          {
            "sbg:revision": 75,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550957255,
            "sbg:revisionNotes": "SPORK_Junction.py: uniformity_score log \";\" and get_fusion_type(): allow with the gene"
          }
        ],
        "sbg:cmdPreview": "python bin_pairs.py  -s SAMPLE",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "at_boundary_cutoff": 3,
            "read_num_to_read_id": {
              "secondaryFiles": [],
              "path": "/path/to/read_num_to_read_id.ext",
              "class": "File",
              "size": 0
            },
            "combined_fastq": {
              "metadata": {
                "sample_id": "SAMPLE"
              },
              "size": 0,
              "path": "/path/to/combined_fastq.ext",
              "class": "File",
              "secondaryFiles": []
            },
            "group_member_cutoff": 5,
            "splice_flank_len": 10,
            "min_bases_per_col": 9,
            "splice_finding_flank": 5,
            "number_of_cpus": 10,
            "consensus_score_cutoff": 1.685471257343689,
            "flank_len": 1,
            "bin_size": 9,
            "fusion_max_gap": "fusion_max_gap-string-value",
            "five_prime": {
              "metadata": {
                "sample_id": "five_prime"
              },
              "size": 0,
              "path": "/path/to/five_prime.ext",
              "class": "File",
              "secondaryFiles": []
            },
            "three_prime": {
              "secondaryFiles": [],
              "path": "/path/to/three_prime.ext",
              "class": "File",
              "size": 0
            }
          }
        },
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/build-consensus-sequences/75",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/build-consensus-sequences/75",
        "sbg:revision": 75,
        "sbg:revisionNotes": "SPORK_Junction.py: uniformity_score log \";\" and get_fusion_type(): allow with the gene",
        "sbg:modifiedOn": 1550957255,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520433042,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos",
          "milos_jordanski"
        ],
        "sbg:latestRevision": 75,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a5f18be4f3847a266a2c2d57d114e9d63664375acd2af28920accf68bead2e096",
        "x": 2094.3340687884497,
        "y": -101.31777633499199,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/build-consensus-sequences/75"
      },
      "inputs": [
        {
          "id": "#SPORK_Build_Consensus_Sequences.three_prime",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.result_sam_file"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.splice_flank_len",
          "source": [
            "#splice_flank_len"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.splice_finding_flank",
          "source": [
            "#splice_finding_flank"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.read_num_to_read_id",
          "source": [
            "#SPORK_combine_and_split_unaligned_reads.read_num_to_read_id"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.number_of_cpus",
          "source": [
            "#number_of_cpus"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.min_bases_per_col",
          "source": [
            "#min_bases_per_col"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.group_member_cutoff",
          "source": [
            "#group_member_cutoff"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.fusion_max_gap",
          "source": [
            "#fusion_max_gap"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.flank_len",
          "source": [
            "#flank_len"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.five_prime",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.result_sam_file"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.consensus_score_cutoff",
          "source": [
            "#consensus_score_cutoff"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.combined_fastq",
          "source": [
            "#SPORK_combine_and_split_unaligned_reads.combined_reads"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.bin_size",
          "default": 50,
          "source": [
            "#bin_size"
          ]
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.at_boundary_cutoff",
          "source": [
            "#at_boundary_cutoff"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_Build_Consensus_Sequences.used_read_ids"
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.reads_in_jcts"
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.putative_splices"
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.denovo_junctions"
        },
        {
          "id": "#SPORK_Build_Consensus_Sequences.bin_pairs"
        }
      ],
      "sbg:x": 2094.3340687884497,
      "sbg:y": -101.31777633499199
    },
    {
      "id": "#AppendedReportSPORK",
      "run": {
        "class": "CommandLineTool",
        "label": "AppendedReportSPORK",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import argparse\nimport pandas as pd\nimport re\nfrom collections import defaultdict\nimport ast\nimport pickle\n\n\ndef count_indels(indel_file):\n    noindel_counts = defaultdict(int)\n    indel_counts = defaultdict(int)\n    with open(indel_file) as h_indel:\n        for line in h_indel:\n            if line[0] == '@':\n                continue\n\n            jct_id, str_values = line.split('\\t')\n            values = ast.literal_eval(str_values)  # <-- convert from str to list\n            noindel_counts[jct_id] += values[len(values) / 2]  # <-- the mid ind is noindel\n            indel_counts[jct_id] += sum(values) - noindel_counts[jct_id]\n\n    return noindel_counts, indel_counts\n\n\ndef get_badfjs(sam_files):\n    badfjs = defaultdict(int)\n    for sam_file in sam_files:\n        with open(sam_file) as h_sam:\n            for line in h_sam:\n                if line[0] == '@':\n                    continue\n\n                jct_id = line.split('\\t')[0]\n                if len(jct_id) >= 255:\n\n                    for junction in merged[\"junction\"]:\n                        if junction.startswith(jct_id):\n                            #print jct_id\n                            jct_id = junction\n                            break\n                if sam_file.endswith(\"regular_FJ.sam\") or sam_file.endswith(\"scrambled_FJ.sam\"):\n                    alignment_score = float(line.strip().split(\"\\t\")[11].split(\":\")[-1])\n                    if line.split(\"\\t\")[12][0:3] == \"XS:\":\n                        num_N_reference = float(line.split(\"\\t\")[13].split(\":\")[-1])\n                    else:\n                        num_N_reference = float(line.split(\"\\t\")[12].split(\":\")[-1])\n\n                    num_N_junction = line.split(\"\\t\")[9].count(\"N\")\n\n                    num_of_mismatches = int(line.split(\"XM:i:\")[1].split(\"\\t\")[0])\n\n                    if alignment_score > -0.24 * (300 - (num_of_mismatches + alignment_score / 6)) or (alignment_score / 6 + num_of_mismatches) < 50:\n                        badfjs[jct_id] = 1\n                else:\n                    badfjs[jct_id] = 1\n\n    return badfjs\n\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('-kglm', '--knife_glm', help='output of knife glm')\nparser.add_argument('-nr', '--naive_report', help='naive report')\nparser.add_argument('-sglm', '--spork_glm', help = 'output of spork glm')\nparser.add_argument('-nj', '--novel_junctions', help = 'novel junctions fasta file')\nparser.add_argument('-ih', '--indels_histogram', nargs='+', help = 'indels histogram 1')\nparser.add_argument('-bfjs', '--bad_fj_sam', nargs='+', help='BadFJ sam files')\nparser.add_argument('-bfj2s', '--bad_fj_2_sam', nargs='+', help='BadFJ_ver2 sam files')\nparser.add_argument('-s', '--sample_name', help = 'sample name')\nparser.add_argument('-suf', '--suffix', help = 'suffix')\nparser.add_argument('-5p', '--five_prime', help = 'file prime sam')\nparser.add_argument('-3p', '--three_prime', help = 'three prime sam')\nparser.add_argument('-dj', '--duplicate_junction', help='duplicate junctions')\nparser.add_argument('-sdj', '--seq_duplicate_junction', help='duplicate junctions')\nparser.add_argument('-uf', '--uniformity_pvalue', help='duplicate junctions')\n\nargs = parser.parse_args()\n\nappended_report = args.sample_name + \"_naive_report_Appended\" + args.suffix + \".txt\"\n\nduplicate_junctions = pickle.load(open(args.duplicate_junction, \"rb\"))\nreverse_duplicate_junctions = {}\nfor key, value in duplicate_junctions.iteritems():\n    if value[1:-1] not in reverse_duplicate_junctions:\n        reverse_duplicate_junctions[value[1:-1]] = [key[1:-1]]\n    else:\n        reverse_duplicate_junctions[value[1:-1]].append(key[1:-1])\n\nseq_duplicate_junctions = pickle.load(open(args.seq_duplicate_junction, \"rb\"))\nreverse_seq_duplicate_junctions = {}\nfor key, value in seq_duplicate_junctions.iteritems():\n    if value[1:] not in reverse_seq_duplicate_junctions:\n        reverse_seq_duplicate_junctions[value[1:]] = [key[1:]]\n    else:\n        reverse_seq_duplicate_junctions[value[1:]].append(key[1:])\n\n\nnaive = pd.read_table(args.naive_report, sep='\\t')\n\nnaive.rename(columns={'@Junction':'junction'}, inplace=True)\n\nuniformity_pvalue = pd.read_table(args.uniformity_pvalue, sep=\"\\t\")\nuniformity_pvalue.rename(columns={'R1_JuncName':'junction'}, inplace=True)\n\nnaive = pd.merge(naive, uniformity_pvalue)\n\nmerged = naive\nif args.spork_glm:\n    glm = pd.read_table(args.spork_glm, sep='\\t')\n    merged = pd.merge(naive,glm)\n\nrename_dict = {'genome-anomaly': 'genome.anomaly',\n               'genome-pval': 'genome.pval',\n               'reg-anomaly': 'reg.anomaly',\n               'reg-pval': 'reg.pval',\n               'junc-anom': 'junc.anom',\n               'junc-pval': 'junc.pval',\n               'FarJunc-anom': 'FarJunc.anom',\n               'FarJunc-pval': 'FarJunc.pval',\n               'logsum_2.x': 'logsum.2.x',\n               'productPhat_lower.x': 'productPhat.lower.x',\n               'junction_cdf.x': 'junction.cdf.x',\n               'junction_cdf_lower.x': 'junction.cdf.lower.x',\n               'logsum_2.y': 'logsum.2.y',\n               'productPhat_lower.y': 'productPhat.lower.y',\n               'junction_cdf.y': 'junction_cdf_y',\n               'junction_cdf_lower.y': 'junction.cdf.lower.y',\n               'junction_cdf_windel_diff': 'junction.cdf.windel.diff'}\n\nmerged.rename(columns=rename_dict, inplace=True) #Rename the merged column\n\nparse_locs = {0: 'chr1', 1: 'gene1', 2: 'pos1', 3: 'strand1',\n              4: 'chr2', 5: 'gene2', 6: 'pos2', 7: 'strand2',\n              8: 'kind', 10: 'num', 12: \"collapsed_num\", 14: 'score', 16: 'gap',\n              18: 'break-point', 20: 'uniformity_score', 22: 'at_boundary', 24: 'don.dist', 26: 'acc.dist',\n              28: 'mapq', 30: 'badfj.3', 32: 'jct.ind'}\n\nparse_vals = defaultdict(list)\n\nfor jct in merged['junction']:\n    parsed = re.split('=|:|,|\\|',jct)\n    for i,v in enumerate(parsed):\n        if i in parse_locs:\n            parse_vals[parse_locs[i]].append(v)\n\ncolname_order = [x[1] for x in sorted(parse_locs.iteritems())]\nfor k in colname_order:\n    merged[k] = parse_vals[k]\n\nmerged.replace('False', 0, inplace=True)\nmerged.replace('True', 1, inplace=True)\n\nindelfiles = sorted(args.indels_histogram)\n\nindel_file1 = indelfiles[0]\nindel_file2 = indelfiles[1]\n\nprint indel_file1\nprint indel_file2\n\n\nnoindel_counts1,indel_counts1 = count_indels(indel_file1)\nnoindel_counts2,indel_counts2 = count_indels(indel_file2)\n\nmerged['num.noindel.1'] = merged['junction'].map(noindel_counts1)\nmerged['num.indel.1'] = merged['junction'].map(indel_counts1)\nmerged['num.noindel.2'] = merged['junction'].map(noindel_counts2)\nmerged['num.indel.2'] = merged['junction'].map(indel_counts2)\n\nBadFJ1_sams = args.bad_fj_sam\nBadFJ2_sams = args.bad_fj_2_sam\nbadfj1s = get_badfjs(BadFJ1_sams)\nbadfj2s = get_badfjs(BadFJ2_sams)\n\nprint \"Badfj1s: \" + str(len(badfj1s))\n\nmerged['badfj.1'] = merged['junction'].map(badfj1s)\nmerged['badfj.2'] = merged['junction'].map(badfj2s)\nmerged['badfj.1'].fillna(0,inplace=True)\nmerged['badfj.2'].fillna(0,inplace=True)\n\nprint len(merged[merged['badfj.1'] > 0])\n\nif args.knife_glm:\n    gene_counts = defaultdict(int)\n    with open(args.knife_glm) as h:\n        h.readline()\n        for line in h:\n            jct, count, log_sum, posterior = line.split('\\t')[:4]\n            if float(posterior) > 0.8:\n                chrom, gene1, pos1, gene2, pos2, kind, strand = re.split(':|\\|', jct)\n                gene_counts[gene1] = max(gene_counts[gene1], int(count))\n                gene_counts[gene2] = max(gene_counts[gene2], int(count))\n\n    merged['exon.1'] = merged['gene1'].map(gene_counts)\n    merged['exon.2'] = merged['gene2'].map(gene_counts)\n    merged['exon.1'].fillna(0, inplace=True)\n    merged['exon.2'].fillna(0, inplace=True)\n\nelse:\n    merged['exon.1'] = -1\n    merged['exon.2'] = -1\n\nfive_prime  = {}\nthree_prime = {}\n\nwith open(args.five_prime, \"r\") as f:\n    while True:\n        line = f.readline()\n        if not line:\n            break\n        junction_id = line.split(\"\\t\")[0]\n        if len(junction_id) >= 255:\n            for junction in merged[\"junction\"]:\n                if junction.startswith(junction_id):\n                    junction_id = junction\n\n        five_prime[junction_id] = line.split(\"\\t\")[4]\n\nwith open(args.three_prime, \"r\") as f:\n    while True:\n        line = f.readline()\n        if not line:\n            break\n        junction_id = line.split(\"\\t\")[0]\n        if len(junction_id) >= 255:\n            for junction in merged[\"junction\"]:\n                if junction.startswith(junction_id):\n                    junction_id = junction\n        three_prime[junction_id] = line.split(\"\\t\")[4]\n\nmerged[\"five_prime_qual\"] = merged['junction'].map(five_prime)\nmerged[\"three_prime_qual\"] = merged['junction'].map(three_prime)\n\nid_to_seq = {}\nwith open(args.novel_junctions,'r') as fasta_file:\n    while True:\n        header = fasta_file.readline()\n        if not header:\n            break\n\n        jct_id = header[1:].strip()\n        seq = fasta_file.readline().strip()\n        id_to_seq[jct_id] = seq\n\nmerged['seq'] = merged['junction'].map(id_to_seq)\nmerged[\"pos1\"] = merged[\"pos1\"].astype(int)\nmerged[\"pos2\"] = merged[\"pos2\"].astype(int)\n\nif args.spork_glm:\n    badfj1s = merged[merged['badfj.1'] > 0]\n    badfj1s_badfj2s = merged[(merged[\"badfj.1\"] > 0) & (merged[\"numReads.x\"] > 1)]\n    badfj1_no_fusions = merged[(merged[\"badfj.1\"] > 0) & (merged[\"chr1\"] == merged[\"chr2\"]) & (merged[\"strand1\"] == merged[\"strand2\"]) & (abs(merged[\"pos1\"] - merged[\"pos2\"]) < 100000)]\n    badfj1_fusions = merged[(merged[\"badfj.1\"] > 0 & ((merged[\"chr1\"] != merged[\"chr2\"]) | (merged[\"strand1\"] != merged[\"strand2\"]) | (abs(merged[\"pos1\"] - merged[\"pos2\"]) >= 100000)))]\n    total_badfj1s = len(badfj1s)\n    total_badfj1s_badfj2s = len(badfj1s_badfj2s)\n    total_badfj1_no_fusions = len(badfj1_no_fusions)\n    total_badfj1_fusions = len(badfj1_fusions)\n    emp_ps = []\n    emp_ps_2 = []\n    emp_ps_3 = []\n\n    for row in merged.itertuples():\n\n        num_greater = sum(badfj1s['junction_cdf_y'] > row.junction_cdf_y)\n        num_greater_2 = sum(badfj1s_badfj2s['junction_cdf_y'] > row.junction_cdf_y)\n\n        if (row.chr1 == row.chr2) and (row.strand1 == row.strand2) and (abs(row.pos1 - row.pos2) < 100000):\n            num_greater_3 = sum(badfj1_no_fusions['junction_cdf_y'] > row.junction_cdf_y)\n        else:\n            num_greater_3 = sum(badfj1_fusions['junction_cdf_y'] > row.junction_cdf_y)\n\n        if total_badfj1s == 0:\n            emp_ps.append(1)\n        else:\n            emp_ps.append(float(num_greater)/total_badfj1s)\n\n        if total_badfj1s_badfj2s == 0:\n            emp_ps_2.append(1)\n        else: emp_ps_2.append(float(num_greater_2)/total_badfj1s_badfj2s)\n\n        if (row.chr1 == row.chr2) and (row.strand1 == row.strand2) and (abs(row.pos1 - row.pos2) < 100000):\n            if total_badfj1_no_fusions == 0:\n                emp_ps_3.append(1)\n            else: emp_ps_3.append(float(num_greater_3)/total_badfj1_no_fusions)\n        else:\n            if total_badfj1_fusions == 0:\n                emp_ps_3.append(1)\n            else: emp_ps_3.append(float(num_greater_3)/total_badfj1_fusions)\n\n\n    merged['emp.p'] = emp_ps\n    merged['emp.p.2'] = emp_ps_2\n    merged['emp.p.3'] = emp_ps_3\n\n#merged.to_csv(appended_report,sep='\\t',index=False)\n\nrename_dict = {'junction_cdf_y': 'junction.cdf.y'}\n\nmerged.rename(columns=rename_dict, inplace=True)\n\nmerged_list = []\nfor index, item in merged.iterrows():\n    tmp_list = [item[0]]\n    tmp_list.extend(list(item[1:]))\n    merged_list.append(tmp_list)\n    if item[0] in reverse_duplicate_junctions:\n        for new_junction_name in reverse_duplicate_junctions[item[0]]:\n            tmp_list_new = [new_junction_name + \"|DUPLICATE\"]\n            tmp_list_new.extend(list(item[1:]))\n            merged_list.append(tmp_list_new)\n    if item[0] in reverse_seq_duplicate_junctions:\n        for new_junction_name in reverse_seq_duplicate_junctions[item[0]]:\n            tmp_list_new = [new_junction_name + \"|SAME_SEQUENCE\"]\n            tmp_list_new.extend(list(item[1:]))\n            merged_list.append(tmp_list_new)\n\nmerged_df = pd.DataFrame(merged_list,columns=merged.columns)\nmerged_df.to_csv(appended_report,sep='\\t',index=False)",
                "filename": "appended_report.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine"
          }
        ],
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-uf"
            },
            "id": "#uniformity_pvalue",
            "sbg:altPrefix": "--uniformity_pvalue",
            "required": false
          },
          {
            "inputBinding": {
              "prefix": "-3p",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#three_prime_sam",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--suffix",
            "inputBinding": {
              "prefix": "-suf",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--spork_glm",
            "inputBinding": {
              "prefix": "-sglm",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#spork_glm",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--seq_duplicate_junction",
            "inputBinding": {
              "prefix": "-sdj",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#seq_duplicate_junction",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--novel_junctions",
            "inputBinding": {
              "prefix": "-nj",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#novel_junctions",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--naive_report",
            "inputBinding": {
              "prefix": "-nr",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#naive_report",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--knife_glm",
            "inputBinding": {
              "prefix": "-kglm",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#knife_glm",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--indels_histogram",
            "inputBinding": {
              "prefix": "-ih",
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": " "
            },
            "id": "#indels_histogram",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "prefix": "-5p",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#five_prime_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:fileTypes": "PICKLE, pickle",
            "inputBinding": {
              "prefix": "-dj",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#duplicate_junction",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--bad_fj_sam",
            "inputBinding": {
              "prefix": "-bfjs",
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": " "
            },
            "id": "#bad_fj_sam",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--bad_fj_2_sam",
            "inputBinding": {
              "prefix": "-bfj2s",
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": " "
            },
            "id": "#bad_fj_2_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_naive_report_Appended*",
              "sbg:inheritMetadataFrom": "#novel_junctions"
            },
            "id": "#naive_report_Appended",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7",
            "class": "DockerRequirement"
          }
        ],
        "baseCommand": [
          "python",
          "appended_report.py"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n\tif($job.inputs.novel_junctions && $job.inputs.novel_junctions.metadata && $job.inputs.novel_junctions.metadata.sample_id)\n      return \"-s \" + $job.inputs.novel_junctions.metadata.sample_id\n}"
            }
          }
        ],
        "sbg:cmdPreview": "python appended_report.py  -s sample name",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:image_url": null,
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434246,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434268,
            "sbg:revisionNotes": "revision 6 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520889518,
            "sbg:revisionNotes": "3p and 5p included"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528071951,
            "sbg:revisionNotes": "filter reg/scrambled fj junctions updated; emp.p.2 added"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528102316,
            "sbg:revisionNotes": "appended_report.py updated"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529936349,
            "sbg:revisionNotes": "emp.p.2 modified: merged[(merged[\"badfj.1\"] > 0) & (merged[\"numReads.x\"] > 1)]"
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530277007,
            "sbg:revisionNotes": "duplicate_junctions added"
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530278704,
            "sbg:revisionNotes": "duplicate_junctions fixed"
          },
          {
            "sbg:revision": 8,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533646620,
            "sbg:revisionNotes": "filter badfj.1 fixed"
          },
          {
            "sbg:revision": 9,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533686432,
            "sbg:revisionNotes": "alignment_score typo fixed"
          },
          {
            "sbg:revision": 10,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537529637,
            "sbg:revisionNotes": "seq_duplicate_junction added"
          },
          {
            "sbg:revision": 11,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537722786,
            "sbg:revisionNotes": "similar_seq added"
          },
          {
            "sbg:revision": 12,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537954419,
            "sbg:revisionNotes": "back to rev:10"
          },
          {
            "sbg:revision": 13,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1539077750,
            "sbg:revisionNotes": "parse_locs includes break-point and at_boundary"
          },
          {
            "sbg:revision": 14,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545868883,
            "sbg:revisionNotes": "seq_duplicate_junction removed"
          },
          {
            "sbg:revision": 15,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1546011904,
            "sbg:revisionNotes": "|SAME_SEQUENCE|DUPLICATE and |SIMILAR_SEQUENCE|DUPLICATE added"
          },
          {
            "sbg:revision": 16,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550769719,
            "sbg:revisionNotes": "collapsed_num and uniformity_score added to parse_locs"
          },
          {
            "sbg:revision": 17,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550804373,
            "sbg:revisionNotes": "typo fixed"
          },
          {
            "sbg:revision": 18,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550979890,
            "sbg:revisionNotes": "uniformity_pvalue as input"
          },
          {
            "sbg:revision": 19,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550981943,
            "sbg:revisionNotes": "emp.p.3 added"
          },
          {
            "sbg:revision": 20,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550982202,
            "sbg:revisionNotes": "\"badfj.1\" fixed"
          },
          {
            "sbg:revision": 21,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550982513,
            "sbg:revisionNotes": "and, or fixed"
          },
          {
            "sbg:revision": 22,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550983049,
            "sbg:revisionNotes": "pos1, pos2 int type"
          },
          {
            "sbg:revision": 23,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550983306,
            "sbg:revisionNotes": "\"junction.cdf.y\" fixed"
          },
          {
            "sbg:revision": 24,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1551084107,
            "sbg:revisionNotes": "short jct_id fixed"
          },
          {
            "sbg:revision": 25,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1551091746,
            "sbg:revisionNotes": "en(jct_id) >= 255"
          },
          {
            "sbg:revision": 26,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1553502306,
            "sbg:revisionNotes": "chr1/2 and five_prime, three_prime fixed"
          },
          {
            "sbg:revision": 27,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1553596392,
            "sbg:revisionNotes": "appended_report three_prime[junction_id] fixed"
          }
        ],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "duplicate_junction": {
              "size": 0,
              "class": "File",
              "path": "/path/to/duplicate_junction.pickle",
              "secondaryFiles": []
            },
            "knife_glm": {
              "size": 0,
              "class": "File",
              "path": "/path/to/knife_glm.ext",
              "secondaryFiles": []
            },
            "indels_histogram": [
              {
                "size": 0,
                "class": "File",
                "path": "/path/to/indels_histogram_1-1.ext",
                "secondaryFiles": []
              },
              {
                "size": 0,
                "class": "File",
                "path": "/path/to/indels_histogram_1-2.ext",
                "secondaryFiles": []
              }
            ],
            "novel_junctions": {
              "class": "File",
              "size": 0,
              "metadata": {
                "sample_id": "sample name"
              },
              "path": "/path/to/novel_junctions.ext",
              "secondaryFiles": []
            },
            "naive_report": {
              "size": 0,
              "class": "File",
              "path": "/path/to/naive_report.ext",
              "secondaryFiles": []
            },
            "seq_duplicate_junction": {
              "class": "File",
              "secondaryFiles": [],
              "path": "/path/to/seq_duplicate_junction.ext",
              "size": 0
            },
            "spork_glm": {
              "size": 0,
              "class": "File",
              "path": "/path/to/spork_glm.ext",
              "secondaryFiles": []
            },
            "three_prime_sam": {
              "size": 0,
              "class": "File",
              "path": "/path/to/three_prime_sam.ext",
              "secondaryFiles": []
            },
            "bad_fj_2_sam": [
              {
                "size": 0,
                "class": "File",
                "path": "/path/to/bad_fj_2_sam-1.ext",
                "secondaryFiles": []
              },
              {
                "size": 0,
                "class": "File",
                "path": "/path/to/bad_fj_2_sam-2.ext",
                "secondaryFiles": []
              }
            ],
            "five_prime_sam": {
              "size": 0,
              "class": "File",
              "path": "/path/to/five_prime_sam.ext",
              "secondaryFiles": []
            },
            "bad_fj_sam": [
              "bad_fj_sam-string-value-1",
              "bad_fj_sam-string-value-2"
            ],
            "suffix": "suffix-string-value",
            "uniformity_pvalue": {
              "path": "/path/to/uniformity_pvalue.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          }
        },
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/appendedreportspork/27",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/appendedreportspork/27",
        "sbg:revision": 27,
        "sbg:revisionNotes": "appended_report three_prime[junction_id] fixed",
        "sbg:modifiedOn": 1553596392,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520434246,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "sbg:latestRevision": 27,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a21a273e95e1b4f26b1022f60f68d4765af14154d9033329b8162258eb9051e41",
        "x": 6446.752192209246,
        "y": -90.45489089177262,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/appendedreportspork/27"
      },
      "inputs": [
        {
          "id": "#AppendedReportSPORK.uniformity_pvalue",
          "source": [
            "#SPORK_uniformity_pvalue_filtered.output_file"
          ]
        },
        {
          "id": "#AppendedReportSPORK.three_prime_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.result_sam_file"
          ]
        },
        {
          "id": "#AppendedReportSPORK.suffix",
          "default": "_SPORK"
        },
        {
          "id": "#AppendedReportSPORK.spork_glm",
          "source": [
            "#SPORK_GLM_script_UseIndel.fusion_w_anomaly_and_indel_juncp_out_lef_join"
          ]
        },
        {
          "id": "#AppendedReportSPORK.seq_duplicate_junction",
          "source": [
            "#SPORK_BadFJ3.seq_duplicates"
          ]
        },
        {
          "id": "#AppendedReportSPORK.novel_junctions",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        },
        {
          "id": "#AppendedReportSPORK.naive_report",
          "source": [
            "#SPORK_FarJuncNaiveReport.naive_report"
          ]
        },
        {
          "id": "#AppendedReportSPORK.knife_glm",
          "source": [
            "#KNIFE_GLM_model.linear_junc_probs"
          ]
        },
        {
          "id": "#AppendedReportSPORK.indels_histogram",
          "source": [
            "#SPORK_MakeIndelsHisto.indels_txt"
          ]
        },
        {
          "id": "#AppendedReportSPORK.five_prime_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.result_sam_file"
          ]
        },
        {
          "id": "#AppendedReportSPORK.duplicate_junction",
          "source": [
            "#SPORK_BadFJ3.duplicate_junctions"
          ]
        },
        {
          "id": "#AppendedReportSPORK.bad_fj_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.result_sam_file"
          ]
        },
        {
          "id": "#AppendedReportSPORK.bad_fj_2_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#AppendedReportSPORK.naive_report_Appended"
        }
      ],
      "sbg:x": 6446.752192209246,
      "sbg:y": -90.45489089177262
    },
    {
      "id": "#AppendedReportSPORK_With_Building_Reads",
      "run": {
        "class": "CommandLineTool",
        "label": "AppendedReportSPORK_With_Building_Reads",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import argparse\nimport pandas as pd\nimport re\nfrom collections import defaultdict\nimport ast\nimport pickle\n\n\ndef count_indels(indel_file):\n    noindel_counts = defaultdict(int)\n    indel_counts = defaultdict(int)\n    with open(indel_file) as h_indel:\n        for line in h_indel:\n            if line[0] == '@':\n                continue\n\n            jct_id, str_values = line.split('\\t')\n            values = ast.literal_eval(str_values)  # <-- convert from str to list\n            noindel_counts[jct_id] += values[len(values) / 2]  # <-- the mid ind is noindel\n            indel_counts[jct_id] += sum(values) - noindel_counts[jct_id]\n\n    return noindel_counts, indel_counts\n\n\ndef get_badfjs(sam_files):\n    badfjs = defaultdict(int)\n    for sam_file in sam_files:\n        with open(sam_file) as h_sam:\n            for line in h_sam:\n                if line[0] == '@':\n                    continue\n\n                jct_id = line.split('\\t')[0]\n                if len(jct_id) >= 255:\n\n                    for junction in merged[\"junction\"]:\n                        if junction.startswith(jct_id):\n                            #print jct_id\n                            jct_id = junction\n                            break\n                if sam_file.endswith(\"regular_FJ.sam\") or sam_file.endswith(\"scrambled_FJ.sam\"):\n                    alignment_score = float(line.strip().split(\"\\t\")[11].split(\":\")[-1])\n                    if line.split(\"\\t\")[12][0:3] == \"XS:\":\n                        num_N_reference = float(line.split(\"\\t\")[13].split(\":\")[-1])\n                    else:\n                        num_N_reference = float(line.split(\"\\t\")[12].split(\":\")[-1])\n\n                    num_N_junction = line.split(\"\\t\")[9].count(\"N\")\n\n                    num_of_mismatches = int(line.split(\"XM:i:\")[1].split(\"\\t\")[0])\n\n                    if alignment_score > -0.24 * (300 - (num_of_mismatches + alignment_score / 6)) or (alignment_score / 6 + num_of_mismatches) < 50:\n                        badfjs[jct_id] = 1\n                else:\n                    badfjs[jct_id] = 1\n\n    return badfjs\n\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('-kglm', '--knife_glm', help='output of knife glm')\nparser.add_argument('-nr', '--naive_report', help='naive report')\nparser.add_argument('-sglm', '--spork_glm', help = 'output of spork glm')\nparser.add_argument('-nj', '--novel_junctions', help = 'novel junctions fasta file')\nparser.add_argument('-ih', '--indels_histogram', nargs='+', help = 'indels histogram 1')\nparser.add_argument('-bfjs', '--bad_fj_sam', nargs='+', help='BadFJ sam files')\nparser.add_argument('-bfj2s', '--bad_fj_2_sam', nargs='+', help='BadFJ_ver2 sam files')\nparser.add_argument('-s', '--sample_name', help = 'sample name')\nparser.add_argument('-suf', '--suffix', help = 'suffix')\nparser.add_argument('-5p', '--five_prime', help = 'file prime sam')\nparser.add_argument('-3p', '--three_prime', help = 'three prime sam')\nparser.add_argument('-dj', '--duplicate_junction', help='duplicate junctions')\nparser.add_argument('-sdj', '--seq_duplicate_junction', help='duplicate junctions')\nparser.add_argument('-uf', '--uniformity_pvalue', help='duplicate junctions')\n\nargs = parser.parse_args()\n\nappended_report = args.sample_name + \"_naive_report_Appended\" + args.suffix + \".txt\"\n\nduplicate_junctions = pickle.load(open(args.duplicate_junction, \"rb\"))\nreverse_duplicate_junctions = {}\nfor key, value in duplicate_junctions.iteritems():\n    if value[1:-1] not in reverse_duplicate_junctions:\n        reverse_duplicate_junctions[value[1:-1]] = [key[1:-1]]\n    else:\n        reverse_duplicate_junctions[value[1:-1]].append(key[1:-1])\n\nseq_duplicate_junctions = pickle.load(open(args.seq_duplicate_junction, \"rb\"))\nreverse_seq_duplicate_junctions = {}\nfor key, value in seq_duplicate_junctions.iteritems():\n    if value[1:] not in reverse_seq_duplicate_junctions:\n        reverse_seq_duplicate_junctions[value[1:]] = [key[1:]]\n    else:\n        reverse_seq_duplicate_junctions[value[1:]].append(key[1:])\n\n\nnaive = pd.read_table(args.naive_report, sep='\\t')\n\nnaive.rename(columns={'@Junction':'junction'}, inplace=True)\n\nuniformity_pvalue = pd.read_table(args.uniformity_pvalue, sep=\"\\t\")\nuniformity_pvalue.rename(columns={'R1_JuncName':'junction'}, inplace=True)\n\nnaive = pd.merge(naive, uniformity_pvalue)\n\nmerged = naive\nif args.spork_glm:\n    glm = pd.read_table(args.spork_glm, sep='\\t')\n    merged = pd.merge(naive,glm)\n\nrename_dict = {'genome-anomaly': 'genome.anomaly',\n               'genome-pval': 'genome.pval',\n               'reg-anomaly': 'reg.anomaly',\n               'reg-pval': 'reg.pval',\n               'junc-anom': 'junc.anom',\n               'junc-pval': 'junc.pval',\n               'FarJunc-anom': 'FarJunc.anom',\n               'FarJunc-pval': 'FarJunc.pval',\n               'logsum_2.x': 'logsum.2.x',\n               'productPhat_lower.x': 'productPhat.lower.x',\n               'junction_cdf.x': 'junction.cdf.x',\n               'junction_cdf_lower.x': 'junction.cdf.lower.x',\n               'logsum_2.y': 'logsum.2.y',\n               'productPhat_lower.y': 'productPhat.lower.y',\n               'junction_cdf.y': 'junction_cdf_y',\n               'junction_cdf_lower.y': 'junction.cdf.lower.y',\n               'junction_cdf_windel_diff': 'junction.cdf.windel.diff'}\n\nmerged.rename(columns=rename_dict, inplace=True) #Rename the merged column\n\nparse_locs = {0: 'chr1', 1: 'gene1', 2: 'pos1', 3: 'strand1',\n              4: 'chr2', 5: 'gene2', 6: 'pos2', 7: 'strand2',\n              8: 'kind', 10: 'num', 12: \"collapsed_num\", 14: 'score', 16: 'gap',\n              18: 'break-point', 20: 'uniformity_score', 22: 'at_boundary', 24: 'don.dist', 26: 'acc.dist',\n              28: 'mapq', 30: 'badfj.3', 32: 'jct.ind'}\n\nparse_vals = defaultdict(list)\n\nfor jct in merged['junction']:\n    parsed = re.split('=|:|,|\\|',jct)\n    for i,v in enumerate(parsed):\n        if i in parse_locs:\n            parse_vals[parse_locs[i]].append(v)\n\ncolname_order = [x[1] for x in sorted(parse_locs.iteritems())]\nfor k in colname_order:\n    merged[k] = parse_vals[k]\n\nmerged.replace('False', 0, inplace=True)\nmerged.replace('True', 1, inplace=True)\n\nindelfiles = sorted(args.indels_histogram)\n\nindel_file1 = indelfiles[0]\nindel_file2 = indelfiles[1]\n\nprint indel_file1\nprint indel_file2\n\n\nnoindel_counts1,indel_counts1 = count_indels(indel_file1)\nnoindel_counts2,indel_counts2 = count_indels(indel_file2)\n\nmerged['num.noindel.1'] = merged['junction'].map(noindel_counts1)\nmerged['num.indel.1'] = merged['junction'].map(indel_counts1)\nmerged['num.noindel.2'] = merged['junction'].map(noindel_counts2)\nmerged['num.indel.2'] = merged['junction'].map(indel_counts2)\n\nBadFJ1_sams = args.bad_fj_sam\nBadFJ2_sams = args.bad_fj_2_sam\nbadfj1s = get_badfjs(BadFJ1_sams)\nbadfj2s = get_badfjs(BadFJ2_sams)\n\nprint \"Badfj1s: \" + str(len(badfj1s))\n\nmerged['badfj.1'] = merged['junction'].map(badfj1s)\nmerged['badfj.2'] = merged['junction'].map(badfj2s)\nmerged['badfj.1'].fillna(0,inplace=True)\nmerged['badfj.2'].fillna(0,inplace=True)\n\nprint len(merged[merged['badfj.1'] > 0])\n\nif args.knife_glm:\n    gene_counts = defaultdict(int)\n    with open(args.knife_glm) as h:\n        h.readline()\n        for line in h:\n            jct, count, log_sum, posterior = line.split('\\t')[:4]\n            if float(posterior) > 0.8:\n                chrom, gene1, pos1, gene2, pos2, kind, strand = re.split(':|\\|', jct)\n                gene_counts[gene1] = max(gene_counts[gene1], int(count))\n                gene_counts[gene2] = max(gene_counts[gene2], int(count))\n\n    merged['exon.1'] = merged['gene1'].map(gene_counts)\n    merged['exon.2'] = merged['gene2'].map(gene_counts)\n    merged['exon.1'].fillna(0, inplace=True)\n    merged['exon.2'].fillna(0, inplace=True)\n\nelse:\n    merged['exon.1'] = -1\n    merged['exon.2'] = -1\n\nfive_prime  = {}\nthree_prime = {}\n\nwith open(args.five_prime, \"r\") as f:\n    while True:\n        line = f.readline()\n        if not line:\n            break\n        junction_id = line.split(\"\\t\")[0]\n        if len(junction_id) >= 255:\n            for junction in merged[\"junction\"]:\n                if junction.startswith(junction_id):\n                    junction_id = junction\n\n        five_prime[junction_id] = line.split(\"\\t\")[4]\n\nwith open(args.three_prime, \"r\") as f:\n    while True:\n        line = f.readline()\n        if not line:\n            break\n        junction_id = line.split(\"\\t\")[0]\n        if len(junction_id) >= 255:\n            for junction in merged[\"junction\"]:\n                if junction.startswith(junction_id):\n                    junction_id = junction\n        three_prime[junction_id] = line.split(\"\\t\")[4]\n\nmerged[\"five_prime_qual\"] = merged['junction'].map(five_prime)\nmerged[\"three_prime_qual\"] = merged['junction'].map(three_prime)\n\nid_to_seq = {}\nwith open(args.novel_junctions,'r') as fasta_file:\n    while True:\n        header = fasta_file.readline()\n        if not header:\n            break\n\n        jct_id = header[1:].strip()\n        seq = fasta_file.readline().strip()\n        id_to_seq[jct_id] = seq\n\nmerged['seq'] = merged['junction'].map(id_to_seq)\nmerged[\"pos1\"] = merged[\"pos1\"].astype(int)\nmerged[\"pos2\"] = merged[\"pos2\"].astype(int)\n\nif args.spork_glm:\n    badfj1s = merged[merged['badfj.1'] > 0]\n    badfj1s_badfj2s = merged[(merged[\"badfj.1\"] > 0) & (merged[\"numReads.x\"] > 1)]\n    badfj1_no_fusions = merged[(merged[\"badfj.1\"] > 0) & (merged[\"chr1\"] == merged[\"chr2\"]) & (merged[\"strand1\"] == merged[\"strand2\"]) & (abs(merged[\"pos1\"] - merged[\"pos2\"]) < 100000)]\n    badfj1_fusions = merged[(merged[\"badfj.1\"] > 0 & ((merged[\"chr1\"] != merged[\"chr2\"]) | (merged[\"strand1\"] != merged[\"strand2\"]) | (abs(merged[\"pos1\"] - merged[\"pos2\"]) >= 100000)))]\n    total_badfj1s = len(badfj1s)\n    total_badfj1s_badfj2s = len(badfj1s_badfj2s)\n    total_badfj1_no_fusions = len(badfj1_no_fusions)\n    total_badfj1_fusions = len(badfj1_fusions)\n    emp_ps = []\n    emp_ps_2 = []\n    emp_ps_3 = []\n\n    for row in merged.itertuples():\n\n        num_greater = sum(badfj1s['junction_cdf_y'] > row.junction_cdf_y)\n        num_greater_2 = sum(badfj1s_badfj2s['junction_cdf_y'] > row.junction_cdf_y)\n\n        if (row.chr1 == row.chr2) and (row.strand1 == row.strand2) and (abs(row.pos1 - row.pos2) < 100000):\n            num_greater_3 = sum(badfj1_no_fusions['junction_cdf_y'] > row.junction_cdf_y)\n        else:\n            num_greater_3 = sum(badfj1_fusions['junction_cdf_y'] > row.junction_cdf_y)\n\n        if total_badfj1s == 0:\n            emp_ps.append(1)\n        else:\n            emp_ps.append(float(num_greater)/total_badfj1s)\n\n        if total_badfj1s_badfj2s == 0:\n            emp_ps_2.append(1)\n        else: emp_ps_2.append(float(num_greater_2)/total_badfj1s_badfj2s)\n\n        if (row.chr1 == row.chr2) and (row.strand1 == row.strand2) and (abs(row.pos1 - row.pos2) < 100000):\n            if total_badfj1_no_fusions == 0:\n                emp_ps_3.append(1)\n            else: emp_ps_3.append(float(num_greater_3)/total_badfj1_no_fusions)\n        else:\n            if total_badfj1_fusions == 0:\n                emp_ps_3.append(1)\n            else: emp_ps_3.append(float(num_greater_3)/total_badfj1_fusions)\n\n\n    merged['emp.p'] = emp_ps\n    merged['emp.p.2'] = emp_ps_2\n    merged['emp.p.3'] = emp_ps_3\n\n#merged.to_csv(appended_report,sep='\\t',index=False)\n\nrename_dict = {'junction_cdf_y': 'junction.cdf.y'}\n\nmerged.rename(columns=rename_dict, inplace=True)\n\nmerged_list = []\nfor index, item in merged.iterrows():\n    tmp_list = [item[0]]\n    tmp_list.extend(list(item[1:]))\n    merged_list.append(tmp_list)\n    if item[0] in reverse_duplicate_junctions:\n        for new_junction_name in reverse_duplicate_junctions[item[0]]:\n            tmp_list_new = [new_junction_name + \"|DUPLICATE\"]\n            tmp_list_new.extend(list(item[1:]))\n            merged_list.append(tmp_list_new)\n    if item[0] in reverse_seq_duplicate_junctions:\n        for new_junction_name in reverse_seq_duplicate_junctions[item[0]]:\n            tmp_list_new = [new_junction_name + \"|SAME_SEQUENCE\"]\n            tmp_list_new.extend(list(item[1:]))\n            merged_list.append(tmp_list_new)\n\nmerged_df = pd.DataFrame(merged_list,columns=merged.columns)\nmerged_df.to_csv(appended_report,sep='\\t',index=False)",
                "filename": "appended_report.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine"
          }
        ],
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-uf"
            },
            "id": "#uniformity_pvalue",
            "sbg:altPrefix": "--uniformity_pvalue",
            "required": false
          },
          {
            "inputBinding": {
              "prefix": "-3p",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#three_prime_sam",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--suffix",
            "inputBinding": {
              "prefix": "-suf",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--spork_glm",
            "inputBinding": {
              "prefix": "-sglm",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#spork_glm",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--seq_duplicate_junction",
            "inputBinding": {
              "prefix": "-sdj",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#seq_duplicate_junction",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--novel_junctions",
            "inputBinding": {
              "prefix": "-nj",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#novel_junctions",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--naive_report",
            "inputBinding": {
              "prefix": "-nr",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#naive_report",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--knife_glm",
            "inputBinding": {
              "prefix": "-kglm",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#knife_glm",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--indels_histogram",
            "inputBinding": {
              "prefix": "-ih",
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": " "
            },
            "id": "#indels_histogram",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "prefix": "-5p",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#five_prime_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:fileTypes": "PICKLE, pickle",
            "inputBinding": {
              "prefix": "-dj",
              "separate": true,
              "sbg:cmdInclude": true
            },
            "id": "#duplicate_junction",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--bad_fj_sam",
            "inputBinding": {
              "prefix": "-bfjs",
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": " "
            },
            "id": "#bad_fj_sam",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--bad_fj_2_sam",
            "inputBinding": {
              "prefix": "-bfj2s",
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": " "
            },
            "id": "#bad_fj_2_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_naive_report_Appended*",
              "sbg:inheritMetadataFrom": "#novel_junctions"
            },
            "id": "#naive_report_Appended",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7",
            "class": "DockerRequirement"
          }
        ],
        "baseCommand": [
          "python",
          "appended_report.py"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n\tif($job.inputs.novel_junctions && $job.inputs.novel_junctions.metadata && $job.inputs.novel_junctions.metadata.sample_id)\n      return \"-s \" + $job.inputs.novel_junctions.metadata.sample_id\n}"
            }
          }
        ],
        "sbg:cmdPreview": "python appended_report.py  -s sample name",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:image_url": null,
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434246,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434268,
            "sbg:revisionNotes": "revision 6 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520889518,
            "sbg:revisionNotes": "3p and 5p included"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528071951,
            "sbg:revisionNotes": "filter reg/scrambled fj junctions updated; emp.p.2 added"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528102316,
            "sbg:revisionNotes": "appended_report.py updated"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529936349,
            "sbg:revisionNotes": "emp.p.2 modified: merged[(merged[\"badfj.1\"] > 0) & (merged[\"numReads.x\"] > 1)]"
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530277007,
            "sbg:revisionNotes": "duplicate_junctions added"
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530278704,
            "sbg:revisionNotes": "duplicate_junctions fixed"
          },
          {
            "sbg:revision": 8,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533646620,
            "sbg:revisionNotes": "filter badfj.1 fixed"
          },
          {
            "sbg:revision": 9,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533686432,
            "sbg:revisionNotes": "alignment_score typo fixed"
          },
          {
            "sbg:revision": 10,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537529637,
            "sbg:revisionNotes": "seq_duplicate_junction added"
          },
          {
            "sbg:revision": 11,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537722786,
            "sbg:revisionNotes": "similar_seq added"
          },
          {
            "sbg:revision": 12,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537954419,
            "sbg:revisionNotes": "back to rev:10"
          },
          {
            "sbg:revision": 13,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1539077750,
            "sbg:revisionNotes": "parse_locs includes break-point and at_boundary"
          },
          {
            "sbg:revision": 14,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545868883,
            "sbg:revisionNotes": "seq_duplicate_junction removed"
          },
          {
            "sbg:revision": 15,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1546011904,
            "sbg:revisionNotes": "|SAME_SEQUENCE|DUPLICATE and |SIMILAR_SEQUENCE|DUPLICATE added"
          },
          {
            "sbg:revision": 16,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550769719,
            "sbg:revisionNotes": "collapsed_num and uniformity_score added to parse_locs"
          },
          {
            "sbg:revision": 17,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550804373,
            "sbg:revisionNotes": "typo fixed"
          },
          {
            "sbg:revision": 18,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550979890,
            "sbg:revisionNotes": "uniformity_pvalue as input"
          },
          {
            "sbg:revision": 19,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550981943,
            "sbg:revisionNotes": "emp.p.3 added"
          },
          {
            "sbg:revision": 20,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550982202,
            "sbg:revisionNotes": "\"badfj.1\" fixed"
          },
          {
            "sbg:revision": 21,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550982513,
            "sbg:revisionNotes": "and, or fixed"
          },
          {
            "sbg:revision": 22,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550983049,
            "sbg:revisionNotes": "pos1, pos2 int type"
          },
          {
            "sbg:revision": 23,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550983306,
            "sbg:revisionNotes": "\"junction.cdf.y\" fixed"
          },
          {
            "sbg:revision": 24,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1551084107,
            "sbg:revisionNotes": "short jct_id fixed"
          },
          {
            "sbg:revision": 25,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1551091746,
            "sbg:revisionNotes": "en(jct_id) >= 255"
          },
          {
            "sbg:revision": 26,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1553502306,
            "sbg:revisionNotes": "chr1/2 and five_prime, three_prime fixed"
          },
          {
            "sbg:revision": 27,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1553596392,
            "sbg:revisionNotes": "appended_report three_prime[junction_id] fixed"
          }
        ],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "duplicate_junction": {
              "size": 0,
              "class": "File",
              "path": "/path/to/duplicate_junction.pickle",
              "secondaryFiles": []
            },
            "knife_glm": {
              "size": 0,
              "class": "File",
              "path": "/path/to/knife_glm.ext",
              "secondaryFiles": []
            },
            "indels_histogram": [
              {
                "size": 0,
                "class": "File",
                "path": "/path/to/indels_histogram_1-1.ext",
                "secondaryFiles": []
              },
              {
                "size": 0,
                "class": "File",
                "path": "/path/to/indels_histogram_1-2.ext",
                "secondaryFiles": []
              }
            ],
            "novel_junctions": {
              "class": "File",
              "size": 0,
              "metadata": {
                "sample_id": "sample name"
              },
              "path": "/path/to/novel_junctions.ext",
              "secondaryFiles": []
            },
            "naive_report": {
              "size": 0,
              "class": "File",
              "path": "/path/to/naive_report.ext",
              "secondaryFiles": []
            },
            "seq_duplicate_junction": {
              "class": "File",
              "secondaryFiles": [],
              "path": "/path/to/seq_duplicate_junction.ext",
              "size": 0
            },
            "spork_glm": {
              "size": 0,
              "class": "File",
              "path": "/path/to/spork_glm.ext",
              "secondaryFiles": []
            },
            "three_prime_sam": {
              "size": 0,
              "class": "File",
              "path": "/path/to/three_prime_sam.ext",
              "secondaryFiles": []
            },
            "bad_fj_2_sam": [
              {
                "size": 0,
                "class": "File",
                "path": "/path/to/bad_fj_2_sam-1.ext",
                "secondaryFiles": []
              },
              {
                "size": 0,
                "class": "File",
                "path": "/path/to/bad_fj_2_sam-2.ext",
                "secondaryFiles": []
              }
            ],
            "five_prime_sam": {
              "size": 0,
              "class": "File",
              "path": "/path/to/five_prime_sam.ext",
              "secondaryFiles": []
            },
            "bad_fj_sam": [
              "bad_fj_sam-string-value-1",
              "bad_fj_sam-string-value-2"
            ],
            "suffix": "suffix-string-value",
            "uniformity_pvalue": {
              "path": "/path/to/uniformity_pvalue.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          }
        },
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/appendedreportspork/27",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/appendedreportspork/27",
        "sbg:revision": 27,
        "sbg:revisionNotes": "appended_report three_prime[junction_id] fixed",
        "sbg:modifiedOn": 1553596392,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520434246,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "sbg:latestRevision": 27,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a21a273e95e1b4f26b1022f60f68d4765af14154d9033329b8162258eb9051e41",
        "x": 6451.674897962467,
        "y": 86.66696798802609,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/appendedreportspork/27"
      },
      "inputs": [
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.uniformity_pvalue",
          "source": [
            "#SPORK_uniformity_pvalue.output_file"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.three_prime_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.result_sam_file"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.suffix",
          "default": "_SPORK_With_Building_Reads"
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.spork_glm",
          "source": [
            "#GLM_script_UseIndel_SPORK_With_Building_Reads.fusion_w_anomaly_and_indel_juncp_out_lef_join"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.seq_duplicate_junction",
          "source": [
            "#SPORK_BadFJ3.seq_duplicates"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.novel_junctions",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.naive_report",
          "source": [
            "#SPORK_FarJuncNaiveReport.naive_report"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.knife_glm",
          "source": [
            "#KNIFE_GLM_model.linear_junc_probs"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.indels_histogram",
          "source": [
            "#SPORK_MakeIndelsHisto.indels_txt"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.five_prime_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.result_sam_file"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.duplicate_junction",
          "source": [
            "#SPORK_BadFJ3.duplicate_junctions"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.bad_fj_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.result_sam_file"
          ]
        },
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.bad_fj_2_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#AppendedReportSPORK_With_Building_Reads.naive_report_Appended"
        }
      ],
      "sbg:x": 6451.674897962467,
      "sbg:y": 86.66696798802609
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List 5 prime",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 1928.3337764342782,
        "y": -271.6146756389937
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.read_sequence",
          "source": [
            "#SPORK_combine_and_split_unaligned_reads.5prime"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.output_file_suffix",
          "default": "5prime"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.number_of_cpu",
          "default": 1
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5_prime.aligned_reads_only"
        }
      ],
      "sbg:x": 1928.3337764342782,
      "sbg:y": -271.6146756389937
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List 3 prime",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 1928.333654363961,
        "y": 28.385434324957277
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.read_sequence",
          "source": [
            "#SPORK_combine_and_split_unaligned_reads.3prime"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.output_file_suffix",
          "default": "3prime"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.number_of_cpu",
          "default": 1
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3_prime.aligned_reads_only"
        }
      ],
      "sbg:x": 1928.333654363961,
      "sbg:y": 28.385434324957277
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Junctions",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 2668.3336801926407,
        "y": -113.28122565274353
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.suppress_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.read_sequence",
          "source": [
            "#SPORK_concatenate_files.don_fasta",
            "#SPORK_concatenate_files.acc_fasta"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.output_file_suffix"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.number_of_cpu",
          "default": 1
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.maximum_fragment_length",
          "default": 500000
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.ignore_paired_end_metadata"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Junctions.aligned_reads_only"
        }
      ],
      "sbg:x": 2668.3336801926407,
      "sbg:y": -113.28122565274353
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Scrambled FJ",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 4230.002284103057,
        "y": 128.38529071749394
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.threads",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.read_sequence",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.output_file_suffix",
          "default": "scrambled_FJ"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.number_of_cpu",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_scrambled_junctions"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 4230.002284103057,
      "sbg:y": 128.38529071749394
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular FJ",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 4230.002121210178,
        "y": -8.281388942985666
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.threads",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.read_sequence",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.output_file_suffix",
          "default": "regular_FJ"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.number_of_cpu",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_junctions"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 4230.002121210178,
      "sbg:y": -8.281388942985666
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Transcriptome FJ",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 4230.001632730226,
        "y": -158.28144673300216
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.threads",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.read_sequence",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.output_file_suffix",
          "default": "transcriptome_FJ"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.number_of_cpu",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_transcriptome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 4230.001632730226,
      "sbg:y": -158.28144673300216
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Genome FJ",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 4235.0024469959335,
        "y": -274.9482041709236
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.threads",
          "default": 5
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.read_sequence",
          "source": [
            "#SPORK_linkfastafiles.concat_far_junctions"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.output_file_suffix",
          "default": "genome_FJ"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.number_of_cpu",
          "default": 5
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 4235.0024469959335,
      "sbg:y": -274.9482041709236
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Genome PE",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 4573.334841118973,
        "y": -269.94807954422885
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.threads",
          "default": 6
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.reference_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.read_sequence",
          "source": [
            "#SPORK_SplitFastaforBadFJ.fusion_junction_fq1",
            "#SPORK_SplitFastaforBadFJ.fusion_junction_fq2"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.read_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.output_file_suffix",
          "default": "genome_PE"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.number_of_cpu",
          "default": 6
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.maximum_fragment_length",
          "default": 500000
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.ignore_paired_end_metadata"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.function_score_min"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.constant_scoremin_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.coefficient_scoremin_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.aligned_reads_only"
        }
      ],
      "sbg:x": 4573.334841118973,
      "sbg:y": -269.94807954422885
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Transcriptome PE",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 4573.334336347086,
        "y": -153.28139326101044
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.threads",
          "default": 6
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.reference_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.read_sequence",
          "source": [
            "#SPORK_SplitFastaforBadFJ.fusion_junction_fq1",
            "#SPORK_SplitFastaforBadFJ.fusion_junction_fq2"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.read_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.output_file_suffix",
          "default": "transcriptome_PE"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.number_of_cpu",
          "default": 6
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.maximum_fragment_length",
          "default": 500000
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.ignore_paired_end_metadata"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.function_score_min"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.constant_scoremin_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.coefficient_scoremin_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_transcriptome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.aligned_reads_only"
        }
      ],
      "sbg:x": 4573.334336347086,
      "sbg:y": -153.28139326101044
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular PE",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 4575.0013188654,
        "y": -18.28143803072333
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.threads",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.sort_sam",
          "default": false
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.reference_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.read_sequence",
          "source": [
            "#SPORK_SplitFastaforBadFJ.fusion_junction_fq1",
            "#SPORK_SplitFastaforBadFJ.fusion_junction_fq2"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.read_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.output_file_suffix",
          "default": "regular_PE"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.number_of_cpu",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.maximum_fragment_length",
          "default": 500000
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.ignore_paired_end_metadata"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.function_score_min"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.constant_scoremin_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.coefficient_scoremin_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_junctions"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.aligned_reads_only"
        }
      ],
      "sbg:x": 4575.0013188654,
      "sbg:y": -18.28143803072333
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Scrambled PE",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 4576.668474806746,
        "y": 118.3852354441176
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.threads",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.reference_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.read_sequence",
          "source": [
            "#SPORK_SplitFastaforBadFJ.fusion_junction_fq2",
            "#SPORK_SplitFastaforBadFJ.fusion_junction_fq1"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.read_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.output_file_suffix",
          "default": "scrambled_PE"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.number_of_cpu",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.maximum_fragment_length",
          "default": 500000
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.ignore_paired_end_metadata"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.function_score_min"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.constant_scoremin_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.coefficient_scoremin_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_scrambled_junctions"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.aligned_reads_only"
        }
      ],
      "sbg:x": 4576.668474806746,
      "sbg:y": 118.3852354441176
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 5 R2",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5805.00118537748,
        "y": 308.3854888963229
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.output_file_suffix",
          "default": "RegIndels2"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.input_fasta_files",
          "default": false
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_5"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R2.aligned_reads_only"
        }
      ],
      "sbg:x": 5805.00118537748,
      "sbg:y": 308.3854888963229
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 3 R2",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5693.334028045359,
        "y": 185.05215119198218
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.output_file_suffix",
          "default": "RegIndels2"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_3"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R2.aligned_reads_only"
        }
      ],
      "sbg:x": 5693.334028045359,
      "sbg:y": 185.05215119198218
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 4 R2",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5928.334684981289,
        "y": 185.05217715311736
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.sort_sam",
          "default": false
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.output_file_suffix",
          "default": "RegIndels2"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_4"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R2.aligned_reads_only"
        }
      ],
      "sbg:x": 5928.334684981289,
      "sbg:y": 185.05217715311736
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 2 R2",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5905.001215974532,
        "y": 50.052134383471824
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.output_file_suffix",
          "default": "RegIndels2"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_2"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R2.aligned_reads_only"
        }
      ],
      "sbg:x": 5905.001215974532,
      "sbg:y": 50.052134383471824
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 1 R2",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String",
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ],
            "required": false
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5720.001374893767,
        "y": 55.05216331159323,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3"
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.output_file_suffix",
          "default": "RegIndels2"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_1"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R2.aligned_reads_only"
        }
      ],
      "sbg:x": 5720.001374893767,
      "sbg:y": 55.05216331159323
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 1 R1",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5695.001365158342,
        "y": -429.94819823694974
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.read_sequence",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.output_file_suffix",
          "default": "RegIndels1"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_1"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_1_R1.aligned_reads_only"
        }
      ],
      "sbg:x": 5695.001365158342,
      "sbg:y": -429.94819823694974
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 2 R1",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5913.334217561645,
        "y": -426.6146915070751
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.read_sequence",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.output_file_suffix",
          "default": "RegIndels1"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_2"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_2_R1.aligned_reads_only"
        }
      ],
      "sbg:x": 5913.334217561645,
      "sbg:y": -426.6146915070751
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 4 R1",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5918.334847079438,
        "y": -299.9480133433343
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.read_sequence",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.output_file_suffix",
          "default": "RegIndels1"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.input_fasta_files",
          "default": false
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_4"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_4_R1.aligned_reads_only"
        }
      ],
      "sbg:x": 5918.334847079438,
      "sbg:y": -299.9480133433343
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 3 R1",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5693.334696504853,
        "y": -291.6147271638997
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.read_sequence",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.output_file_suffix",
          "default": "RegIndels1"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_3"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_3_R1.aligned_reads_only"
        }
      ],
      "sbg:x": 5693.334696504853,
      "sbg:y": -291.6147271638997
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Regular Indels 5 R1",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 5810.0008862151335,
        "y": -553.2813149934861
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.read_sequence",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.output_file_suffix",
          "default": "RegIndels1"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.number_of_cpu",
          "default": 4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels_5"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_Indels_5_R1.aligned_reads_only"
        }
      ],
      "sbg:x": 5810.0008862151335,
      "sbg:y": -553.2813149934861
    },
    {
      "id": "#SPORK_Create_Junctions",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK Create Junctions",
        "description": "",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# General Imports\nfrom collections import defaultdict\nimport subprocess\nimport itertools\nimport zlib\nimport time\nimport sys\nimport os\nimport re\n\n# Specific Imports\nfrom SPORK_consensus_utils import *\nfrom SPORK_Junction import Junction\nfrom SPORK_BinPair import BinPair\nfrom SPORK_GTFEntry import GTFEntry\nfrom SPORK_SAMEntry import SAMEntry\nfrom SPORK_FastQEntry import FastQEntry\n\n\n\ndef get_ref_seq(read_seq, MD):\n\n    cur_pos = 0\n    reference_string = \"\"\n    k = 0\n    for i, c in enumerate(MD):\n        if c.isdigit():\n            continue\n        if cur_pos != i:\n            num_matches = int(MD[cur_pos:i])\n        else:\n            num_matches = 0\n        reference_string += read_seq[k: k + num_matches]\n        reference_string += c\n        cur_pos = i + 1\n        k = k + num_matches + 1\n    reference_string += read_seq[k:]\n\n    return reference_string\n\n#######################################\n#   Get Reference and GTF from Mode   #\n#######################################\n# Finding the correct reference index based on the mode\n# Human defaults are used and currently the only supported mode\n# Could imagine lots of if else statements with other supported references though\n# Putting this in the utils file should allow for easy reference addition\ndef get_reference_and_gtf_from_mode(ref_dir, abs_path, mode=\"hg19\"):\n    \"\"\"\n    Goal: take in the desired mode and return the index and gtf path\n    Arguments:\n        the path to the circ_ref directory that MACHETE also uses\n        the mode (currently only allows hg19, so this function is mostly for show)\n        will become an 'elif' tree as more and more indicies are added\n\n    Returns:\n        a tuple of (reference_path,gtf_path)\n    \"\"\"\n    # index_path = \"/scratch/PI/horence/rob/index/\"\n    # reference = index_path+\"hg19\"\n    reference = ref_dir\n    gtf_path = \"\"\n    if mode == \"hg19\":\n        sys.stdout.write('SPORK: Reference using hg19\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"hg19_gtfs\")\n        reference = os.path.join(reference, \"hg19_genome\")\n\n    elif mode == \"grch38\":\n        sys.stdout.write('SPORK: Reference using grch38\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"grch38_gtfs\")\n        reference = os.path.join(reference, \"grch38_genome\")\n\n    elif mode == \"mm10\":\n        sys.stdout.write('SPORK: Reference using mm10\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"mm10_gtfs\")\n        reference = os.path.join(reference, \"mm10_genome\")\n\n    return reference, gtf_path\n\n\n#################################\n#   Find Bin Pair Group Ranges  #\n#################################\n# Run through the bin pair groupings to find the end index of each group\n# Example bin pair list:\n# [0] chr10:45_chr10:55\n# [2] chr10:45_chr10:55\n# [3] chr10:98_chr10:99\n# [4] chr10:145_chr10:155\n# [5] chr10:145_chr10:155\n# [6] chr10:145_chr10:155\n#\n# Output: [2,3,6]\ndef find_bin_pair_group_ranges(bin_pairs, constants_dict, bin_pairs_ids):\n    \"\"\"\n    Goal: take in a sorted list of bin_pairs and collapse them to ranges\n    Arguments:\n        bin_pairs is a list[BinPair] of the bin pairs\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        bin_pair_group_ranges which is a list[[start0,stop0],[start1,stop1],...]\n        also filters out groups that have less then a cutoff of members\n    \"\"\"\n    bin_pair_group_ends = []\n    prev_bin_pair = \"\"\n    for bin_pair_ind in range(len(bin_pairs)):\n        curr_bin_pair = bin_pairs[bin_pair_ind].bin_pair\n        if curr_bin_pair != prev_bin_pair:\n            bin_pair_group_ends.append(bin_pair_ind)\n            prev_bin_pair = curr_bin_pair\n\n    # Remove the 0 at the front of the bin_pair list\n    bin_pair_group_ends = bin_pair_group_ends[1:]\n\n    # Add on the last bin_pair end which will necessarily be the end of the bin_pair list\n    bin_pair_group_ends.append(len(bin_pairs))\n\n    # Find the bin pair ranges\n    bin_pair_group_ranges = []\n    to_remove_bin_pairs = []\n    to_keep_bin_pairs = []\n    for bin_pair_ind in range(len(bin_pair_group_ends) - 1):\n        start_ind = bin_pair_group_ends[bin_pair_ind]\n        stop_ind = bin_pair_group_ends[bin_pair_ind + 1]\n        if stop_ind - start_ind >= (constants_dict[\"group_member_cutoff\"]):  # The \"-1\" is for inclusive counting\n            bin_pair_group_ranges.append([start_ind, stop_ind])\n        else:\n            org_bin_pair = bin_pairs[start_ind].bin_pair\n            left_chr = org_bin_pair.split(\":\")[0]\n            left_pos = org_bin_pair.split(\":\")[1].split(\"_\")[0]\n            right_chr = \"_\".join(org_bin_pair.split(\":\")[1].split(\"_\")[1:])\n            right_pos = org_bin_pair.split(\":\")[2].split(\"_\")[0]\n            strand_left = \"+\" if org_bin_pair.split(\":\")[2].split(\"_\")[1][1] == \"-\" else \"-\"\n            strand_right = \"+\" if org_bin_pair.split(\":\")[2].split(\"_\")[1][3] == \"-\" else \"-\"\n\n            reverse_bin_pair = right_chr + \":\" + right_pos + \"_\" + left_chr + \":\" + left_pos + \"_(\" + strand_right + \",\" + strand_left + \")\"\n            if reverse_bin_pair in bin_pairs_ids:\n                bin_pair_group_ranges.append([start_ind, stop_ind])\n                to_keep_bin_pairs.append(org_bin_pair)\n            else:\n                to_remove_bin_pairs.append(org_bin_pair)\n    # print bin_pair_group_ends\n    # print bin_pair_group_ranges\n    # sys.stdout.flush()\n\n    #with open(\"to_remove_bin_pairs.txt\", \"w\") as f:\n    #    for bin_pair in to_remove_bin_pairs:\n    #        f.write(bin_pair + \"\\n\")\n\n    #with open(\"to_keep_bin_pairs.txt\", \"w\") as f:\n    #    for bin_pair in to_keep_bin_pairs:\n    #        f.write(bin_pair + \"\\n\")\n\n    return bin_pair_group_ranges\n\n\n\n################################\n#   Build Junction Sequences   #\n################################\n# Run through the bin_pair_group_ends to perform:\n# (1) checking if there are enough in each group\n# (2) padding the sequences in the first bin\n# (3) creating a consensus in the first bin\n# (4) scoring the consensus in the first bin\n# (5) repeat (2)-(4) for the second bin\n# (6) average the two consensus scores and see if they are below a cutoff\ndef build_junction_sequences(bin_pairs, bin_pair_group_ranges, full_path_name, constants_dict, read_num_to_read_id):\n    \"\"\"\n    Goal: convert the bin_pairs into a junction object for each bin_pair\n    Arguments:\n        bin_pairs is a list[BinPairs]\n        bin_pair_group_ranges is a list[[start0,stop0],[start1,stop1],...] so its a list of list\n        full_path_name is the 'spaces-removed' file that is looked at to get the full sequences\n            -> this is used to build the consensus for the junction\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        denovo_junctions which is a list[Junction]\n    \"\"\"\n    group_member_cutoff = constants_dict[\"group_member_cutoff\"]\n    consensus_score_cutoff = constants_dict[\"consensus_score_cutoff\"]\n    bin_size = constants_dict[\"bin_size\"]\n    #reference = constants_dict[\"reference\"]\n    denovo_junctions = []\n\n    # Look back at the original full path to get seq lines\n    unaligned_file = open(full_path_name, \"r\")\n    unaligned_reads = unaligned_file.readlines()\n    unaligned_file.close()\n    unaligned_reads = [unaligned_reads[ind] for ind in range(len(unaligned_reads)) if ind % 4 == 0 or ind % 4 == 1]\n    id_to_seq = {}\n\n    # Build the dictionary of read_id to the full read\n    for ind in range(0, len(unaligned_reads), 2):\n        key = unaligned_reads[ind].strip()\n        value = unaligned_reads[ind + 1].strip()\n        id_to_seq[key] = value\n\n    # walk through each bin_pair_group\n    #write_time(\"Working on the bin-pairs :\" + str(len(bin_pair_group_ranges)), time.time(), constants_dict[\"timer_file_path\"])\n\n    num_fail_size = 0\n    num_fail_score = 0\n    jct_ind = 0\n    for bin_pair_group_range in bin_pair_group_ranges:\n        # junction_num = \"(\"+str(bin_pair_group_ranges.index(bin_pair_group_range)+1)+\"/\"+str(len(bin_pair_group_ranges))+\")\"\n        # print junction_num\n        # sys.stdout.flush()\n\n        # start_build_junction = time.time()\n        start_ind = bin_pair_group_range[0]\n        stop_ind = bin_pair_group_range[1]\n        group_members = bin_pairs[start_ind:stop_ind]\n\n        # If there are not enough group members then skip this group\n        #if len(group_members) < group_member_cutoff:\n            # sys.stderr.write(\"Skipped group in build junction seqs\\n\") #expecting to have filtered out before this\n            # sys.stderr.write(\"len(group_members) == \"+str(len(group_members))+\"\\n\")\n            #num_fail_size += 1\n            #continue\n\n        # Otherwise start thinking about getting strandedness\n        five_prime_strand = group_members[0].five_prime_strand\n        three_prime_strand = group_members[0].three_prime_strand\n\n        # Find the consensus sequence and score\n        # Takes just the 5' ends to get the pos\n        # the full original unaligned seq\n        mapped_reads = [member.five_prime_SAM for member in group_members]\n        bin_consensus, bin_score = build_and_score_consensus(mapped_reads, five_prime_strand, id_to_seq, bin_size, constants_dict, read_num_to_read_id)\n        took_reverse_compliment = False\n\n        \"\"\"\n        # TODO what do I do if the five and three prime strands are not the same? (this represents a translocation)\n        # If the reverse compliment was taken above then take the rev compliment of the consensus too\n        # NOTE currently just taking reverse compliment whenever the 5' strand is negative to help groupings\n        #   i.e. if have 5' - and 3' + of a jct and 5' + and 3' - of the same jct, they should be collapsed, but won't be\n        #   unless I implement this\n        #if five_prime_strand == \"-\" and three_prime_strand == \"-\":\n        if five_prime_strand == \"-\":\n            group_members = [member.take_reverse_compliment() for member in group_members]\n            bin_consensus = reverse_compliment(bin_consensus)\n            took_reverse_compliment = True\n\n        \"\"\"\n        # If the bin score is good enough then add it\n        if bin_score < consensus_score_cutoff:\n            denovo_junction = Junction(bin_consensus, bin_score, group_members, jct_ind, took_reverse_compliment, constants_dict)\n            denovo_junctions.append(denovo_junction)\n            jct_ind += 1\n        else:\n            num_fail_score += 1\n\n    #write_time(\"Filtered out bin-pairs by size < \" + str(group_member_cutoff) + \" :\" + str(num_fail_size), time.time(), constants_dict[\"timer_file_path\"])\n    #write_time(\"Filtered out bin-pairs by score < \" + str(consensus_score_cutoff) + \" :\" + str(num_fail_score), time.time(), constants_dict[\"timer_file_path\"])\n    #write_time(\"Number of jcts after build jcts: \" + str(jct_ind), time.time(), constants_dict[\"timer_file_path\"])\n    return denovo_junctions\n\n\n##########################\n#   Find Splice Inds V2  #\n##########################\n# Runs bowtie on all of the possible splice sites of all possible junctions\n# Returns a dict keyed by jct_id and valued by a list of cut sites\ndef find_splice_inds_v2(denovo_junctions, constants_dict):\n    \"\"\"\n    Goal: find where in the consensus sequence to make and donor and acceptor cut\n    Arguments:\n        denovo_junctions is a list[Junction]\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        returns a tuple of (jcts_with_splice,jcts_without_splice)\n        to allow for continuing with only jcts that had a splice site found\n\n    Program flow:\n        1. Write all possible splice cuts for all possible\n           consensus seq jcts to a fasta file\n\n        2. Map this file to the genome reference\n           --> Don't allow gaps\n           --> Report the best k unique multiple mappings for each read\n\n        3. Look through the mapping file for each junction to find the best splice site\n           --> Preference should primarily be given to splits that map close to each other\n           --> Next preference is the most amount of the consensus successfully mapped\n    \"\"\"\n\n    # Get parameters from the constants_dict\n    splice_fasta_path = os.path.join(constants_dict[\"output_dir\"], \"putative_splices.fa\")\n    splice_mapped_path = os.path.join(constants_dict[\"output_dir\"], \"putative_splices.sam\")\n    flank_len = constants_dict[\"splice_finding_flank\"]\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    max_mismatches = int(constants_dict[\"splice_finding_allowed_mismatches\"])\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n    n_multimap = \"10\"\n\n    # 1. Write all possible splice cuts for all possible jcts to a fasta\n    #   if seq is abcdefghijklmnopqrstuvwxyz and thirds_len = 10 then you would want:\n    #       [abcdefghij]|[klmnopqrst]uvwxyz\n    #       a[bcdefghijk]|[lmnopqrstu]vwxyz\n    #       ab[cdefghijkl]|[mnopqrstuv]wxyz\n    #       abc[defghijklm]|[nopqrstuvw]xyz\n    #       abcd[efghijklmn]|[opqrstuvwx]yz\n    #       abcde[fghijklmno]|[pqrstuvwxy]z\n    #       abcdef[ghijklmnop]|[qrstuvwxyz]\n    #   where the first [] group is don and second [] group is acc\n    with open(splice_fasta_path, 'w') as splice_fasta:\n        for jct in denovo_junctions:\n            seq = jct.consensus\n            jct_ind = jct.jct_ind\n            for split_ind in range(flank_len, len(seq) - flank_len + 1):\n                don_seq = seq[:split_ind][-flank_len:]\n                acc_seq = seq[split_ind:][:flank_len]\n                base_header = '>' + str(jct_ind) + '_' + str(split_ind)\n\n                splice_fasta.write(base_header + '_don\\n' + don_seq + '\\n')\n                splice_fasta.write(base_header + '_acc\\n' + acc_seq + '\\n')\n\n    # 2. Map the splice fasta to the genome reference\n    with open(splice_mapped_path, \"w\") as splice_mapped:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-hd\", \"--no-unal\", min_score, read_gap_score,\n             ref_gap_score, \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, splice_fasta_path],\n            stdout=splice_mapped)\n\n    # 3. Look through the mapping file for each junction to find the best splice site\n    #   no sorting guarantees so have to read all in at once\n    #   (could pre-sort if this is too mem intensive)\n\n    # Maybe this is poor coding, but splice_dict is a 3-deep default dictionary\n    #   the 1st level is the jct_index\n    #   the 2nd level is the splice_index\n    #   the 3rd level is either 'don' or 'acc'\n    # Could have made a flat dict with a combination key of the levels\n    #   but then I would have to keep track of what the jct and splice indices are\n    splice_dict = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))\n    with open(splice_mapped_path, \"r\") as splice_mapped:\n        for line in splice_mapped:\n            sam = SAMEntry(line)\n            jct_ind, split_ind, kind = sam.read_id.split('_')\n            splice_dict[jct_ind][split_ind][kind].append(sam)\n\n    # Internal splice comparing function\n    def compare_don_acc(best_don, best_acc, test_don, test_acc):\n        # None case\n        if best_don == None and best_acc == None:\n            return test_don, test_acc\n\n        # If one pair is on the same chr and the other is not\n        best_same_chr = best_don.chromosome == best_acc.chromosome\n        test_same_chr = test_don.chromosome == test_acc.chromosome\n        if test_same_chr and not best_same_chr:\n            return test_don, test_acc\n        if best_same_chr and not test_same_chr:\n            return best_don, best_acc\n\n        # NOTE could extend this to do strand comparisons\n\n        # Now the pairs share chr status determine by which dropped less sequence\n        best_len = len(best_don.seq) + len(best_acc.seq)\n        test_len = len(test_don.seq) + len(test_acc.seq)\n        if best_len > test_len:\n            return best_don, best_acc\n        if test_len > best_len:\n            return test_don, test_acc\n\n        # Now determine by number of mismatches\n        best_mismatches = best_don.num_mismatches + best_acc.num_mismatches\n        test_mismatches = test_don.num_mismatches + test_acc.num_mismatches\n        if best_mismatches > test_mismatches:\n            return test_don, test_acc\n        else:\n            return best_don, best_acc\n\n    # Loop through the jcts looking throughout the entire splice_dict\n    jcts_with_splice = []\n    jcts_wout_splice = []\n\n    for jct in denovo_junctions:\n        best_don, best_acc = None, None\n        jct_ind = str(jct.jct_ind)\n        for splice_ind in splice_dict[jct_ind]:\n            dons = splice_dict[jct_ind][splice_ind]['don']\n            accs = splice_dict[jct_ind][splice_ind]['acc']\n\n            # NOTE Just a print out to check for multimappings\n            # if len(dons) > 1 or len(accs) > 1:\n            #    sys.stdout.write('MULTIMAPPING: '+jct_ind+'_'+splice_ind+'\\n')\n\n            for don, acc in itertools.product(dons, accs):\n                best_don, best_acc = compare_don_acc(best_don, best_acc, don, acc)\n\n        # If there is no splice\n        if best_don == None or best_acc == None:\n            jcts_wout_splice.append(jct)\n            continue\n\n        # Otherwise update jct data\n        jct.consensus = best_don.seq + best_acc.seq\n        jct.donor_sam = best_don\n        jct.acceptor_sam = best_acc\n        jcts_with_splice.append(jct)\n\n    # Return the jcts\n    sys.stdout.write('WITH SPLICE: ' + str(len(jcts_with_splice)) + ' WOUT SPLICE:' + str(len(jcts_wout_splice)) + '\\n')\n    return jcts_with_splice, jcts_wout_splice\n\n\n########################\n#   Find Splice Inds   #\n########################\n# Runs bowtie on all of the possible splice sites of all possible junctions\n# Returns a dict keyed by jct_id and valued by a list of cut sites\ndef find_splice_inds(denovo_junctions, constants_dict):\n    \"\"\"\n    Goal: find where in the consensus sequence to make and donor and acceptor cut\n    Arguments:\n        denovo_junctions is a list[Junction]\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        returns a tuple of (jcts_with_splice,jcts_without_splice)\n        to allow for continuing with only jcts that had a splice site found\n    \"\"\"\n    # Gather info from the constants dictionary\n    splice_finder_temp_name = os.path.join(constants_dict[\"output_dir\"], \"splice_finder_temp_\")\n    thirds_len = constants_dict[\"thirds_len\"]\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    max_mismatches = int(constants_dict[\"splice_finding_allowed_mismatches\"])\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    allowed_mappings = constants_dict[\"splice_finding_allowed_mappings\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n\n    # Handle temporary files\n    five_prime_mapped_name = splice_finder_temp_name + \"5_prime.sam\"\n    three_prime_mapped_name = splice_finder_temp_name + \"3_prime.sam\"\n    five_prime_fa_file = splice_finder_temp_name + \"5_prime.fa\"\n    three_prime_fa_file = splice_finder_temp_name + \"3_prime.fa\"\n    five_temp_file = open(five_prime_fa_file, \"w\")\n    three_temp_file = open(three_prime_fa_file, \"w\")\n\n    # Do all the aligning work only if there are no mapped files already\n    if use_prior and os.path.isfile(five_prime_mapped_name) and os.path.isfile(three_prime_mapped_name):\n        write_time(\"--Using existing files in splice ind id\", time.time(), constants_dict[\"timer_file_path\"])\n    else:\n        # Write out all the possible splice sites for every jct out to a 5' and 3' file\n        num_size_excluded = 0\n        avg_cons_len = 0\n        for jct_ind in range(len(denovo_junctions)):\n            sys.stdout.flush()\n            junction = denovo_junctions[jct_ind]\n            cons_len = len(junction.consensus)\n            avg_cons_len = (float(jct_ind * avg_cons_len) / (jct_ind + 1)) + (float(cons_len) / (jct_ind + 1))\n            # splice_map_size = len(junction.consensus)/3\n            # NOTE found that I was forcinng splice sites to be too central if I used the thirds len\n            # NOTE and lost BCR-ABL this way, so instead I'll stick with using 1/3 of the consensus\n            splice_map_size = thirds_len\n            # sys.stderr.write(\"Cons len \"+str(cons_len)+\" and thirds_len \"+str(splice_map_size)+\"\\n\")\n\n            five_prime_list = [junction.consensus[ind:ind + splice_map_size]\n                               for ind in range(0, cons_len - 2 * splice_map_size + 1)]\n\n            three_prime_list = [junction.consensus[ind:ind + splice_map_size]\n                                for ind in range(splice_map_size, cons_len - splice_map_size + 1)]\n\n            # Oh this is my problem, sometimes the consensus length is too small\n            # to try and find splice inds from, so I should just throw that out and iterate,\n            # otherwise I'll have blank lines added to my splice ind fa files and they will be\n            # incorrectly formatted\n            if len(five_prime_list) == 0 or len(three_prime_list) == 0:\n                num_size_excluded += 1\n                continue\n\n            five_prime_fa_list = [\">jct_\" + str(jct_ind) + \"_ind_\" + str(ind) + \"\\n\"\n                                  + five_prime_list[ind] for ind in range(len(five_prime_list))]\n\n            three_prime_fa_list = [\">jct_\" + str(jct_ind) + \"_ind_\" + str(ind) + \"\\n\"\n                                   + three_prime_list[ind] for ind in range(len(three_prime_list))]\n\n            five_temp_file.write(\"\\n\".join(five_prime_fa_list) + \"\\n\")\n            three_temp_file.write(\"\\n\".join(three_prime_fa_list) + \"\\n\")\n\n        # Don't forget to close the files :)\n        five_temp_file.close()\n        three_temp_file.close()\n        sys.stdout.write(\"SPORK: Average consensus length [\" + str(avg_cons_len) + \"]\\n\")\n        sys.stdout.write(\"SPORK: Splitting fqs, size excluded [\" + str(num_size_excluded) + \"] of [\" + str(\n            len(denovo_junctions)) + \"]\\n\")\n\n        # Map the temp files above to the reference and save in temp sam files\n        # Need to specify the -f flag because the inputs are fasta files\n        with open(five_prime_mapped_name, \"w\") as five_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-x\", reference, five_prime_fa_file], stdout=five_prime_mapped)\n\n        with open(three_prime_mapped_name, \"w\") as three_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-x\", reference, three_prime_fa_file], stdout=three_prime_mapped)\n\n        # Map the temp files above to the reference and save in temp sam files\n        # Need to specify the -f flag because the inputs are fasta files\n        \"\"\"\n        n_multimap = \"10\"\n        with open(five_prime_mapped_name,\"w\") as five_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, five_prime_fa_file], stdout=five_prime_mapped)\n\n        with open(three_prime_mapped_name,\"w\") as three_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, three_prime_fa_file], stdout=three_prime_mapped)\n        \"\"\"\n\n        # Sort the temp output files after removing the header lines\n        p1 = subprocess.Popen([\"grep\", \"-v\", \"@\", five_prime_mapped_name], stdout=subprocess.PIPE)\n        p2 = subprocess.Popen([\"sort\", \"-o\", five_prime_mapped_name], stdin=p1.stdout)\n        p2.communicate()\n\n        p3 = subprocess.Popen([\"grep\", \"-v\", \"@\", three_prime_mapped_name], stdout=subprocess.PIPE)\n        p4 = subprocess.Popen([\"sort\", \"-o\", three_prime_mapped_name], stdin=p3.stdout)\n        p4.communicate()\n\n    # Open the mapped, sorted, headerless files\n    five_prime_sam_file = open(five_prime_mapped_name, \"r\")\n    three_prime_sam_file = open(three_prime_mapped_name, \"r\")\n\n    # Try and find the best splice sites walking through both files at once\n    best_splices = {}\n    sam_five_list = []\n    sam_three_list = []\n    prev_jct_ind = 0\n    five_sam_line = five_prime_sam_file.readline()\n    three_sam_line = three_prime_sam_file.readline()\n    while five_sam_line and three_sam_line:\n        sys.stdout.flush()\n        five_sam_entry = SAMEntry(five_sam_line)\n        three_sam_entry = SAMEntry(three_sam_line)\n\n        five_jct_ind = int(five_sam_entry.read_id.split(\"_\")[1])\n        three_jct_ind = int(three_sam_entry.read_id.split(\"_\")[1])\n\n        # Both the 5' and 3' sam are the prev_jct_ind\n        if five_jct_ind == prev_jct_ind and three_jct_ind == prev_jct_ind:\n            if five_sam_entry.num_mismatches <= max_mismatches:\n                sam_five_list.append(five_sam_entry)\n            if three_sam_entry.num_mismatches <= max_mismatches:\n                sam_three_list.append(three_sam_entry)\n            five_sam_line = five_prime_sam_file.readline()\n            three_sam_line = three_prime_sam_file.readline()\n\n        # Only the 5' sam is at the prev_jct_ind\n        elif five_jct_ind == prev_jct_ind:\n            if five_sam_entry.num_mismatches <= max_mismatches:\n                sam_five_list.append(five_sam_entry)\n            five_sam_line = five_prime_sam_file.readline()\n\n        # Only the 3' sam is at the prev_jct_ind\n        elif three_jct_ind == prev_jct_ind:\n            if three_sam_entry.num_mismatches <= max_mismatches:\n                sam_three_list.append(three_sam_entry)\n            three_sam_line = three_prime_sam_file.readline()\n\n        # Niether the 5' nor 3' sam is at the prev_jct_ind\n        else:\n            # RB 11/18/16 Filter out 5' and 3' sams if chroms are not the same as the unsplit\n            # RB 11/21/16 Also imposing a radius on the same chromosome filter (start at 30, very tight)\n            # RB 05/26/17 Actually I don't want to impose this restriction, would be ok with\n            #            different alignments than the original\n            #            this boils down to just commenting out this 'extra' filtering\n            radius = 30\n            pj = denovo_junctions[prev_jct_ind]\n\n            \"\"\"\n            sam_five_list = [sam for sam in sam_five_list\n                             if (sam.chromosome == pj.donor_sam.chromosome and \n                                 abs(pj.donor_sam.start-sam.start) < radius)]\n\n            sam_three_list = [sam for sam in sam_three_list\n                              if (sam.chromosome == pj.acceptor_sam.chromosome and \n                                  abs(pj.acceptor_sam.start-sam.start) < radius)]\n            \"\"\"\n\n            # Get the best 5' and 3' pair of Sams\n            prev_consensus = pj.consensus\n            # best_five,best_three = get_best_splice(sam_five_list,sam_three_list,prev_consensus,max_mismatches)\n            best_five, best_three = get_multi_best_splice(sam_five_list, sam_three_list, prev_consensus, max_mismatches)\n\n            best_splices[prev_jct_ind] = [best_five, best_three]\n            sam_five_list = []\n            sam_three_list = []\n            prev_jct_ind = min(five_jct_ind, three_jct_ind)\n\n    # Have to push the last jct lists into the shared_dict\n    pj = denovo_junctions[prev_jct_ind]\n    prev_consensus = pj.consensus\n    sam_five_list = [sam for sam in sam_five_list if sam.chromosome == pj.donor_sam.chromosome]\n    sam_three_list = [sam for sam in sam_three_list if sam.chromosome == pj.acceptor_sam.chromosome]\n\n    # best_five,best_three = get_best_splice(sam_five_list,sam_three_list,prev_consensus,max_mismatches)\n    best_five, best_three = get_multi_best_splice(sam_five_list, sam_three_list, prev_consensus, max_mismatches)\n    best_splices[prev_jct_ind] = [best_five, best_three]\n\n    # Close the 5' and 3' sam files\n    five_prime_sam_file.close()\n    three_prime_sam_file.close()\n\n    # Loop through the jcts assigning the splice site info\n    jcts_with_splice = []\n    jcts_without_splice = []\n    for jct_ind in range(len(denovo_junctions)):\n        sys.stdout.flush()\n        jct = denovo_junctions[jct_ind]\n\n        # Use calculted best splice if was previously found and both the\n        # donor and acceptor elements exist\n        if jct_ind in best_splices and all([sam.exists for sam in best_splices[jct_ind]]):\n            donor_sam, acceptor_sam = best_splices[jct_ind]\n\n            # Need to include the donor seq not used in splitting\n            # gets complicated by + and - strand\n            donor_ind = int(donor_sam.read_id.split(\"_ind_\")[1])\n            donor_len = len(donor_sam.seq)\n            up_remaining = jct.consensus[:donor_ind]\n            if donor_sam.strand == \"+\":\n                donor_sam.seq = up_remaining + donor_sam.seq\n                donor_sam.start -= len(up_remaining)\n            elif donor_sam.strand == \"-\":\n                donor_sam.seq = up_remaining + reverse_compliment(donor_sam.seq)\n                donor_sam.stop += len(up_remaining)\n            jct.donor_sam = donor_sam\n\n            # Need to include the acceptor seq not used in splitting\n            # gets complicated by + and - strand\n            acceptor_ind = int(acceptor_sam.read_id.split(\"_ind_\")[1])\n            acceptor_len = len(acceptor_sam.seq)\n            down_remaining = jct.consensus[acceptor_ind + 2 * acceptor_len:]\n            if acceptor_sam.strand == \"+\":\n                acceptor_sam.seq = acceptor_sam.seq + down_remaining\n                acceptor_sam.stop += len(down_remaining) - 1\n            elif acceptor_sam.strand == \"-\":\n                acceptor_sam.seq = reverse_compliment(acceptor_sam.seq) + down_remaining\n                acceptor_sam.start -= len(down_remaining)\n            jct.acceptor_sam = acceptor_sam\n\n            jcts_with_splice.append(jct)\n\n        # If either the donor or acceptor doesn't map (or both), add it to the\n        # jcts_without_splice list instead NOTE this list is currently not used\n        else:\n            jcts_without_splice.append(jct)\n\n    # Choose either the forward or reverse form of the junction that yields\n    # the smaller donor site since this will help collapsing in the next step\n    # (could have chosen larger donor etc, just to flip them all same way)\n\n    write_time(\"Num Jcts w/ splice = \" + str(len(jcts_with_splice)), time.time(), timer_file_path)\n    write_time(\"Num Jcts w/out splice = \" + str(len(jcts_without_splice)), time.time(), timer_file_path)\n\n    small_don_jcts_with_splice = []\n    for jct in jcts_with_splice:\n        if jct.donor_sam.donor() < jct.acceptor_sam.acceptor():\n            small_don_jcts_with_splice.append(jct)\n        else:\n            small_don_jcts_with_splice.append(jct.yield_reverse())\n\n    # Return the jcts w/ and w/out splice separately\n    return small_don_jcts_with_splice, jcts_without_splice\n\n\n#######################\n#   Get Best Splice   #\n#######################\n# This is a helper function for the splice site finder\n# If there are multiple found splice, return the best from the shared sams dict from the two sam lists\ndef get_best_splice(sam_five_list, sam_three_list, consensus, max_mismatches):\n    \"\"\"\n    Goal: given a list of possible splice, return the best one for a junction\n    Arguments:\n        sam_five_list is a list[SAMEntry] for possible 5' cuts\n        sam_three_list is a list[SAMEntry] for possible 3' cuts\n        consensus is a str and the consensus sequence of this junction\n        max_mismatches is the maximum allowed mismatches in total for the 5' and 3' sides\n\n    Returns:\n        a tuple of the (best_5'_sam,best_3'_sam) to then be stored in the junction\n    \"\"\"\n    shared_dict = {}\n    id_dict = {}\n    best_sam_five = SAMEntry()\n    best_sam_five_len = 0\n    best_sam_three = SAMEntry()\n    best_sam_three_len = 0\n\n    # Populate the id_dict to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 5' mapping\n    for sam_five in sam_five_list:\n        id_dict[sam_five.read_id] = sam_five\n        if len(sam_five.seq) > best_sam_five_len:\n            best_sam_five_len = len(sam_five.seq)\n            best_sam_five = sam_five\n\n    # Check the id_dict to see if the 3' has a perfect 5' match\n    # Also keep track of the best (longest) 3' mapping\n    for sam_three in sam_three_list:\n        if len(sam_three.seq) > best_sam_three_len:\n            best_sam_three_len = len(sam_three.seq)\n            best_sam_three = sam_three\n        if sam_three.read_id in id_dict:\n            sam_five = id_dict[sam_three.read_id]\n            shared_dict[sam_three.read_id] = [sam_five, sam_three]\n\n    # Now pick out the best sam's to use\n    # If there is at least one shared perfect splice ind find the one w/ least mismatches\n    # then choose the perfect pair that has the least mismatches\n    if len(shared_dict) > 0:\n        best_key = \"\"\n        min_mismatches = max_mismatches + 1\n        for key in shared_dict:\n            sam1, sam2 = shared_dict[key]\n            num_mismatches = sam1.num_mismatches + sam2.num_mismatches\n            if best_key == \"\" or num_mismatches < min_mismatches:\n                best_key = key\n                min_mismatches = num_mismatches\n        best_five_sam, best_three_sam = shared_dict[best_key]\n        return best_five_sam, best_three_sam\n\n    # Otherwise there is a mapping for the left and right pieces, although there is space in between\n    # NOTE is it possible that the best 5' and 3' seqs have overlap in the middle?\n    else:\n        return best_sam_five, best_sam_three\n\n\n#############################\n#   Get Multi Best Splice   #\n#############################\n# This is a helper function for the splice site finder that takes into account\n# If there are multiple found splice, return the best from the shared sams dict from the two sam lists\ndef get_multi_best_splice(sam_five_list, sam_three_list, consensus, max_mismatches):\n    \"\"\"\n    Goal: given a list of possible splice, return the best one for a junction\n    Arguments:\n        sam_five_list is a list[SAMEntry] for possible 5' cuts\n        sam_three_list is a list[SAMEntry] for possible 3' cuts\n        consensus is a str and the consensus sequence of this junction\n        max_mismatches is the maximum allowed mismatches in total for the 5' and 3' sides\n\n    Returns:\n        a tuple of the (best_5'_sam,best_3'_sam) to then be stored in the junction\n    \"\"\"\n    shared_dict = defaultdict(list)\n    sam_fives = defaultdict(list)\n    sam_threes = defaultdict(list)\n    best_sam_five = SAMEntry()\n    best_sam_five_len = 0\n    best_sam_three = SAMEntry()\n    best_sam_three_len = 0\n\n    # Populate the sam_fives to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 5' mapping\n    for sam_five in sam_five_list:\n        sam_fives[sam_five.read_id].append(sam_five)\n        if len(sam_five.seq) > best_sam_five_len:\n            best_sam_five_len = len(sam_five.seq)\n            best_sam_five = sam_five\n\n    # Populate the sam_threes to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 3' mapping\n    for sam_three in sam_three_list:\n        sam_threes[sam_three.read_id].append(sam_three)\n        if len(sam_three.seq) > best_sam_three_len:\n            best_sam_three_len = len(sam_three.seq)\n            best_sam_three = sam_three\n\n    # Check the id_dict to see if the 5' has a perfect 3' match\n    # Within the perfect match, if there are multi maps choose the one that is closest together\n    # NOTE the internal loop is O(n^2) but n = 10 right now so not too bad\n    for id_key in sam_fives:\n        if id_key in sam_threes:\n            fives = sam_threes[id_key]\n            threes = sam_threes[id_key]\n\n            # For each split index propose the one where the 5' and 3' are the closest\n            # and put this in the shared_dict\n            best_five = fives[0]\n            best_three = threes[0]\n            for five in fives[1:]:\n                for three in threes[1:]:\n                    # If the current best are on different chroms\n                    if best_five.chromosome != best_three.chromosome:\n                        if five.chromosome == three.chromosome:\n                            best_five = five\n                            best_three = three\n\n                    # If the current best are on the same chroms\n                    else:\n                        if five.chromosome == three.chromosome:\n                            if abs(five.start - three.start) < abs(best_five.start - best_three.start):\n                                best_five = five\n                                best_three = three\n\n            shared_dict[id_key] = [best_five, best_three]\n\n    # Now pick out the best sam's to use\n    # If there is at least one shared perfect splice ind find the one w/ least mismatches\n    # then choose the perfect pair that has the least mismatches\n    if len(shared_dict) > 0:\n        best_key = \"\"\n        min_mismatches = max_mismatches + 1\n        for key in shared_dict:\n            sam1, sam2 = shared_dict[key]\n            num_mismatches = sam1.num_mismatches + sam2.num_mismatches\n            if best_key == \"\" or num_mismatches < min_mismatches:\n                best_key = key\n                min_mismatches = num_mismatches\n        best_five_sam, best_three_sam = shared_dict[best_key]\n        return best_five_sam, best_three_sam\n\n    # Otherwise there is a mapping for the left and right pieces, although there is space in between\n    # NOTE is it possible that the best 5' and 3' seqs have overlap in the middle?\n    else:\n        return best_sam_five, best_sam_three\n\n\n##########################\n#   Filter Map Quality   #\n##########################\n# Function to take in Junctions after Splice Ind finding and map pieces right around ind\n# to filter out degenerate or multiple mapping pieces. Currently uses a hard threshold\ndef filter_map_quality(jcts, constants_dict):\n    \"\"\"\n    Goal: Map left and right 25-mers of splice ind and filter out jcts by mapping score\n    Arguments:\n        jcts is a list of type Junction\n        constants dict has all the constants used in the program\n\n    Returns:\n        (pass_jcts,fail_jcts, anom_jcts) is a tuple of \n            (1) list of type Junction of jcts that passed\n            (2) list of type Junction of jcts that failed\n            (3) list of type Junction of jcts that had some other error\n    \"\"\"\n\n    # Add map qualities and only keep those above the cutoff\n    mq_cutoff = constants_dict[\"mq_cutoff\"]\n    mq_len = constants_dict[\"mq_len\"]\n\n    # mqmallg=unique(mallg[(!is.na(match( paste(mallg$junction),paste(mq[mq3+mq5>lower.mq]$junction))))])\n\n    # Write out temp fasta for Bowtie2 calls\n    temp_fasta_name = os.path.join(constants_dict[\"output_dir\"], \"mapq_temp.fasta\")\n    with open(temp_fasta_name, \"w\") as temp_fasta:\n        for ind, jct in enumerate(jcts):\n            seq = jct.consensus\n            don_seq = seq[:jct.splice_ind()][-mq_len:]  # Get the last mq_len bases before splice\n            acc_seq = seq[jct.splice_ind():][:mq_len]  # Get the first mq_len bases after splice\n            temp_fasta.write(\">jct_\" + str(ind) + \"_don\" + \"\\n\" + don_seq + \"\\n\")\n            temp_fasta.write(\">jct_\" + str(ind) + \"_acc\" + \"\\n\" + acc_seq + \"\\n\")\n\n    # Get bowtie2 parameter constants\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n    mq_mapped_name = os.path.join(constants_dict[\"output_dir\"], \"mapq_mapped.sam\")\n\n    # Call bowtie2 to get map qualities\n    with open(mq_mapped_name, \"w\") as mq_mapped:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n             \"-x\", reference, temp_fasta_name], stdout=mq_mapped)\n\n    # Go through the mapped output file\n    pass_jcts = []\n    fail_jcts = []\n    anom_jcts = []\n    with open(mq_mapped_name, \"r\") as mq_mapped:\n        sam_line = mq_mapped.readline()\n\n        while sam_line:\n            # Skip header lines\n            if \"@\" in sam_line:\n                sam_line = mq_mapped.readline()\n                continue\n\n            # Get sam entry 1\n            sam_entry_1 = SAMEntry(sam_line)\n            x, jct_ind_1, don = sam_entry_1.read_id.split(\"_\")\n            jct_ind_1 = int(jct_ind_1)\n\n            # Get sam entry 2\n            sam_line = mq_mapped.readline()\n            sam_entry_2 = SAMEntry(sam_line)\n            if not sam_line:\n                anom_jcts.append(jcts[jct_ind_1])\n                continue\n            x, jct_ind_2, acc = sam_entry_2.read_id.split(\"_\")\n            jct_ind_2 = int(jct_ind_2)\n\n            # Check for different anomalous cases where a don/acc doesn't appear in output\n            # If any anomally is hit we start w/ sam_entry_2 next loop, don't advance\n            if don != \"don\" or acc != \"acc\" or jct_ind_1 != jct_ind_2:\n                anom_jcts.append(jcts[jct_ind_1])\n                continue\n\n            # Otherwise if they are don/acc from the same jct check if they passed mq_cutoff\n            jct_mapq = sam_entry_1.mapping_quality + sam_entry_2.mapping_quality\n            jcts[jct_ind_1].mapq = jct_mapq\n            if jct_mapq > mq_cutoff:\n                pass_jcts.append(jcts[jct_ind_1])\n            else:\n                fail_jcts.append(jcts[jct_ind_1])\n\n            # Move on to the next line\n            sam_line = mq_mapped.readline()\n\n    # Return the passed, failed, and anomalous jcts\n    return (pass_jcts, fail_jcts, anom_jcts)\n\n\n#####################\n#   Generate GTFS   #\n#####################\n# Helper function to generate a list of gtf objects from a gtf path full of gtf files\ndef generate_gtfs(gtf_path, allowed_feature_types=[\"exon\"]):\n    \"\"\"\n    Goal: open all the gtf_files and put all gtf objects in a list from the given path\n    Arguments:\n        gtf_file_name is the full path to the gtf files\n        allowed_feature_types is a list of string specifiying which feature types to add (default 'exon' only)\n\n    Returns:\n        gtfs is a list[GTFEntry]\n    \"\"\"\n    gtfs = []\n    gtf_file_names = [gtf_name for gtf_name in os.listdir(gtf_path) if \"gtf\" in gtf_name]\n    for gtf_file_name in gtf_file_names:\n        abs_gtf_file_path = os.path.join(gtf_path, gtf_file_name)\n        # sys.stdout.write(\"Reading in GTF file \"+abs_gtf_file_path+\"\\n\")\n        with open(abs_gtf_file_path, \"r\") as gtf_file:\n            for gtf_line in gtf_file.readlines():\n                # RB 6/6/17: Try to skip common header lines to avoid parsing error\n                if gtf_line[0] == '#' or gtf_line[0] == '@':\n                    continue\n                gtf = GTFEntry(gtf_line)\n                if gtf.feature in allowed_feature_types:\n                    gtfs.append(gtf)\n\n    sys.stdout.write('Len GTFs: ' + str(len(gtfs)) + '\\n')\n    return gtfs\n\n\n########################\n#   Get JCT GTF info   #\n########################\ndef get_jct_gtf_info(junctions, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs):\n    \"\"\"\n    Goal: for each junction find the closest gtf for donor and acceptor\n    Arguments:\n        junctions is a list[Junction]\n        gtfs is a list[GTF]\n\n    Returns:\n        nothing (just updates the junction objects as pass-by-reference)\n    \"\"\"\n    # Separate the gtfs by chromosome into a dictionary\n\n\n    for junction in junctions:\n        closest_results = find_closest_gtf(junction, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs)\n        if closest_results[\"donor\"] and not junction.best_don_list and not junction.rev_best_don_list:\n            junction.donor_sam.gtf = closest_results[\"donor\"]\n        elif closest_results[\"donor\"] and not junction.rev_best_don_list:\n            for index in range(len(closest_results[\"donor\"])):\n                junction.best_don_list[index].gtf = closest_results[\"donor\"][index]\n        elif closest_results[\"donor\"] and not junction.best_don_list:\n            for index in range(len(closest_results[\"donor\"])):\n                junction.rev_best_don_list[index].gtf = closest_results[\"donor\"][index]\n\n        if closest_results[\"acceptor\"] and not junction.best_acc_list and not junction.rev_best_acc_list:\n            junction.acceptor_sam.gtf = closest_results[\"acceptor\"]\n        elif closest_results[\"acceptor\"] and not junction.rev_best_acc_list:\n            for index in range(len(closest_results[\"acceptor\"])):\n                junction.best_acc_list[index].gtf = closest_results[\"acceptor\"][index]\n        elif closest_results[\"acceptor\"] and not junction.best_acc_list:\n            for index in range(len(closest_results[\"acceptor\"])):\n                junction.rev_best_acc_list[index].gtf = closest_results[\"acceptor\"][index]\n\n\n#################################\n#        Find Closest GTF       #\n#################################\ndef find_closest_gtf(jct, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs):\n    \"\"\"\n    Goal: make it easier to call find closest gtf of donor and acceptor w/out code duplication\n    Arguments:\n        takes in a single junction\n        takes in chrom_gtfs_don which is a dict[\"chrom\":list[GTFEntry]] sorted by donor\n        takes in chrom_gtfs_acc which is a dict[\"chrom\":list[GTFEntry]] sorted by acceptor\n\n    Returns:\n        closest_results which is a dictionary keyed by\n        -> closest_results[\"donor\"] -> GTFEntry\n        -> closest_results[\"acceptor\"] -> GTFEntry\n    \"\"\"\n    closest_results = {\"donor\": None, \"acceptor\": None}\n\n    # Find the closest donor sam gtf\n    if jct.donor_sam.exists and not jct.best_don_list and not jct.rev_best_don_list:\n        query = jct.donor_sam.donor()\n        chrom = jct.donor_sam.chromosome\n        chrom_key = chrom + jct.donor_sam.strand\n        if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(chrom_don_libs[chrom_key])>0 and len(chrom_gtfs_don[chrom_key])>0:\n            gtfs_don = chrom_gtfs_don[chrom_key]\n            don_lib = chrom_don_libs[chrom_key]\n            # closest_don_ind,its = bin_search_gtf(query,don_lib)\n\n            closest_don_ind = brute_search_gtf(query, don_lib)  # <-- RB trying brute force\n            closest_results[\"donor\"] = gtfs_don[closest_don_ind]\n\n    elif jct.donor_sam.exists and not jct.rev_best_don_list:\n        closest_results[\"donor\"] = []\n        for index in range(len(jct.best_don_list)):\n            query = jct.best_don_list[index].donor()\n            chrom = jct.best_don_list[index].chromosome\n            chrom_key = chrom + jct.best_don_list[index].strand\n            if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(chrom_don_libs[chrom_key]) > 0 and len(\n                    chrom_gtfs_don[chrom_key]) > 0:\n                gtfs_don = chrom_gtfs_don[chrom_key]\n                don_lib = chrom_don_libs[chrom_key]\n                closest_don_ind = brute_search_gtf(query, don_lib)\n                closest_results[\"donor\"].append(gtfs_don[closest_don_ind])\n\n    elif jct.donor_sam.exists and not jct.best_don_list:\n        closest_results[\"donor\"] = []\n        for index in range(len(jct.rev_best_don_list)):\n            query = jct.rev_best_don_list[index].donor()\n            chrom = jct.rev_best_don_list[index].chromosome\n            chrom_key = chrom + jct.rev_best_don_list[index].strand\n            if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(\n                    chrom_don_libs[chrom_key]) > 0 and len(\n                    chrom_gtfs_don[chrom_key]) > 0:\n                gtfs_don = chrom_gtfs_don[chrom_key]\n                don_lib = chrom_don_libs[chrom_key]\n                closest_don_ind = brute_search_gtf(query, don_lib)\n                closest_results[\"donor\"].append(gtfs_don[closest_don_ind])\n\n    # Find the closest acceptor sam gtf\n    if jct.acceptor_sam.exists and not jct.best_acc_list and not jct.rev_best_acc_list:\n        query = jct.acceptor_sam.acceptor()\n        chrom = jct.acceptor_sam.chromosome\n        chrom_key = chrom + jct.acceptor_sam.strand\n        if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(chrom_gtfs_acc[chrom_key])>0 and len(chrom_acc_libs[chrom_key])>0:\n            gtfs_acc = chrom_gtfs_acc[chrom_key]\n            acc_lib = chrom_acc_libs[chrom_key]\n            # closest_acc_ind,its = bin_search_gtf(query,acc_lib)\n            closest_acc_ind = brute_search_gtf(query, acc_lib)  # <-- RB trying brute force\n            closest_results[\"acceptor\"] = gtfs_acc[closest_acc_ind]\n    elif jct.acceptor_sam.exists and not jct.rev_best_acc_list:\n        closest_results[\"acceptor\"] = []\n        for index in range(len(jct.best_acc_list)):\n            query = jct.best_acc_list[index].acceptor()\n            chrom = jct.best_acc_list[index].chromosome\n            chrom_key = chrom + jct.best_acc_list[index].strand\n            if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(\n                    chrom_gtfs_acc[chrom_key]) > 0 and len(chrom_acc_libs[chrom_key]) > 0:\n                gtfs_acc = chrom_gtfs_acc[chrom_key]\n                acc_lib = chrom_acc_libs[chrom_key]\n                closest_acc_ind = brute_search_gtf(query, acc_lib)\n                closest_results[\"acceptor\"].append(gtfs_acc[closest_acc_ind])\n\n    elif jct.acceptor_sam.exists and not jct.best_acc_list:\n        closest_results[\"acceptor\"] = []\n        for index in range(len(jct.rev_best_acc_list)):\n            query = jct.rev_best_acc_list[index].acceptor()\n            chrom = jct.rev_best_acc_list[index].chromosome\n            chrom_key = chrom + jct.rev_best_acc_list[index].strand\n            if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(\n                    chrom_gtfs_acc[chrom_key]) > 0 and len(chrom_acc_libs[chrom_key]) > 0:\n                gtfs_acc = chrom_gtfs_acc[chrom_key]\n                acc_lib = chrom_acc_libs[chrom_key]\n                closest_acc_ind = brute_search_gtf(query, acc_lib)\n                closest_results[\"acceptor\"].append(gtfs_acc[closest_acc_ind])\n\n    return closest_results\n\n\n#################################\n#    Binary Search Closest GTF  #\n#################################\n# Recursive binary search function\n# NOTE this could probably be sped up using bisectleft, but I doubt by much\ndef bin_search_gtf(query, library, start_ind=0, end_ind=-1, its=1, disp=False):\n    \"\"\"\n    Goal: do a binary search through the library for the closest ind\n    Arguments:\n        query is an int\n        library is a list[int] of genomic positions to look through\n        start_ind is defaulted to 0 and keeps track of where to look\n        end_ind is defaulted to -1 and keeps track of where to look\n\n    Returns:\n        the index of the closest matching library value to the query\n    \"\"\"\n    # First iteration\n    if its == 1 and end_ind == -1:\n        end_ind = len(library) - 1\n\n    # Base case\n    if end_ind - start_ind <= 1:\n        sys.stdout.flush()\n        start_dist = abs(query - library[start_ind])\n        end_dist = abs(library[end_ind] - query)\n        ret_ind = start_ind if start_dist <= end_dist else end_ind\n        if disp:\n            sys.stdout.write(str(its) + \")\" + \" Found closest to:[\" + library[ret_ind] + \"]\\n\")\n        return ret_ind, its\n    # Recursive case\n    else:\n        mid_ind = (start_ind + end_ind) / 2\n        # Determine whether or not to print this line\n        # (almost never want to except when debugging)\n        if disp:\n            print str(its) + \")\", library[start_ind], \"--\", library[mid_ind], \"--\", library[end_ind]\n\n        # Check to see how to recurse\n        if query < library[mid_ind]:\n            return bin_search_gtf(query, library, start_ind, mid_ind, its + 1, disp=disp)\n        else:\n            return bin_search_gtf(query, library, mid_ind, end_ind, its + 1, disp=disp)\n\n            #####################################\n\n\n# Brute Force Closest GTF        #\n#####################################\ndef brute_search_gtf(query, library):\n    \"\"\"\n    Goal: do brute search through the library for the closest ind\n    Arguments:\n        query is an int\n        library is a list[int] of genomic positions to look through\n\n    Returns:\n        the index of the closest matching library value to the query\n    \"\"\"\n\n    closest_ind = 0\n    closest_dist = abs(library[0] - query)\n    for ind, val in enumerate(library[1:]):\n        if abs(val - query) < closest_dist:\n            closest_ind = ind + 1  # <-- have to add 1 since skipping first ind\n            closest_dist = abs(val - query)\n\n    return closest_ind\n\n\n#####################################\n#         Identify Fusions          #\n#####################################\n# Takes junctions that already have gtf info\n# If a junction has the following properties call it a 'fusion':\n#   IF donor and acceptor sams are at_boundary:\n#       IF donor and acceptor are on different chromosomes\n#           [yes fusion]\n#       ELIF donor and acceptor are on different strands\n#       ELIF distance between donor and acceptor > threshold\n#           [yes fusion]\n#       ELSE\n#           [no fusion]\n#   ELSE:\n#       [no fusion]\n#\n# Returns a list of junctions that are deemed 'fusions'\ndef identify_fusions(junctions):\n    \"\"\"\n    Goal: take the junctions and find the ones that could be fusions\n    Arguments:\n        junctions is a list[Junction] objects\n        span_cutoff is an optional int or float defining min distance for a fusion\n            on the same chromosome\n    Returns:\n        fusion_jcts as a list[Junction] with the junctions defined as fusions\n    \"\"\"\n    #span_cutoff = constants_dict[\"span_cutoff\"]\n    fusion_jcts = []\n    for jct in junctions:\n        fusion_type = jct.get_fusion_type()\n        if \"fusion\" in fusion_type and \"no_fusion\" not in fusion_type:\n            fusion_jcts.append(jct)\n    return fusion_jcts\n\n\n####################\n#   Assign Class   #\n####################\n# Assigns a pair of R1 and R2 to a class based on certain factors. These are both SAMEntry objects.\n# Possible classes. R1 always maps to a denovo jct, and R2 somewhere else.\n# NOTE I currently have no confidence that this function works\n# TODO update the logic to allow 'Fusion' classification\n# TODO use regex to parse the chromosome rather than all this messy splitting (it looks terrible)\n# [1] Linear\n# [2] Linear Anomally\n# [3] Circular\n# [4] Circular Anomally\n# [5] None <-- kind of in the place of fusions for now\ndef assign_class(sam_R1, sam_R2):\n    \"\"\"\n    Goal: take the donor and acceptor sam and categorize them\n    Arguments:\n        sam_R1 is of type SAMEntry\n        sam_R2 is of type SAMEntry\n\n    Returns:\n        a string of the generated type\n    \"\"\"\n    jct_chrom_1 = sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[1]\n    jct_chrom_2 = sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[0]\n\n    # If the jct splices 2 chromosomes together just skip it for now\n    if jct_chrom_1 != jct_chrom_2:\n        return \"None\"\n    # If the R1 and R2 are on different chromosomes just skip it for now\n    if jct_chrom_1 != sam_R2.chromosome:\n        return \"None\"\n\n    span = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[5].split(\":\")[1])\n\n    # Linear case\n    if span > 0:\n        if sam_R1.strand != sam_R2.strand:\n            return \"Linear\"\n        else:\n            return \"Linear_Anomaly\"\n\n    # Circular case\n    else:\n        start_1 = int(sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[3].split(\":\")[1])\n        stop_1 = int(sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[4].split(\":\")[1])\n        start_2 = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[2].split(\":\")[1])\n        stop_2 = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[3].split(\":\")[1])\n        if sam_R1.strand == sam_R2.strand:\n            return \"Circular_Anomaly\"\n        elif start_2 <= sam_R2.start <= stop_1:\n            return \"Circular\"\n        else:\n            return \"Circular_Anomaly\"\n\n\n############################\n#   Write GLM Class File   #\n############################\n# Simple function to print out GLM class file in the right format\n# NOTE I don't think this function currently works\ndef write_glm_class_file(class_file_name, sam_list):\n    \"\"\"\n    Goal: print out a class file for the GLM\n    Arguments:\n        class_file_name is the name of the save file for the GLM\n        sam_list is a list[[SAMEntry,SAMEntry,str,list[string],list[string]],...]\n\n    Returns:\n        nothing (just prints to the file instead)\n    \"\"\"\n    header = \"\"\n    header += \"id\\t\"\n    header += \"class\\t\"\n    header += \"pos\\t\"\n    header += \"qual\\t\"\n    header += \"aScore\\t\"\n    header += \"numN\\t\"\n    header += \"readLen\\t\"\n    header += \"junction\\t\"\n    header += \"strand\\t\"\n    header += \"posR2\\t\"\n    header += \"qualR2\\t\"\n    header += \"aScoreR2\\t\"\n    header += \"numNR2\\t\"\n    header += \"readLenR2\\t\"\n    header += \"junctionR2\\t\"\n    header += \"strandR2\\n\"\n    with open(class_file_name, \"w\") as class_file:\n        class_file.write(header)\n        for read_pair in sam_list:\n            sam_R1, sam_R2, pair_class, sam_R1_genes, sam_R2_genes = read_pair\n\n            # Add general info to the out_line\n            out_line = \"\"\n            out_line += str(sam_R1.read_id.split(\"/\")[0]) + \"\\t\"\n            out_line += str(pair_class) + \"\\t\"\n\n            # Add R1 info to the out_line\n            out_line += str(sam_R1.start) + \"\\t\"\n            out_line += str(sam_R1.mapping_quality) + \"\\t\"\n            out_line += str(sam_R1.alignment_score) + \"\\t\"\n            out_line += str(sam_R1.num_Ns) + \"\\t\"\n            out_line += str(len(sam_R1.seq)) + \"\\t\"\n            out_line += str(sam_R1.junction()) + \"|\" + sam_R1_genes + \"\\t\"\n            out_line += str(sam_R1.strand) + \"\\t\"\n\n            # Add R2 info to the out_line\n            out_line += str(sam_R2.start) + \"\\t\"\n            out_line += str(sam_R2.mapping_quality) + \"\\t\"\n            out_line += str(sam_R2.alignment_score) + \"\\t\"\n            out_line += str(sam_R2.num_Ns) + \"\\t\"\n            out_line += str(len(sam_R2.seq)) + \"\\t\"\n            out_line += str(sam_R2.junction()) + \"|\" + sam_R2_genes + \"\\t\"\n            out_line += str(sam_R2.strand) + \"\\n\"\n\n            # Write the built up out_line to the glm input class file\n            class_file.write(out_line)\n\n\n##################\n#   Write Time   #\n##################\n# Helper function to write out the timing of something\n# Takes in the message, a start time in seconds, and a timer_file_path\n# Appends to the timer file by default, first call should overwrite\ndef write_time(message, start_time, timer_file_path, append=True, uniform_len=70):\n    \"\"\"\n    Goal: write a timed event out to a file\n    Arguments:\n        message is the text of the job to put next to the time (i.e. 'Time to align reads')\n        start_time is the start of the job gotten by time.time()\n        time_file_path is the full path to the timer store file\n        append is a boolean saying whether or not to append to the file vs. overwriting (default append)\n        uniform_len is the max message length to allow aligning the timer output file\n\n    Returns:\n        nothing (just writes to the timer file)\n    \"\"\"\n    seconds_duration = float(time.time() - start_time)\n    minutes_duration = seconds_duration / 60\n    hours_duration = seconds_duration / 3600\n    seconds_str = (\"{:3.2f}\".format(seconds_duration)).rjust(5, \" \")\n    minutes_str = (\"{:3.2f}\".format(minutes_duration)).rjust(5, \" \")\n    hours_str = (\"{:3.2f}\".format(hours_duration)).rjust(5, \" \")\n\n    if len(message) < uniform_len:\n        message += \" \" * (uniform_len - len(message))\n    else:\n        message = message[:uniform_len]\n    time_out_str = message + \":    \"\n    time_out_str += seconds_str + \":seconds    \"\n    time_out_str += minutes_str + \":minutes    \"\n    time_out_str += hours_str + \":hours\\n\"\n    timer_file = open(timer_file_path, \"a\") if append else open(timer_file_path, \"w\")\n    timer_file.write(time_out_str)\n    timer_file.close()\n\n\n##########################\n#   Collapse Junctions   #\n##########################\ndef collapse_junctions(jcts, collapse_thresh, group_out_file_name=None):\n    \"\"\"\n    Goal: take in the junctions and collapse ones at or near the same\n          splice sites\n    Arguments:\n        junctions is a list[Junction] object\n        full_path_name points to the the combined fastq file\n        constants dict is a dictionary of global constants\n\n    Returns:\n        a tuple with the first element as the singles \"uncollapsed list\"\n        and the second being the collapsed list of junctions list[Junction]\n    \"\"\"\n    # Get the collapsing threshold (radius of donor and acceptor to collapse in)\n    #collapse_thresh = constants_dict[\"collapse_thresh\"]\n\n    # Separate the jcts by chromosome pairs to make later O(N^2) less painful\n    # so will have one entry for chr1:chr2, chr1:chr3 etc\n    # it will be combinations, not permutations (chr1:chr2 == chr2:chr1)\n    splices_by_chroms = {}\n    for jct in jcts:\n        chrom_1 = \"chr\" + str(jct.donor_sam.chromosome)\n        chrom_2 = \"chr\" + str(jct.acceptor_sam.chromosome)\n        if chrom_1 + chrom_2 in splices_by_chroms:\n            splices_by_chroms[chrom_1 + chrom_2].append(jct)\n        #elif chrom_2 + chrom_1 in splices_by_chroms:\n        #    splices_by_chroms[chrom_2 + chrom_1].append(jct)\n        else:\n            splices_by_chroms[chrom_1 + chrom_2] = [jct]\n\n    groupings = {}\n    for chroms in splices_by_chroms:\n        groupings[chroms] = []\n        for jct in splices_by_chroms[chroms]:\n            don = jct.donor_sam.donor()\n            acc = jct.acceptor_sam.acceptor()\n            found_prev_group = False\n\n            # Only compare jct to other jcts if both\n            # don and acc are not None\n            if don and acc:\n                for prev_group in groupings[chroms]:\n                    for prev_jct in prev_group:\n                        prev_don = prev_jct.donor_sam.donor()\n                        prev_acc = prev_jct.acceptor_sam.acceptor()\n                        # If any one of the acceptor/donors are None\n                        if not prev_don or not prev_acc:\n                            continue\n                        if abs(don - prev_don) <= collapse_thresh and abs(acc - prev_acc) <= collapse_thresh:\n                            # sys.stderr.write(\"Found match for:\\n\")\n                            # sys.stderr.write(jct.verbose_fasta_string())\n                            prev_group.append(jct)\n                            found_prev_group = True\n                            break\n\n                    # If found a prev_group, don't need to look through\n                    # other prev groups\n                    if found_prev_group:\n                        break\n\n            # If it didn't find any of the prev_groups, start a new group\n            if not found_prev_group:\n                groupings[chroms].append([jct])\n\n    # Separate singles from groups\n    singles = []\n    groups = []\n    group_out_file = None\n    if group_out_file_name:\n        group_out_file = open(group_out_file_name, \"w\")\n\n    for chroms in groupings:\n        for group in groupings[chroms]:\n            if len(group) <= 1:\n                singles += group\n            else:\n                if group_out_file_name:\n                    group_out_file.write(\"Group info:\\n\")\n                    group_out_file.write(\"\".join([m.verbose_fasta_string() for m in group]) + \"\\n\")\n                counts = [len(member.bin_pair_group) for member in group]\n                max_ind = counts.index(max(counts))\n                repr_jct = group[max_ind]\n                repr_jct.collapsed_num = sum(counts)\n                groups.append(repr_jct)\n\n    if group_out_file_name:\n        group_out_file.close()\n\n\n    return singles, groups\n\n\n########################\n#   Badfj3 fusions     #\n########################\ndef badfj3_fusions(junctions, constants_dict):\n    # Bowtie params\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n\n    # Build up file stems\n    badfj3_stem = os.path.join(constants_dict[\"output_dir\"], \"badfj3_\")\n    don_fasta = badfj3_stem + \"don.fasta\"\n    acc_fasta = badfj3_stem + \"acc.fasta\"\n    badfj3_mapped = badfj3_stem + \"mapped.sam\"\n\n    # Open the R1 and R2\n    don_fasta_f = open(don_fasta, \"w\")\n    acc_fasta_f = open(acc_fasta, \"w\")\n\n    # Build up the \"paired end\" files\n    jct_dict = {}\n    for jct in junctions:\n        jct_dict[jct.jct_ind] = jct\n        header = \">\" + str(jct.jct_ind)\n        break_point = jct.splice_ind()\n        don = jct.consensus[:break_point]\n        acc = jct.consensus[break_point:]\n\n        # RB: 5/26/17 Change this to map just the first and last 20 bases\n        # don_fasta_f.write(header+\"\\n\"+don+\"\\n\")\n        # acc_fasta_f.write(header+\"\\n\"+acc+\"\\n\")\n        don_fasta_f.write(header + \"\\n\" + don[:20] + \"\\n\")\n        acc_fasta_f.write(header + \"\\n\" + acc[-20:] + \"\\n\")\n\n    # Close the R1 and R2 fastqs\n    don_fasta_f.close()\n    acc_fasta_f.close()\n\n    badfj3_gap = \"500000\"  # If the don/acc can map within 1/2 Mb, then jct not fusion\n\n    # Run bowtie2 on the R1 and R2\n    with open(badfj3_mapped, \"w\") as badfj3_mapped_f:\n        subprocess.call([\n            \"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", \"--no-mixed\", \"--no-hd\",\n            min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n            \"-x\", reference, \"-X\", badfj3_gap, \"--ff\", \"-1\",\n            don_fasta, \"-2\", acc_fasta\n        ],\n            stdout=badfj3_mapped_f)\n\n    # Read back the sam file\n    flags = [\"paired\", \"proper\", \"no_align\", \"paired_no_align\", \"minus\", \"mate_minus\", \"R1\", \"R2\"]\n    seen_jct_inds = []\n    with open(badfj3_mapped, \"r\") as badfj3_mapped_f:\n        for line in badfj3_mapped_f:\n            # NOTE this is a sloppy way of parsing a PE SAM file (should use samtools view)\n            split_line = line.split('\\t')\n            jct_ind = int(split_line[0])\n            flag = int(split_line[1])\n\n            # Does sloppy binary flag parsing\n            jct_flags = {flags[ind]: bool(int(bit)) for ind, bit in enumerate(format(flag, \"08b\"))}\n\n            # If it didn't align, then just skip it, it can't be a badfj3\n            if jct_flags[\"no_align\"] or jct_flags[\"paired_no_align\"]:\n                continue\n            # If it did align AND it has already been seen this is a badfj3\n            elif jct_ind in seen_jct_inds:\n                jct_dict[jct_ind].badfj3 = True\n            # If it did align but has not already been seen put it in the see_jct_inds\n            else:\n                seen_jct_inds.append(jct_ind)\n\n    return junctions\n\n\n############################\n#   Old Badfj3 fusions     #\n############################\n\"\"\"\ndef badfj3_fusions(fusion_junctions,constants_dict):\n\n    #Bowtie params\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n\n    #Build up file stems\n    badfj3_stem = os.path.join(constants_dict[\"output_dir\"],\"badfj3_\")\n    don_fasta = badfj3_stem+\"don.fasta\"\n    acc_fasta = badfj3_stem+\"acc.fasta\"\n    badfj3_mapped = badfj3_stem+\"mapped.sam\"\n\n    #Open the R1 and R2\n    don_fasta_f = open(don_fasta,\"w\")\n    acc_fasta_f = open(acc_fasta,\"w\")\n\n    #Build up the \"paired end\" files\n    for fusion in fusion_junctions:\n        header = \">\"+str(fusion.jct_ind)+\"\\n\"\n        break_point = fusion.splice_ind()\n        don = fusion.consensus[:break_point]\n        acc = fusion.consensus[break_point:]\n        don_fasta_f.write(header+don+\"\\n\")\n        acc_fasta_f.write(header+acc+\"\\n\")\n\n    #Close the R1 and R2\n    don_fasta_f.close()\n    acc_fasta_f.close()\n\n    badfj3_gap = \"500000\" #If the don/acc can map within 1/2 Mb, then jct not fusion\n\n    #Run bowtie2 on the R1 and R2\n    with open(badfj3_mapped,\"w\") as badfj3_mapped_f:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n             \"-x\", reference, \"-X\", badfj3_gap, \"--ff\", \"-1\", don_fasta, \"-2\", acc_fasta], stdout=badfj3_mapped_f)\n\n\n    still_fusions = []\n    now_jcts = []\n\n    #Read back the sam file\n    with open(badfj3_mapped,\"r\") as badfj3_mapped_f:\n        for line in badfj3_mapped_f:\n            print line #NOTE!!! need to see how PE output looks\n\n    return still_fusions,now_jcts\n\"\"\"\n\n\n##########################\n#   Reverse Compliment   #\n##########################\n# Just a little helper function to give the reverse compliment of a sequence\ndef reverse_compliment(seq):\n    \"\"\"\n    Goal: take a sequence and return the reverse compliment\n    Arguments:\n        seq is a string of A's,T's,C's,G's, and N's\n\n    Returns:\n        the reverse compliment string\n    \"\"\"\n    comp_dict = {\"A\": \"T\",\n                 \"a\": \"t\",\n                 \"T\": \"A\",\n                 \"t\": \"a\",\n                 \"C\": \"G\",\n                 \"c\": \"g\",\n                 \"G\": \"C\",\n                 \"g\": \"c\",\n                 \"N\": \"N\",\n                 \"n\": \"n\"}\n\n    rev_comp_seq = \"\".join([comp_dict[base] for base in seq])[::-1]\n    return rev_comp_seq\n\n\n################################################################\n#   Print out the constants dict for better version tracking   #\n################################################################\ndef write_constants_dict(constants_dict, params_out_name):\n    \"\"\"\n    Goal: print out the constants dict to inform what parameters were used on the run\n    Arguments:\n        constants_dict is a dict keyed by string and valued by numeric or string\n        params_out_name is the file path to store the constants dict info\n    Returns:\n        None, everything is written to the file\n    \"\"\"\n    uniform_len = max([len(str(key)) for key in constants_dict])\n    spaces = \" \" * uniform_len\n\n    with open(params_out_name, \"w\") as params_out:\n        # Header info with date and time\n        params_out.write(\"Parameter file used for SPORK run\\n\")\n        params_out.write(\"\\tDate \" + time.strftime(\"%d/%m/%y\") + \" (day/month/year)\\n\")\n        params_out.write(\"\\tTime \" + time.strftime(\"%H:%M:%S\") + \"\\n\")\n        params_out.write(\"\\nParameters:\\n\")\n        params_out.write(\"-\" * (uniform_len + 4) + \"\\n\")\n\n        # Loop through the parameters printing nicely\n        len_sorted_params = sorted(constants_dict.keys(), key=lambda k: len(k))\n        for param in len_sorted_params:\n            padded_param = param[:uniform_len] + spaces[:uniform_len - len(param)]\n            param_val = str(constants_dict[param])\n            params_out.write(padded_param + \"    :    \" + param_val + \"\\n\")\n\n\n###################################\n#   Track NUP214 as a test case   #\n###################################\ndef follow_nup214(forward_jct, reverse_jct):\n    \"\"\"\n    Goal: check if forward or reverse nup214 makes more sense in terms\n          of donor and acceptor sites\n    Arguments:\n        forward_jct is of type Junction\n        reverse_jct is of type Junction and is the rev-comp of forward_jct\n\n    Returns:\n        nothing, just writes out info to stdout\n    \"\"\"\n    if (forward_jct.donor_sam.str_gene() == \"NUP214\" or\n                forward_jct.acceptor_sam.str_gene() == \"NUP214\" or\n                reverse_jct.donor_sam.str_gene() == \"NUP214\" or\n                reverse_jct.acceptor_sam.str_gene() == \"NUP214\"):\n        sys.stdout.write(\"Found a NUP214\\n\")\n        sys.stdout.write(forward_jct.verbose_fasta_string())\n        sys.stdout.write(str(forward_jct.donor_sam.gtf) + \"\\n\")\n        sys.stdout.write(str(forward_jct.acceptor_sam.gtf) + \"\\n\")\n        sys.stdout.write(reverse_jct.verbose_fasta_string())\n        sys.stdout.write(str(reverse_jct.donor_sam.gtf) + \"\\n\")\n        sys.stdout.write(str(reverse_jct.acceptor_sam.gtf) + \"\\n\")\n        sys.stdout.write(\"Forward dist: \" + str(forward_dist) + \" reverse_dist: \" + str(reverse_dist) + \"\\n\")\n        sys.stdout.write(\"Forward donor gtf span:\" + str(forward_jct.donor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Forward acceptor gtf span:\" + str(forward_jct.acceptor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Reverse donor gtf span:\" + str(reverse_jct.donor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Reverse acceptor gtf span:\" + str(reverse_jct.acceptor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"\\n\")\n        sys.stdout.flush()\n\n\n###################################\n#   Track NUP214 as a test case   #\n###################################\ndef get_seq_complexity(seq):\n    \"\"\"\n    Goal: take in a string and return the sequence complexity. Makes use of zlib to compress\n          the string and see how much compression occurred. If lots of compression, then seq was low complexity\n\n    Arguments:\n        seq is a sequence (or really any string)\n\n    Return:\n        a float for the string complexity between 0 and 1 (0 is least complex, 1 is most)\n    \"\"\"\n    uncompressed = sys.getsizeof(seq)\n    compressed = sys.getsizeof(zlib.compress(seq))\n    compression = float(compressed) / uncompressed  # 0 is worst, 1 is best (visually making 0.675 cutoff)\n    return compression",
                "filename": "SPORK_utils.py"
              },
              {
                "fileContent": "# Identified junction class\n\n# Imports\nfrom SPORK_SAMEntry import SAMEntry\nimport copy\nimport sys\nimport itertools\nfrom scipy.stats import chisquare\n\n\n# Junction class\nclass Junction(object):\n    __slots__ = [\"consensus\", \"score\", \"bin_pair\", \"bin_pair_group\", \"took_reverse_compliment\", \"constants_dict\",\n                 \"badfj3\", \"donor_sam\", \"acceptor_sam\", \"mapq\", \"jct_ind\", \"best_don_list\", \"best_acc_list\",\n                 \"rev_best_don_list\", \"rev_best_acc_list\", \"is_at_boundary\", \"uniformity_score\", \"collapsed_num\"]\n\n    def __init__(self, consensus, score, bin_pair_group, jct_ind, took_reverse_compliment, constants_dict):\n        \"\"\"\n        Goal: Initialization function of junction\n        Arguments:\n            consensus                -- str\n            score                    -- float\n            bin_pair_group           -- list[bin_pair]\n            took_reverse_coompliment -- bool\n            constants_dict           -- dict[str->multiple types]\n\n        Returns:\n            nothing\n        \"\"\"\n        # Read in arguments\n        self.consensus = consensus\n        self.score = score\n        self.bin_pair_group = bin_pair_group\n        self.jct_ind = jct_ind\n        self.took_reverse_compliment = took_reverse_compliment\n        self.constants_dict = constants_dict\n        self.mapq = 0\n        self.badfj3 = False\n\n        # Find chromosome, bin_pair and strand info from the first mapped read\n        rep_bin_pair = self.bin_pair_group[0]\n        self.bin_pair = rep_bin_pair.bin_pair\n        self.donor_sam = SAMEntry()\n        self.acceptor_sam = SAMEntry()\n\n        # Get some information for the donor sam from the five_prime sam of the bin pair\n        self.donor_sam.chromosome = rep_bin_pair.five_prime_chr\n        self.donor_sam.start = rep_bin_pair.five_prime_SAM.start\n        self.donor_sam.stop = rep_bin_pair.five_prime_SAM.stop\n\n        # Get some information for the acceptor sam from the three_prime sam of the bin pair\n        self.acceptor_sam.chromosome = rep_bin_pair.three_prime_chr\n        self.acceptor_sam.start = rep_bin_pair.three_prime_SAM.start\n        self.acceptor_sam.stop = rep_bin_pair.three_prime_SAM.stop\n\n        self.best_don_list = None\n        self.best_acc_list = None\n        self.rev_best_don_list = None\n        self.rev_best_acc_list = None\n        self.uniformity_score = [-1, 1]\n\n        bin_size = constants_dict[\"bin_size\"]\n        three_prime_loc = [0] * bin_size\n        five_prime_loc = [0] * bin_size\n\n        for bin_pair in bin_pair_group:\n            three_prime_loc[bin_pair.three_prime_SAM.start % bin_size] += 1\n            five_prime_loc[bin_pair.five_prime_SAM.start % bin_size] += 1\n\n        self.uniformity_score = [round(chisquare(three_prime_loc)[1], 5), round(chisquare(five_prime_loc)[1], 5)]\n        self.collapsed_num = 0\n        self.is_at_boundary = False\n\n    # Use the sam's to find the splice index in reference to the concensus\n    def splice_ind(self):\n        \"\"\"\n        Goal: Get the splice site in consensus coordinates [0,len(consensus)-1]\n        Arguments:\n            none\n\n        Returns:\n            the 3' edge of the donor sequence if both sams are defined\n            otherwise returns the middle index of the consensus as a guess\n        \"\"\"\n\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            # NOTE currently doesn't handle gaps well (just returns the donor side index of gap)\n            # comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n            #        \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n            #        \"N\": \"N\", \"n\": \"n\"}\n            acc_seq = self.acceptor_sam.seq\n            # if (self.acceptor_sam.strand == \"-\" and not self.took_reverse_compliment) or (self.acceptor_sam.strand == \"+\" and self.took_reverse_compliment):\n            #    acc_seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n            return self.consensus.find(acc_seq)\n\n        else:\n            return len(self.consensus) / 2\n\n    # Use the sam's again to find the size of the gap between the two pieces\n    def splice_gap(self):\n        \"\"\"\n        Goal: Find the distance between the donor and acceptor splice sites\n              in consensus coordinates [0,len(consensus)-1]\n        Arguments:\n            none\n\n        Returns:\n            the distance between the 3' end of the donor and 5' end of the acceptor\n            if one or both of the sam's are undefined return None\n        \"\"\"\n        # if self.donor_sam.exists and self.acceptor_sam.exists:\n        # RB 5/26/17: Having strange index errors, I think going by lengths is equivalent\n        #    return len(self.consensus) - len(self.donor_sam.seq) - len(self.acceptor_sam.seq)\n\n        # sys.stderr.write(self.consensus+':  '+self.donor_sam.seq+'\\n')\n        # donor_pos = self.consensus.index(self.donor_sam.seq)+len(self.donor_sam.seq)\n        # sys.stderr.write(self.consensus+':  '+self.acceptor_sam.seq+'\\n')\n        # acceptor_pos = self.consensus.index(self.acceptor_sam.seq)\n        # return donor_pos-acceptor_pos\n        # else:\n        #    return None\n        return 0\n\n    # Use the sam's again to find the size of the gap between the two pieces\n    def span(self):\n        \"\"\"\n        Goal: find the genomic span between the sams\n        Arguments:\n            none\n\n        Returns:\n            if both exist subtract the donor and acceptor sites\n            this distance will always be positive\n            if one or both don't exist just return -1\n        \"\"\"\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            span = self.donor_sam.donor() - self.acceptor_sam.acceptor()\n            return abs(span)\n        else:\n            return -1\n\n    # Give a name to the splice type for this junction\n    def splice_type(self):\n        \"\"\"\n        Goal: get the type of splice this junction represents\n        Arguments:\n            none\n\n        Returns:\n            \"Full\" if both sams exist and have zero gaps in the split\n            \"Gapped\" if both sams exist but there is space in the middle\n            \"Five_Only\" if only the donor sam exists\n            \"Three_Only\" if only the acceptor sam exists\n            \"None\" if niether sam exists\n        \"\"\"\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            if self.splice_gap() == 0:\n                return \"Full\"\n            else:\n                return \"Gapped\"\n        elif self.donor_sam.exists:\n            return \"Five_Only\"\n        elif self.acceptor_sam.exists:\n            return \"Three_Only\"\n        else:\n            return \"None\"\n\n    # Check to see if this jct represents a fusion\n    def get_fusion_type(self, span_cutoff=1e5):\n        \"\"\"\n        Goal: check if this junction represents a fusion\n        Arguments:\n            none\n\n        Returns:\n            bool of whether or not the donor and acceptor have different genes\n            if one or more don't exists then return False\n        \"\"\"\n        anonat = \"\"  # Can be 'bot', 'donor', 'acceptor', or 'none'\n        chroms = \"\"  # Can be 'interchrom', 'distant-intrachrom', or 'local-intrachrom'\n        strand = \"\"  # Can be 'inversion', 'plus', or 'minus'\n        revreg = \"\"  # Can be 'rev', 'reg', or 'invert'\n\n        # Get the anonat type\n        if self.at_boundary(\"donor\") and self.at_boundary(\"acceptor\"):\n            anonat = \"both\"\n        elif self.at_boundary(\"donor\"):\n            anonat = \"donor\"\n        elif self.at_boundary(\"acceptor\"):\n            anonat = \"acceptor\"\n        else:\n            anonat = \"niether\"\n\n        # Get the strand type\n        if self.donor_sam.strand != self.acceptor_sam.strand:\n            strand = \"inversion\"\n        elif self.donor_sam.strand == \"+\":\n            strand = \"plus\"\n        elif self.donor_sam.strand == \"-\":\n            strand = \"minus\"\n\n        # Get the chromosomes type\n        if self.donor_sam.chromosome != self.acceptor_sam.chromosome:\n            chroms = \"interchrom\"\n        elif strand == \"inversion\":\n            chroms = \"inversion-intrachrom\"\n        elif self.span() >= span_cutoff:\n            chroms = \"distant-intrachrom\"\n        else:\n            chroms = \"local-intrachrom\"\n\n        # Get the revreg type\n        if strand == \"inversion\":\n            revreg = \"invert\"\n        elif self.donor_sam.donor() < self.acceptor_sam.acceptor() and self.donor_sam.strand == \"+\":\n            revreg = \"reg\"\n        elif self.donor_sam.donor() > self.acceptor_sam.acceptor() and self.donor_sam.strand == \"-\":\n            revreg = \"reg\"\n        else:\n            revreg = \"rev\"\n\n        # Should this be considered a fusion?\n        fusion = \"no_fusion\"\n\n        if anonat == \"both\":\n            if self.splice_gap() != None and abs(self.splice_gap()) <= self.constants_dict[\"fusion_max_gap\"]:\n                #if chroms != \"local-intrachrom\":\n                #    fusion = \"fusion\"\n                fusion = \"fusion\"\n\n        # Concatenate them into one string\n        fusion_type = fusion + \"-\" + anonat + \"_\" + chroms + \"_\" + strand + \"_\" + revreg\n        return fusion_type\n\n    # Get distance to closest splice boundary\n    def boundary_dist(self, splice_site, bowtie_style=True):\n        \"\"\"\n        Goal: get the distance of the specified splice site from the closest exon\n        Arguments:\n            splice_site which is a string and can be either \"donor\" or \"acceptor\"\n            bowtie_style is an optional boolean argument\n                if True (default), then if a donor/acceptor falls to the 'right' of the gtf-site,\n                regardless of strand, it will be a positive distance\n\n                if False, then the strand does matter, and being 5' of gtf is negative and 3' is positive\n\n\n        Returns:\n            the distance to the closest gtf of the specified splice_site\n            the distance being positive or negative means different things based on the bowtie_style parameter\n            explained above\n        \"\"\"\n        # If donor distance is requested\n        if splice_site == \"donor\" and self.donor_sam.gtf:\n            donor_dist = 0\n            if not bowtie_style:\n                if self.donor_sam.strand == \"+\":\n                    donor_dist = self.donor_sam.donor() - self.donor_sam.gtf.donor\n                elif self.donor_sam.strand == \"-\":\n                    donor_dist = self.donor_sam.gtf.donor - self.donor_sam.donor()\n                else:\n                    sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect strand option \\n\")\n                    sys.exit(1)\n            elif bowtie_style:\n                donor_dist = self.donor_sam.donor() - self.donor_sam.gtf.donor\n\n            return donor_dist\n\n        # If acceptor distance is requested\n        elif splice_site == \"acceptor\" and self.acceptor_sam.gtf:\n            acceptor_dist = 0\n            if not bowtie_style:\n                if self.acceptor_sam.strand == \"+\":\n                    acceptor_dist = self.acceptor_sam.acceptor() - self.acceptor_sam.gtf.acceptor\n                elif self.acceptor_sam.strand == \"-\":\n                    acceptor_dist = self.acceptor_sam.gtf.acceptor - self.acceptor_sam.acceptor()\n                else:\n                    sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect strand option \\n\")\n                    sys.exit(1)\n            elif bowtie_style:\n                acceptor_dist = self.acceptor_sam.acceptor() - self.acceptor_sam.gtf.acceptor\n\n            return acceptor_dist\n\n        # If a different string was passed in or the specified gtf doesn't exist\n        else:\n            sys.stderr.write(str(self) + '\\n')\n            sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect str or gtf doesn't exist\\n\")\n            sys.exit(1)\n\n    # Return whether or not an donor and acceptor is at a boundary\n    def at_boundary(self, splice_site):\n        \"\"\"\n        Goal: check to see if the specified sam is at an exon boundary\n        Arguments:\n            splice_site of type string. should be \"donor\" or \"acceptor\"\n            to specify which sam to check\n\n            radius is optional and signifies the maximum distance from\n            an exon boundary to consider a sam. Default is 3\n\n        Returns:\n            a boolean of whether or not the specified sam is within\n            'radius' distance of any exon boundary\n        \"\"\"\n        dist = self.boundary_dist(splice_site)\n        if abs(dist) <= self.constants_dict[\"at_boundary_cutoff\"]:\n            return True\n        else:\n            return False\n\n    # Returns whether or not this junction is linear\n    def linear(self):\n        \"\"\"\n        Goal: check to see if this junction in linear\n        Arguments:\n            none\n\n        Returns:\n            a boolean of whether the junction is linear or not\n        \"\"\"\n        five_prime_bin, three_prime_bin, strand_info = self.bin_pair.split(\"_\")\n        five_prime_chr = five_prime_bin.split(\":\")[0]\n        five_prime_bin = five_prime_bin.split(\":\")[1]\n        three_prime_chr = three_prime_bin.split(\":\")[0]\n        three_prime_bin = three_prime_bin.split(\":\")[1]\n        linear = True if int(five_prime_bin) <= int(three_prime_bin) else False\n        # RB 04/25/17: I'm not sure this is correct, took_reverse_compliment is always False\n        linear = not linear if self.took_reverse_compliment else linear\n        return linear\n\n    # Returns this junction and a reverse compliment of this junction\n    # to facilitate finding the gtf's of each and seeing which form is better\n    def yield_forward_and_reverse(self):\n        \"\"\"\n        Goal: return a copy of self and a reverse compliment of self\n        Arguments:\n            none\n\n        Returns:\n            a tuple of Junction where the first entry is self and the\n            second is a reverse compliment of self\n        \"\"\"\n        # sys.stdout.write(\"Before copy in yield_forward_and_reverse\\n\")\n        rev_self = Junction(self.consensus, self.score, self.bin_pair_group, self.jct_ind, self.took_reverse_compliment,\n                            self.constants_dict)\n        # rev_self = copy.deepcopy(self)\n        # sys.stdout.write(\"After copy in yield_forward_and_reverse\\n\")\n        rev_self.took_reverse_compliment = not rev_self.took_reverse_compliment\n\n        comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n                \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n                \"N\": \"N\", \"n\": \"n\"}\n\n        # Take the reverse compliments of the seqs and switch them between donor and acceptor\n        rev_self.consensus = \"\".join([comp[base] for base in self.consensus])[::-1]\n        rev_self.donor_sam.seq = \"\".join([comp[base] for base in self.donor_sam.seq])[::-1]\n        rev_self.acceptor_sam.seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n        rev_self.donor_sam.seq, rev_self.acceptor_sam.seq = rev_self.acceptor_sam.seq, rev_self.donor_sam.seq\n\n        rev_self.donor_sam.strand = \"-\" if self.acceptor_sam.strand == \"+\" else \"+\"\n        rev_self.acceptor_sam.strand = \"-\" if self.donor_sam.strand == \"+\" else \"+\"\n\n        rev_self.donor_sam.start, rev_self.acceptor_sam.start = self.acceptor_sam.start, self.donor_sam.start\n        rev_self.donor_sam.stop, rev_self.acceptor_sam.stop = self.acceptor_sam.stop, self.donor_sam.stop\n\n        rev_self.donor_sam.md, rev_self.acceptor_sam.md = self.acceptor_sam.md, self.donor_sam.md\n\n        rev_self.donor_sam.chromosome, rev_self.acceptor_sam.chromosome = self.acceptor_sam.chromosome, self.donor_sam.chromosome\n        rev_self.donor_sam.exists = True\n        rev_self.acceptor_sam.exists = True\n\n        if self.best_don_list:\n            rev_self.rev_best_don_list = []\n            rev_self.rev_best_acc_list = []\n            for index in range(len(self.best_don_list)):\n                rev_don = copy.deepcopy(self.best_don_list[index])\n                rev_acc = copy.deepcopy(self.best_acc_list[index])\n\n                rev_don.seq = \"\".join([comp[base] for base in self.best_acc_list[index].seq])[::-1]\n                rev_acc.seq = \"\".join([comp[base] for base in self.best_don_list[index].seq])[::-1]\n\n                rev_don.strand = \"-\" if self.best_acc_list[index].strand == \"+\" else \"+\"\n                rev_acc.strand = \"-\" if self.best_don_list[index].strand == \"+\" else \"+\"\n\n                rev_don.md = self.best_acc_list[index].md\n                rev_acc.md = self.best_don_list[index].md\n\n                rev_don.start = self.best_acc_list[index].start\n                rev_acc.start = self.best_don_list[index].start\n\n                rev_don.stop = self.best_acc_list[index].stop\n                rev_acc.stop = self.best_don_list[index].stop\n\n                rev_don.chromosome = self.best_acc_list[index].chromosome\n                rev_acc.chromosome = self.best_don_list[index].chromosome\n\n                rev_self.rev_best_don_list.append(rev_don)\n                rev_self.rev_best_acc_list.append(rev_acc)\n\n        return self, rev_self\n\n    # Returns this junction and a reverse compliment of this junction\n    # to facilitate finding the gtf's of each and seeing which form is better\n    def yield_reverse(self):\n        \"\"\"\n        Goal: return a reversed self\n        Arguments:\n            none\n\n        Returns:\n            a Junction which is the reverse of self (note does change original)\n        \"\"\"\n        self.took_reverse_compliment = not self.took_reverse_compliment\n\n        comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n                \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n                \"N\": \"N\", \"n\": \"n\"}\n\n        # Take the reverse compliments of the seqs and switch them between donor and acceptor\n        self.consensus = \"\".join([comp[base] for base in self.consensus])[::-1]\n        self.donor_sam.seq = \"\".join([comp[base] for base in self.donor_sam.seq])[::-1]\n        self.acceptor_sam.seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n        self.donor_sam.seq, self.acceptor_sam.seq = self.acceptor_sam.seq, self.donor_sam.seq\n\n        # Flip the strands of both SAMs\n        # NOTE only switch the strands if both are + or -, don't do it otherwise\n        # Interesting that it works this way, but I drew it out and I'm confident\n        if self.donor_sam.strand == self.acceptor_sam.strand:\n            self.donor_sam.strand = \"-\" if self.donor_sam.strand == \"+\" else \"+\"\n            self.acceptor_sam.strand = \"-\" if self.acceptor_sam.strand == \"+\" else \"+\"\n\n        # Trade starts and stops of donor and acceptor and chromosome\n        self.donor_sam.start, self.acceptor_sam.start = self.acceptor_sam.start, self.donor_sam.start\n        self.donor_sam.stop, self.acceptor_sam.stop = self.acceptor_sam.stop, self.donor_sam.stop\n        self.donor_sam.chromosome, self.acceptor_sam.chromosome = self.acceptor_sam.chromosome, self.donor_sam.chromosome\n\n        return self\n\n    # Format the junction for MACHETE in fasta form\n    # NOTE only call this function on 'fusion' identified junctions\n    def fasta_MACHETE(self):\n        \"\"\"\n        Goal: produce a fasta_string for MACHETE\n        Arguments:\n            none\n        Returns:\n            a fasta formatted string (with a newline between header and sequence)\n        \"\"\"\n        # Make the necessary variables\n        chrom1 = self.donor_sam.chromosome\n        chrom2 = self.acceptor_sam.chromosome\n        genes1 = self.donor_sam.str_gene()\n        genes2 = self.acceptor_sam.str_gene()\n        pos1 = self.donor_sam.donor()\n        pos2 = self.acceptor_sam.acceptor()\n        strand1 = self.donor_sam.strand\n        strand2 = self.acceptor_sam.strand\n        fusion_type = self.get_fusion_type()\n\n        # Start building the fasta string\n        fasta_str = \"\"\n        fasta_str += \">\"\n        fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n        fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n        fasta_str += fusion_type\n        fasta_str += \",num=\" + str(len(self.bin_pair_group))\n        fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n        fasta_str += \",score=\" + str(self.score)\n        fasta_str += \",gap=\" + str(self.splice_gap())\n        fasta_str += \",break-point=\" + str(self.splice_ind())\n        fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(self.uniformity_score[1]) + \")\"\n        fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n        fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n        fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n        fasta_str += \",mapq=\" + str(self.mapq)\n        fasta_str += \",badfj3:\" + str(self.badfj3)\n        fasta_str += \",jct_ind=\" + str(self.jct_ind)\n        fasta_str += \"\\n\"\n\n        # Add the actual padded consensus to the output string\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n\n        return fasta_str\n\n    def fasta_header(self):\n        \"\"\"\n        Goal: produce a fasta_string for MACHETE\n        Arguments:\n            none\n        Returns:\n            a fasta formatted string (with a newline between header and sequence)\n        \"\"\"\n        # Make the necessary variables\n        chrom1 = self.donor_sam.chromosome\n        chrom2 = self.acceptor_sam.chromosome\n        genes1 = self.donor_sam.str_gene()\n        genes2 = self.acceptor_sam.str_gene()\n        pos1 = self.donor_sam.donor()\n        pos2 = self.acceptor_sam.acceptor()\n        strand1 = self.donor_sam.strand\n        strand2 = self.acceptor_sam.strand\n        fusion_type = self.get_fusion_type()\n\n        # Start building the fasta string\n        fasta_str = \"\"\n        fasta_str += \">\"\n        fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n        fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n        fasta_str += fusion_type\n        fasta_str += \",num=\" + str(len(self.bin_pair_group))\n        fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n        fasta_str += \",score=\" + str(self.score)\n        fasta_str += \",gap=\" + str(self.splice_gap())\n        fasta_str += \",break-point=\" + str(self.splice_ind())\n        fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n            self.uniformity_score[1]) + \")\"\n        fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n        fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n        fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n        fasta_str += \",mapq=\" + str(self.mapq)\n        fasta_str += \",badfj3:\" + str(self.badfj3)\n        fasta_str += \",jct_ind=\" + str(self.jct_ind)\n\n        return fasta_str\n\n    # Format the junction to print in fasta-esque form\n    def log_string(self):\n        \"\"\"\n        Goal: produce a fasta_string\n        Arguments:\n            optionally include a junction index.\n            if it is included, it will be printed out\n\n        Returns:\n            a description of the junction over multiple lines\n        \"\"\"\n        fasta_str = \"\"\n        fasta_str += \">|\" + str(self.donor_sam.chromosome) + \"|\"\n        fasta_str += str(self.donor_sam.str_gene()) + \" \"\n        fasta_str += str(self.donor_sam.gene_strand()) + \" strand|\"\n        fasta_str += str(self.donor_sam.start) + \"-\"\n        fasta_str += str(self.donor_sam.stop) + \"|\"\n        fasta_str += \"strand1:\" + str(self.donor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist1:\" + str(self.boundary_dist(\"donor\")) + \"|\"\n        fasta_str += \"at_boundary1:\" + str(self.at_boundary(\"donor\")) + \"|\\n\"\n\n        fasta_str += \">|\" + str(self.acceptor_sam.chromosome) + \"|\"\n        fasta_str += str(self.acceptor_sam.str_gene()) + \" \"\n        fasta_str += str(self.acceptor_sam.gene_strand()) + \" strand|\"\n        fasta_str += str(self.acceptor_sam.start) + \"-\"\n        fasta_str += str(self.acceptor_sam.stop) + \"|\"\n        fasta_str += \"strand2:\" + str(self.acceptor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist2:\" + str(self.boundary_dist(\"acceptor\")) + \"|\"\n        fasta_str += \"at_boundary2:\" + str(self.at_boundary(\"acceptor\")) + \"|\\n\"\n\n        fasta_str += \">|splice:\" + str(self.splice_ind()) + \"|\"\n        fasta_str += \"score:\" + str(self.score) + \"|\"\n        fasta_str += \"fusion:\" + str(self.get_fusion_type()) + \"|\"\n        fasta_str += \"num:\" + str(len(self.bin_pair_group)) + \"|\"\n        fasta_str += \"splice:\" + str(self.splice_type()) + \"|\"\n        fasta_str += \"mapq=\" + str(self.mapq) + \"|\"\n        fasta_str += \"badfj3:\" + str(self.badfj3) + \"|\"\n        fasta_str += \"jct_ind:\" + str(self.jct_ind) + \"|\\n\"\n\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n        fasta_str += str(self.donor_sam.seq) + \"\\n\"\n        fasta_str += \" \" * self.splice_ind() + str(self.acceptor_sam.seq) + \"\\n\"\n\n        # Also printing out gtf information\n        # fasta_str += \"Donor_gtf:\"+str(self.donor_sam.gtf)+\"\\n\"\n        # fasta_str += \"Acceptor_gtf:\"+str(self.acceptor_sam.gtf)+\"\\n\"\n        return fasta_str\n\n    # Format the junction to print in fasta form\n    def verbose_fasta_string(self):\n        \"\"\"\n        Goal: produce a fasta formatted string of this junction with lots of header info\n        Arguments:\n            none\n\n        Returns:\n            a fasta string (with a newline between the header and sequence)\n        \"\"\"\n        fasta_str = \"\"\n        fasta_str += \">|chromosome1:\" + str(self.donor_sam.chromosome) + \"|\"\n        fasta_str += \"genes1:\" + str(self.donor_sam.str_gene()) + \"|\"\n        fasta_str += \"start1:\" + str(self.donor_sam.start) + \"|\"\n        fasta_str += \"stop1:\" + str(self.donor_sam.stop) + \"|\"\n        fasta_str += \"strand1:\" + str(self.donor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist1:\" + str(self.boundary_dist(\"donor\")) + \"|\"\n        fasta_str += \"at_boundary1:\" + str(self.at_boundary(\"donor\")) + \"|_\"\n\n        fasta_str += \"|chromosome2:\" + str(self.acceptor_sam.chromosome) + \"|\"\n        fasta_str += \"genes2:\" + str(self.acceptor_sam.str_gene()) + \"|\"\n        fasta_str += \"start2:\" + str(self.acceptor_sam.start) + \"|\"\n        fasta_str += \"stop2:\" + str(self.acceptor_sam.stop) + \"|\"\n        fasta_str += \"strand2:\" + str(self.acceptor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist2:\" + str(self.boundary_dist(\"acceptor\")) + \"|\"\n        fasta_str += \"at_boundary2:\" + str(self.at_boundary(\"acceptor\")) + \"|_|\"\n\n        fasta_str += \"jct_ind:\" + str(self.jct_ind) + \"|\"\n        fasta_str += \"splice:\" + str(self.splice_ind()) + \"|\"\n        fasta_str += \"span:\" + str(self.span()) + \"|\"\n        fasta_str += \"score:\" + str(self.score) + \"|\"\n        fasta_str += \"fusion:\" + str(self.get_fusion_type()) + \"|\"\n        fasta_str += \"num:\" + str(len(self.bin_pair_group)) + \"|\"\n        fasta_str += \"splice-gap:\" + str(self.splice_gap()) + \"|\"\n        fasta_str += \"splice-type:\" + str(self.splice_type()) + \"|\"\n        fasta_str += \"badfj3:\" + str(self.badfj3) + \"|\"\n        fasta_str += \"took-rev-comp:\" + str(self.took_reverse_compliment) + \"|\\n\"\n\n        # Add N padding to the consensus to get a uniform len\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n        return fasta_str\n\n    # Add N padding to the consensus to get a uniform len\n    # With the splice site in the middle\n    def format_consensus(self, splice_flank_len):\n        \"\"\"\n        Goal: return the consensus properly formatted centered and uniform len\n        Arguments:\n            splice_flank_len is an int deciding how long either side should be\n            from the consensus\n        Returns:\n            a string of either the full consensus of None if there is no splice ind\n        \"\"\"\n        full_consensus = None\n        if self.splice_ind() != -1:\n            splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n            left_padding = \"N\" * (splice_flank_len - self.splice_ind())\n            right_padding = \"N\" * (splice_flank_len - (len(self.consensus) - self.splice_ind()))\n            if self.splice_ind() <= splice_flank_len:\n                five_consensus = self.consensus[:self.splice_ind()]\n            else:\n                five_consensus = self.consensus[self.splice_ind() - splice_flank_len:self.splice_ind()]\n            if self.splice_ind() + splice_flank_len >= len(self.consensus):\n                three_consensus = self.consensus[self.splice_ind():]\n            else:\n                three_consensus = self.consensus[self.splice_ind():self.splice_ind() + splice_flank_len]\n            full_consensus = left_padding + five_consensus + three_consensus + right_padding\n        return str(full_consensus)\n\n    # Give back the R1 readIDs used to make this junction\n    def get_read_ids(self):\n        \"\"\"\n        Goal: return a list of the read ids (strings) that made this junction\n        Arguments:\n            none\n        Returns:\n            a list[string] of the read-ids for this junction\n        \"\"\"\n        read_ids = []\n        for bin_pair in self.bin_pair_group:\n            donor_id = bin_pair.five_prime_SAM.read_id.replace(\"/5_prime\", \"\")\n            acceptor_id = bin_pair.five_prime_SAM.read_id.replace(\"/3_prime\", \"\")\n            if donor_id == acceptor_id:\n                read_ids.append(donor_id)\n            else:\n                sys.stderr.write(\"SPORK ERROR, nonmatching ids in jct: [\" + donor_id + \"] vs [\" + acceptor_id + \"]\\n\")\n                sys.exit(1)\n\n        return read_ids\n\n    def add_duplicates(self, duplicate_junctions):\n\n        if self.donor_sam.gtf.synonyms or self.acceptor_sam.gtf.synonyms:\n            chrom1 = self.donor_sam.chromosome\n            chrom2 = self.acceptor_sam.chromosome\n            genes1 = self.donor_sam.str_gene()\n            genes2 = self.acceptor_sam.str_gene()\n            pos1 = self.donor_sam.donor()\n            pos2 = self.acceptor_sam.acceptor()\n            strand1 = self.donor_sam.strand\n            strand2 = self.acceptor_sam.strand\n            fusion_type = self.get_fusion_type()\n\n            # Start building the fasta string\n            fasta_str_org = \"\"\n            fasta_str_org += \">\"\n            fasta_str_org += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n            fasta_str_org += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n            fasta_str_org += fusion_type\n            fasta_str_org += \",num=\" + str(len(self.bin_pair_group))\n            fasta_str_org += \",collapsed_num=\" + str(self.collapsed_num)\n            fasta_str_org += \",score=\" + str(self.score)\n            fasta_str_org += \",gap=\" + str(self.splice_gap())\n            fasta_str_org += \",break-point=\" + str(self.splice_ind())\n            fasta_str_org += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                self.uniformity_score[1]) + \")\"\n            fasta_str_org += \",at_boundary=\" + str(self.is_at_boundary)\n            fasta_str_org += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n            fasta_str_org += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n            fasta_str_org += \",mapq=\" + str(self.mapq)\n            fasta_str_org += \",badfj3:\" + str(self.badfj3)\n            fasta_str_org += \",jct_ind=\" + str(self.jct_ind)\n            fasta_str_org += \"\\n\"\n            if self.donor_sam.gtf.synonyms and self.acceptor_sam.gtf.synonyms:\n                for genes1, genes2 in itertools.product(self.donor_sam.gtf.synonyms, self.acceptor_sam.gtf.synonyms):\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    # genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if self.donor_sam.gtf.synonyms and not self.acceptor_sam.gtf.synonyms:\n                for genes1 in self.donor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if self.donor_sam.gtf.synonyms and not self.acceptor_sam.gtf.synonyms:\n                for genes1 in self.donor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if not self.donor_sam.gtf.synonyms and self.acceptor_sam.gtf.synonyms:\n                for genes2 in self.acceptor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    genes1 = self.donor_sam.str_gene()\n                    # genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n    # More human readable format\n    def __str__(self):\n        \"\"\"\n        Goal: output the junction in an expanded human readable form\n        Arguments:\n            none\n\n        Returns:\n            the string to be printed out\n        \"\"\"\n        out_str = \"\"\n        out_str += \"Junction with bin pair [\" + self.bin_pair + \"] with [\" + str(\n            len(self.bin_pair_group)) + \"] reads mapped\\n\"\n        out_str += \"Linear \" if self.linear() else \"Non-Linear \"\n        out_str += \"Donor on the \" + str(self.donor_sam.strand) + \" strand and acceptor on the \" + str(\n            self.acceptor_sam.strand) + \"\\n\"\n        out_str += \"5' map position [\" + str(self.donor_sam.start) + \"-\" + str(self.donor_sam.stop) + \"]\\n\"\n        out_str += \"3' map position [\" + str(self.acceptor_sam.start) + \"-\" + str(self.acceptor_sam.stop) + \"]\\n\"\n        out_str += \"badfj3:\" + str(self.badfj3) + \"\\n\"\n        out_str += \"Consensus with score [\" + str(self.score) + \"] and donor splice site [\" + str(\n            self.donor_sam.stop) + \"]:\\n\"\n        out_str += str(self.consensus) + \"\\n\"\n        out_str += str(self.donor_sam.seq) + \"\\n\"\n        out_str += \" \" * len(str(self.donor_sam.seq)) + str(self.acceptor_sam.seq) + \"\\n\"\n        out_str += \"Donor genes [\" + str(self.donor_sam.str_gene()) + \"]\\n\"\n        out_str += \"Acceptor genes [\" + str(self.acceptor_sam.str_gene()) + \"]\\n\"\n        return out_str\n\n    # Rank junctions in order of bin_pairs when sorted\n    def __lt__(self, other):\n        \"\"\"\n        Goal: give a comparison operator for the Junction class\n        Arguments:\n            other junction to compare to\n\n        Returns:\n            a boolean of whether or not this bin_pair\n            is smaller than the other bin_pair\n        \"\"\"\n        return self.bin_pair < other.bin_pair",
                "filename": "SPORK_Junction.py"
              },
              {
                "fileContent": "#Class to store GTF entries\n#TODO give this better documentation\n\n#Imports\nimport re\nimport sys\n\nclass GTFEntry(object):\n    __slots__ = [\"chromosome\",\"source\",\"feature\", \"start\",\"stop\",\"score\",\"strand\", \"frame\",\"gene_name\", \"donor\",\"acceptor\",\"span\", \"synonyms\"]\n\n    def __init__(self,gtf_line='chr\\tsrc\\tfeat\\t-1\\t-1\\t-1\\t+\\t0\\tgene_name \"default\";'):\n        \"\"\"\n        Goal: initialize a GTFEntry\n        Arguments:\n            a gtf_line from a standard gtf file, optional, if none given default made\n\n        Returns:\n            nothing\n        \"\"\"\n        split_gtf_line = gtf_line.split(\"\\t\")\n        self.chromosome = split_gtf_line[0]\n        self.source = split_gtf_line[1]\n        self.feature = split_gtf_line[2]\n        self.start = int(split_gtf_line[3])\n        self.stop = int(split_gtf_line[4])\n        self.score = split_gtf_line[5]\n        self.strand = split_gtf_line[6]\n        self.frame = split_gtf_line[7]\n        self.donor = self.stop if self.strand == \"+\" else self.start\n        self.acceptor = self.start if self.strand == \"+\" else self.stop\n        self.span = abs(self.donor-self.acceptor)\n        group_info = split_gtf_line[8]\n        gene_name_pattern = re.compile('gene_name \"(.*?)\";')\n        gene_name = gene_name_pattern.findall(group_info)\n        if len(gene_name) == 0:\n            gene_id_pattern = re.compile('gene_id \"(.*?)\";')\n            gene_name = gene_id_pattern.findall(group_info)\n            if len(gene_name) == 0:\n                sys.stdout.write(\"SPORK ERROR: in gtf init. No found gene_name or gene_id\")\n                sys.stderr.write(\"SPORK ERROR: in gtf init. No found gene_name or gene_id\")\n                sys.exit(1)\n        self.gene_name = gene_name[0]\n        self.synonyms = set()\n    def __str__(self):\n        \"\"\"\n        Goal: yield a string representation of this GTFEntry\n        Arguments:\n            none\n\n        Returns:\n            a string of important info about this GTFEntry\n        \"\"\"\n        ret_str = \"\"\n        ret_str += \"chromosome: \"+self.chromosome+\"\\t\"\n        ret_str += \"name: \"+self.gene_name+\"\\t\"\n        ret_str += \"donor: \"+str(self.donor)+\"\\t\"\n        ret_str += \"accep: \"+str(self.acceptor)+\"\\t\"\n        ret_str += \"strand: \"+self.strand+\"\\t\"\n        ret_str += \"start: \"+str(self.start)+\"\\t\"\n        ret_str += \"stop: \"+str(self.stop)+\"\\t\"\n        return ret_str\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allows comparison between GTFEntries\n        Arguments:\n            other is also a GTFEntry\n\n        Returns:\n            true if self's chromosome is smaller than other's,\n            or if they are shared and self's start position is smaller\n            false otherwise\n        \"\"\"\n        if self.chromosome != other.chromosome:\n            return self.chromosome < other.chromosome\n        else:\n            return self.start < other.start",
                "filename": "SPORK_GTFEntry.py"
              },
              {
                "fileContent": "# Fastq entry class\n\n# Imports\nimport sys\n\n\nclass FastQEntry(object):\n    __slots__ = [\"read_id\", \"seq\", \"plus_line\", \"quality\"]\n\n    def __init__(self, read_id, seq, plus_line, quality):\n        \"\"\"\n        Goal: initialize the FastQEntry object with the appropriate info\n        Arguments:\n            all of the fastq lines one at a time\n            read_id, seq, plus_line, and quality\n\n        Returns:\n            nothing\n        \"\"\"\n        self.read_id = read_id\n        self.seq = seq\n        self.plus_line = plus_line\n        self.quality = quality\n        self.clean()\n\n    def get_edge_thirds(self, min_third=20):\n        \"\"\"\n        Goal: split this FastQEntry into a 5' and 3' FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            a tuple of FastQEntry objects [5',3']\n        \"\"\"\n        third_len = len(self.seq) / 3\n        if third_len < min_third:\n            # sys.stderr.write(\"Skipping read too short to split in thirds: \"+self.read_id+\"\\n\")\n            return None, None\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[2 * third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[2 * third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def get_first_last_n(self, third_len=36):\n        \"\"\"\n        Goal: very similar to the edge \n        Arguments:\n            optional length of n to take (defaulted at 36)\n\n        Returns:\n            a tuple of 5' and 3' FastQEntry objects\n        \"\"\"\n        # Check to make sure can at least get the first and last third in length\n        if len(self.seq) <= third_len * 2:\n            # sys.stderr.write(\"SPORK: Skipping read too short to split in thirds: \"+self.read_id+\" len = \"+str(len(self.seq))+\"\\n\")\n            return None, None\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[-third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[-third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def clean(self):\n        \"\"\"\n        Goal: clean up the read id, sequence, plus line, and quality\n        Arguments:\n            none\n\n        Returns:\n            nothing\n        \"\"\"\n        # self.read_id = self.read_id.replace(\" \",\"_\").replace(\"\\t\",\"_\").replace(\"\\n\",\"\")\n        self.read_id = self.read_id.replace(\"\\n\", \"\")\n        self.seq = self.seq.replace(\"U\", \"T\").replace(\"\\n\", \"\")\n        self.plus_line = self.plus_line.replace(\" \", \"_\").replace(\"\\n\", \"\")\n        self.quality = self.quality.replace(\"\\n\", \"\")\n\n    def __str__(self):\n        \"\"\"\n        Goal: return an easy to print string of a FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            An output string\n        \"\"\"\n        ret_str = \"\"\n        ret_str += self.read_id + \"\\n\"\n        ret_str += self.seq + \"\\n\"\n        ret_str += self.plus_line + \"\\n\"\n        ret_str += self.quality + \"\\n\"\n        return ret_str\n\n    def __lt__(self, other):\n        \"\"\"\n        Goal: allow comparison between two FastQEntry objects based on read_id\n        Arguments:\n            other is a FastQEntry to compare to\n\n        Returns:\n            True if the read id of this object is 'less' than that of the other\n        \"\"\"\n        return self.read_id < other.read_id",
                "filename": "SPORK_FastQEntry.py"
              },
              {
                "fileContent": "#Imports\nimport sys\n\n#build and score consensus function\n#(1) pads the left and right side of each sequence depending on where it mapped in the bin\n#(2) finds a consensus using a majority vote\n#(3) calculates a consensus score as the (number of mismatches)/(total_possible_mismatches)\ndef build_and_score_consensus(mapped_reads, strand, id_to_seq, bin_size, constants_dict, read_num_to_read_id):\n    #Add padding to the left sides of the reads based on where they fell in the bin pair\n    #Note that for the plus strand, more padding should be added the larger ther pos%bin_size value\n    #while this should have less padding on a minus strand read. This is implemented w/ the ternary expression\n    #read_num_to_read_id = constants_dict[\"read_num_to_read_id\"]\n    padded_seqs = []\n    left_padded_seqs = []\n    for mapped_read in mapped_reads:\n        id_key = mapped_read.read_id\n        id_key = id_key.replace(\"/5_prime\",\"\")\n        id_key = id_key.replace(\"/3_prime\",\"\")\n        id_key = read_num_to_read_id[id_key]\n        #id_key = id_key.replace(\"_\",\" \")\n        if id_key in id_to_seq:\n            full_seq = id_to_seq[id_key]\n        else:\n            sys.stderr.write(\"SPORK ERROR: Couldn't find sequence \"+id_key+\" in consensus building\\n\")\n            sys.exit(1)\n        mapped_read.read_id = id_key\n        left_padding = int(mapped_read.start%bin_size) if strand == \"+\" else int(bin_size-mapped_read.start%bin_size)\n        left_padded_seq = \" \"*left_padding+full_seq\n\n        #Don't allow exact sequence duplicates\n        if left_padded_seq not in left_padded_seqs:\n            left_padded_seqs.append(left_padded_seq)\n\n    #Add padding on the right sides so that every sequence is the same length\n    #Handled the same for plus and minus strand\n    max_len_seq = max([len(seq) for seq in left_padded_seqs])\n    for left_padded_seq in left_padded_seqs:\n        left_padded_len = len(left_padded_seq)\n        padding_to_add = max_len_seq-left_padded_len\n        padded_seq = left_padded_seq+\" \"*padding_to_add\n        padded_seqs.append(padded_seq)\n\n    #Go through each position and get the majority vote as the consensus base\n    #The dictionaries are just to help convert letters into indices and back\n    min_bases_per_col = constants_dict[\"min_bases_per_col\"]\n    consensus = \"\"\n    empty_spaces = 0\n    num_possible_discrepancies = 0\n    num_discrepancies = 0\n    base_dict = {\"A\":0,\"C\":1,\"G\":2,\"T\":3}\n    rev_base_dict = {0:\"A\",1:\"C\",2:\"G\",3:\"T\"}\n    for seq_ind in range(max_len_seq):\n        counts = [0,0,0,0]\n        for seq in padded_seqs:\n            base = seq[seq_ind].upper()\n            if base in base_dict:\n                counts[base_dict[base]] += 1\n        total_bases = sum(counts)\n        if total_bases >= min_bases_per_col:\n            num_possible_discrepancies += total_bases\n            max_count = max(counts)\n            num_discrepancies += total_bases-max_count\n            max_index = counts.index(max_count)\n            consensus += rev_base_dict[max_index]\n        else: empty_spaces += 1\n\n    #Give a terrible score if there are 0 possible discrepancies\n    #This arises most often when a junction only has one unique sequence\n    if int(num_possible_discrepancies) <= 0:\n        consensus_score = 999999\n        #sys.stderr.write(\"Null consensus:\\n\"+\"\\n\".join(padded_seqs)+\"\\n\")\n    else:\n        consensus_score = float(num_discrepancies)/int(num_possible_discrepancies)\n\n    #Print out the consensus's in a nice way\n    print_consensus = False\n    if print_consensus:\n        print \"Strand: \"+strand\n        print \"Discrepancies: \"+str(num_discrepancies)\n        print \"=\"*(len(seq)+2)\n        for seq in padded_seqs:\n            print \"|\"+seq+\"|\"\n        print \"=\"*(len(seq)+2)\n        print \"|\"+\" \"*(len(seq)-len(consensus)-min_bases_per_col)+consensus+\" \"*min_bases_per_col+\"|\"\n        left_score_str = \"|Score: \"+str(consensus_score)+\" \"\n        right_score_str = \" \"*(len(seq)+2-len(left_score_str)-1)+\"|\"\n        print left_score_str+right_score_str\n        print \"=\"*(len(seq)+2)\n        print \"\"\n\n    return consensus,consensus_score",
                "filename": "SPORK_consensus_utils.py"
              },
              {
                "fileContent": "#BinPair class\nclass BinPair(object):\n    __slots__ = [\"five_prime_SAM\",\"three_prime_SAM\",\"five_prime_bin\",\"three_prime_bin\", \"five_prime_strand\",\"three_prime_strand\",\"bin_pair\",\"five_prime_chr\",\"three_prime_chr\"]\n\n    def __init__(self,five_prime_SAM,three_prime_SAM,five_prime_bin,three_prime_bin):\n        \"\"\"\n        Goal: setup a BinPair object\n        Arguments:\n            a 5' SAMEntry object, a 3' SAMEntry object, and a bin from each (bins are ints)\n\n        Returns:\n            nothing\n        \"\"\"\n        self.five_prime_SAM = five_prime_SAM\n        self.three_prime_SAM = three_prime_SAM\n        self.five_prime_bin = int(five_prime_bin)\n        self.three_prime_bin = int(three_prime_bin)\n        self.five_prime_strand = five_prime_SAM.strand\n        self.three_prime_strand = three_prime_SAM.strand\n        self.five_prime_chr = five_prime_SAM.chromosome\n        self.three_prime_chr = three_prime_SAM.chromosome\n        self.bin_pair = self.five_prime_chr+\":\"+str(self.five_prime_bin)+\"_\"+self.three_prime_chr+\":\"+str(self.three_prime_bin)+\"_(\"+self.five_prime_strand+\",\"+self.three_prime_strand+\")\"\n\n    #Schematic of what the reverse compliment aims to do:\n    #================\n    #Before flipping:\n    #================\n    #\n    #(+ strand)-----------------------------------------\n    #\n    #             (*)  (#)                (*)  (#)\n    #              ======                  ======\n    #(- strand)----| 3' |------------------| 5' |-------\n    #              ======                  ======\n    #\n    #(*)'s are the upstream positions and (#)'s are the downstream positions\n    #\n    #===============\n    #After flipping:\n    #===============\n    #\n    #             (*)  (#)                (*)  (#)\n    #              ======                  ======\n    #(+ strand)----| 5' |------------------| 3' |-------\n    #              ======                  ======\n    #\n    #(- strand)-----------------------------------------\n    #\n    #So the 5' box got the orig 3' positions and should have the rev comp seq of the orig 3' seq\n    #the same thing happens to the 3' box\n    def take_reverse_compliment(self):\n        \"\"\"\n        Goal: take the reverse compliment of this bin pair\n        Arguments:\n            none\n\n        Returns:\n            itself for use in list comprehensions\n        \"\"\"\n        #Switch all the strands\n        self.five_prime_SAM.strand = \"-\" if self.five_prime_SAM.strand == \"+\" else \"+\"\n        self.three_prime_SAM.strand = \"-\" if self.three_prime_SAM.strand == \"+\" else \"+\"\n        self.five_prime_strand = \"-\" if self.five_prime_strand == \"+\" else \"+\"\n        self.three_prime_strand = \"-\" if self.three_prime_strand == \"+\" else \"+\"\n\n        #Swap the positions of the five and three prime SAMs\n        hold_five_prime_start = self.five_prime_SAM.start\n        hold_five_prime_stop = self.five_prime_SAM.stop\n        self.five_prime_SAM.start = self.three_prime_SAM.start\n        self.five_prime_SAM.stop = self.three_prime_SAM.stop\n        self.three_prime_SAM.start = hold_five_prime_start\n        self.three_prime_SAM.stop = hold_five_prime_stop\n\n        #Take the reverse compliment of the 5' and 3' seqs\n        #The list comprehensions are complicated but I like doing it in one line:\n        #   The [rev_comp_dict[base] for base in self.five_prime_SAM.seq] builds a list of complimentary bases\n        #   The \"\".join takes that list and turns it into a string\n        #   The [::-1] at the very end reverses the string to turn the compliment string into the rev comp string\n        rev_comp_dict = {\"A\":\"T\",\"a\":\"t\",\"T\":\"A\",\"t\":\"a\",\n                         \"C\":\"G\",\"c\":\"g\",\"G\":\"C\",\"g\":\"c\",\n                         \"N\":\"N\",\"n\":\"n\"}\n        rev_comp_5_prime_seq = \"\".join([rev_comp_dict[base] for base in self.five_prime_SAM.seq])[::-1]\n        rev_comp_3_prime_seq = \"\".join([rev_comp_dict[base] for base in self.three_prime_SAM.seq])[::-1]\n\n        #Then put the orig 3' rev comp into the new 5' and vice versa\n        self.five_prime_SAM.seq = rev_comp_3_prime_seq\n        self.three_prime_SAM.seq = rev_comp_5_prime_seq\n\n        #Switch the chromosomes too in case this is a fusion\n        hold_chromosome = self.five_prime_SAM.chromosome\n        self.five_prime_SAM.chromosome = self.three_prime_SAM.chromosome\n        self.three_prime_SAM.chromosome = hold_chromosome\n\n        #Using this in a list comprehension, so I want it to return itself\n        return self\n\n    def __str__(self):\n        \"\"\"\n        Goal: make this object into a string for easy printing\n        Arguments:\n            none\n\n        Returns:\n            a string representation of a bin pair\n        \"\"\"\n        return \"Bin Pair: \"+self.bin_pair+\" Left: \"+self.five_prime_SAM.read_id+\" Right: \"+self.three_prime_SAM.read_id+\"\\n\"\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allow comparison between two binpair objects\n        Arguments:\n            other is a binpair object just like self\n\n        Returns:\n            true if the bin_pair string of self is less than that of other\n        \"\"\"\n        return self.bin_pair < other.bin_pair",
                "filename": "SPORK_BinPair.py"
              },
              {
                "fileContent": "from SPORK_SAMEntry import SAMEntry\nfrom SPORK_utils import *\nimport argparse\nimport itertools\nimport cPickle\nimport pickle\nfrom collections import defaultdict\nimport sys\nimport copy\n\n\ndef find_best_forward_reverse(forward_junction, reverse_junction):\n\n    best_forward_jct = None\n    best_reverse_jct = None\n\n    best_forward_jct_ind = None\n    best_reverse_jct_ind = None\n\n    if not forward_junction.best_don_list:\n        forward_don = forward_junction.donor_sam.gtf\n        forward_acc = forward_junction.acceptor_sam.gtf\n\n        forward_anon = forward_don and forward_acc\n        if forward_anon:\n            best_forward_jct = forward_junction\n            best_forward_don_dist = abs(forward_junction.boundary_dist(\"donor\"))\n            best_forward_acc_dist = abs(forward_junction.boundary_dist(\"acceptor\"))\n    else:\n        for index in range(len(forward_junction.best_don_list)):\n            forward_don = forward_junction.best_don_list[index].gtf\n            forward_acc = forward_junction.best_acc_list[index].gtf\n            forward_anon = forward_don and forward_acc\n            if not forward_anon:\n                continue\n\n            if not best_forward_jct_ind:\n                best_forward_jct_ind = index\n                forward_junction.donor_sam = forward_junction.best_don_list[index]\n                forward_junction.acceptor_sam = forward_junction.best_acc_list[index]\n                best_forward_don_dist = abs(forward_junction.boundary_dist(\"donor\"))\n                best_forward_acc_dist = abs(forward_junction.boundary_dist(\"acceptor\"))\n                continue\n\n            forward_junction.donor_sam = forward_junction.best_don_list[index]\n            forward_junction.acceptor_sam = forward_junction.best_acc_list[index]\n            forward_don_dist = abs(forward_junction.boundary_dist(\"donor\"))\n            forward_acc_dist = abs(forward_junction.boundary_dist(\"acceptor\"))\n\n            forward_dist = forward_don_dist + forward_acc_dist\n            best_forward_dist = best_forward_don_dist + best_forward_acc_dist\n\n            if forward_dist < best_forward_dist:\n                best_forward_jct_ind = index\n                best_forward_don_dist = forward_don_dist\n                best_forward_acc_dist = forward_acc_dist\n\n        if best_forward_jct_ind:\n            best_forward_jct = forward_junction\n            best_forward_jct.donor_sam = best_forward_jct.best_don_list[best_forward_jct_ind]\n            best_forward_jct.acceptor_sam = best_forward_jct.best_acc_list[best_forward_jct_ind]\n        forward_junction.best_don_list = None\n        forward_junction.best_acc_list = None\n\n    if not reverse_junction.rev_best_don_list:\n        reverse_don = reverse_junction.donor_sam.gtf\n        reverse_acc = reverse_junction.acceptor_sam.gtf\n\n        reverse_anon = reverse_don and reverse_acc\n        if reverse_anon:\n            best_reverse_jct = reverse_junction\n            best_reverse_don_dist = abs(reverse_junction.boundary_dist(\"donor\"))\n            best_reverse_acc_dist = abs(reverse_junction.boundary_dist(\"acceptor\"))\n\n    else:\n        for index in range(len(reverse_junction.rev_best_don_list)):\n            reverse_don = reverse_junction.rev_best_don_list[index].gtf\n            reverse_acc = reverse_junction.rev_best_acc_list[index].gtf\n            reverse_anon = reverse_don and reverse_acc\n            if not reverse_anon:\n                continue\n\n            if not best_reverse_jct_ind:\n                best_reverse_jct_ind = index\n                reverse_junction.donor_sam = reverse_junction.rev_best_don_list[index]\n                reverse_junction.acceptor_sam = reverse_junction.rev_best_acc_list[index]\n                best_reverse_don_dist = abs(reverse_junction.boundary_dist(\"donor\"))\n                best_reverse_acc_dist = abs(reverse_junction.boundary_dist(\"acceptor\"))\n                continue\n\n            reverse_junction.donor_sam = reverse_junction.rev_best_don_list[index]\n            reverse_junction.acceptor_sam = reverse_junction.rev_best_acc_list[index]\n            reverse_don_dist = abs(reverse_junction.boundary_dist(\"donor\"))\n            reverse_acc_dist = abs(reverse_junction.boundary_dist(\"acceptor\"))\n\n            reverse_dist = reverse_don_dist + reverse_acc_dist\n            best_reverse_dist = best_reverse_don_dist + best_reverse_acc_dist\n\n            if reverse_dist < best_reverse_dist:\n                best_reverse_jct_ind = index\n                best_reverse_don_dist = reverse_don_dist\n                best_reverse_acc_dist = reverse_acc_dist\n\n        if best_reverse_jct_ind:\n            best_reverse_jct = reverse_junction\n            best_reverse_jct.donor_sam = best_reverse_jct.rev_best_don_list[best_reverse_jct_ind]\n            best_reverse_jct.acceptor_sam = best_reverse_jct.rev_best_acc_list[best_reverse_jct_ind]\n\n        reverse_junction.rev_best_don_list = None\n        reverse_junction.rev_best_acc_list = None\n\n    if not best_forward_jct and not best_reverse_jct:\n        return None\n\n    if not best_reverse_jct:\n        return best_forward_jct\n\n    if not best_forward_jct:\n        return best_reverse_jct\n\n    #best_reverse_don_dist = abs(best_reverse_jct.boundary_dist(\"donor\"))\n    #best_reverse_acc_dist = abs(best_reverse_jct.boundary_dist(\"acceptor\"))\n    best_reverse_dist = best_reverse_don_dist + best_reverse_acc_dist\n\n    #best_forward_don_dist = abs(best_forward_jct.boundary_dist(\"donor\"))\n    #best_forward_acc_dist = abs(best_forward_jct.boundary_dist(\"acceptor\"))\n    best_forward_dist = best_forward_don_dist + best_forward_acc_dist\n\n    if best_forward_acc_dist < best_reverse_dist:\n        return best_forward_jct\n    else:\n        return best_reverse_jct\n\ndef compare_don_acc(jct, best_don, best_acc, test_don, test_acc):\n    # None case\n    if best_don == None and best_acc == None:\n        return test_don, test_acc, \"First don, acc\"\n\n    jct_don_chr = jct.bin_pair_group[0].five_prime_chr\n    jct_don_strand = jct.bin_pair_group[0].five_prime_strand\n    jct_acc_chr = jct.bin_pair_group[0].three_prime_chr\n    jct_acc_strand = jct.bin_pair_group[0].three_prime_strand\n\n    test_same_don_chr = jct_don_chr == test_don.chromosome\n    test_same_acc_chr = jct_acc_chr == test_acc.chromosome\n    test_same_don_strand = jct_don_strand == test_don.strand\n    test_same_acc_strand = jct_acc_strand == test_acc.strand\n\n    best_same_don_chr = jct_don_chr == best_don.chromosome\n    best_same_acc_chr = jct_acc_chr == best_acc.chromosome\n    best_same_don_strand = jct_don_strand == best_don.strand\n    best_same_acc_strand = jct_acc_strand == best_acc.strand\n\n\n    if test_same_don_chr and test_same_acc_chr and test_same_don_strand and test_same_acc_strand:\n        if (abs(test_don.start - jct.bin_pair_group[0].five_prime_SAM.start) > 4*bin_size) or (abs(test_acc.start - jct.bin_pair_group[0].three_prime_SAM.start) > 4*bin_size):\n            #logs.write(\"Distance problem:\\n\")\n            logs.write(\"Distance problem: \" + str(jct.jct_ind) + \" \" + best_don.chromosome + \" \" + test_don.chromosome + \" \" + jct.bin_pair_group[0].five_prime_chr + \" \" + best_don.strand + \" \" + test_don.strand + \" \" + jct.bin_pair_group[0].five_prime_strand + \" \" + str(best_don.start) + \" \" + str(test_don.start) + \" \" + str(jct.bin_pair_group[0].five_prime_SAM.start) + \" \" + best_acc.chromosome + \" \" + test_acc.chromosome + \" \" + jct.bin_pair_group[0].three_prime_chr + \" \" + best_acc.strand + \" \" + test_acc.strand + \" \" + jct.bin_pair_group[0].three_prime_strand + \" \" + str(best_acc.start) + \" \" + str(test_acc.start) + \" \" + str(jct.bin_pair_group[0].three_prime_SAM.start) + \"\\n\")\n            return best_don, best_acc, \"Continue\"\n\n    if test_same_don_chr and test_same_acc_chr and test_same_don_strand and test_same_acc_strand and not (best_same_don_chr and best_same_acc_chr and best_same_don_strand and best_same_acc_strand):\n        return test_don, test_acc, \"Test match chr and strand and best does not\"\n\n    if best_same_don_chr and best_same_acc_chr and best_same_don_strand and best_same_acc_strand and not (test_same_don_chr and test_same_acc_chr and test_same_don_strand and test_same_acc_strand):\n        return best_don, best_acc, \"Best match chr and strand and test does not\"\n\n    # If one pair is on the same chr and the other is not\n    #best_same_chr = best_don.chromosome == best_acc.chromosome\n    #test_same_chr = test_don.chromosome == test_acc.chromosome\n    #if test_same_chr and not best_same_chr:\n    #    return test_don, test_acc\n    #if best_same_chr and not test_same_chr:\n    #    return best_don, best_acc\n\n    # NOTE could extend this to do strand comparisons\n\n    # Now the pairs share chr status determine by which dropped less sequence\n    #best_len = len(best_don.seq) + len(best_acc.seq)\n    #test_len = len(test_don.seq) + len(test_acc.seq)\n    #if best_len != test_len:\n        #logs.write(\"Something is wrong\\n\")\n        #logs.write(best_don.seq + \"=========\" + best_acc.seq + \"\\n\")\n        #logs.write(test_don.seq + \"=========\" + test_acc.seq + \"\\n\")\n    #if best_len > test_len:\n        #return best_don, best_acc, -1\n    #if test_len > best_len:\n        #return test_don, test_acc, -1\n\n    # Now determine by number of mismatches\n    best_mismatches = best_don.num_mismatches + best_acc.num_mismatches\n    test_mismatches = test_don.num_mismatches + test_acc.num_mismatches\n    test_dist = abs(test_don.start - test_acc.start)\n    best_dist = abs(best_don.start - best_acc.start)\n\n    if abs(best_don.start - best_acc.start) == len(best_don.seq):\n        return test_don, test_acc, \"Best distance equals 30\"\n\n    if abs(test_don.start - test_acc.start) == len(test_don.seq):\n        return best_don, best_acc, \"Test distance equals 30\"\n\n    if best_mismatches > test_mismatches:\n        return test_don, test_acc, \"Best has less mismatches\"\n    elif test_mismatches > best_mismatches:\n        return best_don, best_acc, \"Test has less mismatches\"\n    else:\n        return best_don, best_acc, \"Add to the list of best\"\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('-smp', '--splice_mapped_path', help = 'SAM file')\nparser.add_argument('-dj', '--denovo_junctions', help='denovo junctions pickle file')\n#parser.add_argument('-cgd', '--chrom_gtfs_don', help='chrom_gtfs_don')\n#parser.add_argument('-cga', '--chrom_gtfs_acc', help='chrom_gtfs_acc')\n#parser.add_argument('-cdl', '--chrom_don_libs', help='chrom_don_libs')\n#parser.add_argument('-cal', '--chrom_acc_libs', help='chrom_acc_libs')\nparser.add_argument('-gi', '--gtfs_info', help='gtfs_info')\nparser.add_argument('-bs', '--bin_size', help='size of bins in bps to split ref into', required=True)\n#parser.add_argument('-ct', '--collapse_thresh', help='collapse thresh')\nparser.add_argument('-s', '--sample', help = 'sample name')\n\nargs = parser.parse_args()\n\nsplice_mapped_path = args.splice_mapped_path\ndenovo_junctions = pickle.load(open(args.denovo_junctions,\"rb\"))\n\ngtfs_info = pickle.load(open(args.gtfs_info, \"rb\"))\n\nlogs = open(\"logs.info\", \"w\")\n\nchrom_gtfs_don = gtfs_info[\"chrom_gtfs_don\"]\nchrom_gtfs_acc = gtfs_info[\"chrom_gtfs_acc\"]\nchrom_don_libs = gtfs_info[\"chrom_don_libs\"]\nchrom_acc_libs = gtfs_info[\"chrom_acc_libs\"]\nbin_size = int(args.bin_size)\n\n#collapse_thresh = int(args.collapse_thresh)\n\nsplice_dict = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))\nwith open(splice_mapped_path,\"r\") as splice_mapped:\n    for line in splice_mapped:\n        sam = SAMEntry(line)\n        jct_ind,split_ind,kind = sam.read_id.split('_')\n        splice_dict[jct_ind][split_ind][kind].append(sam)\n\ncomp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n\t                \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n\t                \"N\": \"N\", \"n\": \"n\"}\n\njcts_with_splice = []\njcts_wout_splice = []\n\nfor jct in denovo_junctions:\n    best_don, best_acc = None, None\n    best_don_new, best_acc_new = None, None\n    best_don_list, best_acc_list = None, None\n    jct_ind = str(jct.jct_ind)\n    for splice_ind in splice_dict[jct_ind]:\n        dons = splice_dict[jct_ind][splice_ind]['don']\n        accs = splice_dict[jct_ind][splice_ind]['acc']\n\n        # NOTE Just a print out to check for multimappings\n        # if len(dons) > 1 or len(accs) > 1:\n        #    sys.stdout.write('MULTIMAPPING: '+jct_ind+'_'+splice_ind+'\\n')\n        for don, acc in itertools.product(dons, accs):\n            best_don, best_acc, ind = compare_don_acc(jct, best_don, best_acc, don, acc)\n            if ind == \"Test match chr and strand and best does not\" or ind == \"Best distance equals 30\" or ind == \"Best has less mismatches\":\n                best_don_list = None\n                best_acc_list = None\n            if ind == \"Add to the list of best\" and not best_don_list and best_don.chromosome == jct.bin_pair_group[\n                0].five_prime_chr and best_don.strand == jct.bin_pair_group[\n                0].five_prime_strand and best_acc.chromosome == jct.bin_pair_group[\n                0].three_prime_chr and best_acc.strand == jct.bin_pair_group[0].three_prime_strand:\n                best_don_list = [best_don, don]\n                best_acc_list = [best_acc, acc]\n            elif ind == \"Add to the list of best\" and best_don.chromosome == jct.bin_pair_group[\n                0].five_prime_chr and best_don.strand == jct.bin_pair_group[\n                0].five_prime_strand and best_acc.chromosome == jct.bin_pair_group[\n                0].three_prime_chr and best_acc.strand == jct.bin_pair_group[0].three_prime_strand:\n                best_don_list.append(don)\n                best_acc_list.append(acc)\n\n\n    # If there is no splice\n    if best_don == None or best_acc == None:\n        jcts_wout_splice.append(jct)\n        continue\n\n    if best_don.chromosome != jct.bin_pair_group[0].five_prime_chr or best_don.strand != jct.bin_pair_group[0].five_prime_strand or best_acc.chromosome != jct.bin_pair_group[0].three_prime_chr or best_acc.strand != jct.bin_pair_group[0].three_prime_strand:\n        #print str(jct.jct_ind) + \" \" + best_don.chromosome + \" \" + jct.bin_pair_group[0].five_prime_chr + \" \" + best_don.strand + \" \" + jct.bin_pair_group[0].five_prime_strand + \" \" + best_acc.chromosome + \" \" + jct.bin_pair_group[0].three_prime_chr + \" \" + best_acc.strand + \" \" + jct.bin_pair_group[0].three_prime_strand\n        logs.write(str(jct.jct_ind) + \" \" + best_don.chromosome + \" \" + jct.bin_pair_group[0].five_prime_chr + \" \" + best_don.strand + \" \" + jct.bin_pair_group[0].five_prime_strand + \" \" + best_acc.chromosome + \" \" + jct.bin_pair_group[0].three_prime_chr + \" \" + best_acc.strand + \" \" + jct.bin_pair_group[0].three_prime_strand + \"\\n\")\n        continue\n\n    if best_don.chromosome == jct.bin_pair_group[0].five_prime_chr and best_don.strand == jct.bin_pair_group[0].five_prime_strand and best_acc.chromosome == jct.bin_pair_group[0].three_prime_chr and best_acc.strand == jct.bin_pair_group[0].three_prime_strand:\n        for bp in jct.bin_pair_group:\n            if abs(best_don.start - bp.five_prime_SAM.start) > 4*bin_size or abs(best_acc.start - bp.three_prime_SAM.start) > 4*bin_size:\n                logs.write(\"Distance problem:\\n\")\n                logs.write(str(jct.jct_ind) + \" \" + best_don.chromosome + \" \" + bp.five_prime_chr + \" \" + best_don.strand + \" \" + bp.five_prime_strand + \" \" + str(best_don.start) + str(bp.five_prime_SAM.start) + \" \" + best_acc.chromosome + \" \" + bp.three_prime_chr + \" \" + best_acc.strand + \" \" + bp.three_prime_strand + \" \" + str(best_acc.start) + str(bp.three_prime_SAM.start) + \"\\n\")\n                continue\n\n    #best_don_seq = best_don.seq\n    #if best_don.strand == \"-\":\n    #    best_don_seq = \"\".join([comp[base] for base in best_don.seq])[::-1]\n\n\n\n    #best_acc_seq = best_acc.seq\n    #if best_acc.strand == \"-\":\n    #    best_acc_seq = \"\".join([comp[base] for base in best_acc.seq])[::-1]\n\n    #jct.consensus = best_don_seq + best_acc_seq\n    jct.donor_sam = best_don\n    jct.acceptor_sam = best_acc\n    jct.best_don_list = best_don_list\n    jct.best_acc_list = best_acc_list\n\n    jcts_with_splice.append(jct)\n\nsplice_dict = {}\n\nlogs.write(str(len(jcts_with_splice)) + \"\\n\")\nlogs.write(str(len(jcts_wout_splice))  + \"\\n\")\n\n# Return the jcts\n#sys.stdout.write('WITH SPLICE: ' + str(len(jcts_with_splice)) + ' WOUT SPLICE:' + str(len(jcts_wout_splice)) + '\\n')\n#return jcts_with_splice, jcts_wout_splice\n\ndenovo_junctions = jcts_with_splice\n\nforward_jcts = []\nreverse_jcts = []\n\n#logs.write(str(denovo_junctions[0].donor_sam.exists) + \"\\n\")\n#logs.write(str(denovo_junctions[0].acceptor_sam.exists) + \"\\n\")\n\nfor jct in denovo_junctions:\n    # jct.bin_pair_group = []\n    # write_time(\"Got here \",time.time(),timer_file_path)\n    forward_jct, reverse_jct = jct.yield_forward_and_reverse()\n    forward_jcts.append(forward_jct)\n    reverse_jcts.append(reverse_jct)\n\n\n\n#logs.write(str(forward_jcts[0].donor_sam.exists) + \"\\n\")\n#logs.write(str(forward_jcts[0].acceptor_sam.exists) + \"\\n\")\n#logs.write(str(reverse_jcts[0].donor_sam.exists) + \"\\n\")\n#logs.write(str(reverse_jcts[0].acceptor_sam.exists) + \"\\n\")\n#raw_input(\"Press Enter to continue...\")\n\nlogs.write(str(len(forward_jcts)) + \"\\n\")\nlogs.write(str(len(reverse_jcts)) + \"\\n\")\n\nget_jct_gtf_info(forward_jcts, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs)\nget_jct_gtf_info(reverse_jcts, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs)\n\n#raw_input(\"Press Enter to continue...\")\ngtf_denovo_junctions = []\n#count_forward = 0\n#count_reverse = 0\n#count_both = 0\n\nfor jct_ind in range(len(denovo_junctions)):\n    forward_jct = forward_jcts[jct_ind]\n    reverse_jct = reverse_jcts[jct_ind]\n    # sys.stdout.write(str(forward_jct)+\"\\n\")\n    # sys.stdout.flush()\n\n    best_jct = find_best_forward_reverse(forward_jct, reverse_jct)\n    if not best_jct:\n        continue\n\n    best_jct_don_seq = best_jct.donor_sam.seq\n    if (best_jct.donor_sam.strand == \"-\" and not best_jct.took_reverse_compliment) or (best_jct.donor_sam.strand == \"+\" and best_jct.took_reverse_compliment):\n        best_jct_don_seq = \"\".join([comp[base] for base in best_jct.donor_sam.seq])[::-1]\n\n    best_jct_acc_seq = best_jct.acceptor_sam.seq\n    if (best_jct.acceptor_sam.strand == \"-\" and not best_jct.took_reverse_compliment) or (\n                    best_jct.acceptor_sam.strand == \"+\" and best_jct.took_reverse_compliment):\n        best_jct_acc_seq = \"\".join([comp[base] for base in best_jct.acceptor_sam.seq])[::-1]\n\n    if best_jct.consensus.find(best_jct_don_seq + best_jct_acc_seq) == -1:\n        logs.write(\"Something is wrong with consensus sequence. Junction id : \" + str(best_jct.jct_ind) + \". Consensus: \" + best_jct.consensus + \", donor: \" + best_jct_don_seq + \", donor_strand: \" + best_jct.donor_sam.strand + \", acceptor: \" + best_jct_acc_seq + \", acceptor_stand: \" + best_jct.donor_sam.strand + \", took_reverse_compliment: \" + str(best_jct.took_reverse_compliment) + \"\\n\")\n\n    best_jct_don_seq_ref = get_ref_seq(best_jct_don_seq, best_jct.donor_sam.md)\n    best_jct_acc_seq_ref = get_ref_seq(best_jct_acc_seq, best_jct.acceptor_sam.md)\n\n    best_jct.consensus = best_jct.consensus.replace(best_jct_don_seq + best_jct_acc_seq, best_jct_don_seq_ref + best_jct_acc_seq_ref)\n\n    best_jct.donor_sam.seq = best_jct_don_seq_ref\n    if (best_jct.donor_sam.strand == \"-\" and not best_jct.took_reverse_compliment) or (best_jct.donor_sam.strand == \"+\" and best_jct.took_reverse_compliment):\n        best_jct.donor_sam.seq = \"\".join([comp[base] for base in best_jct_don_seq_ref])[::-1]\n\n    best_jct.acceptor_sam.seq = best_jct_acc_seq_ref\n    if (best_jct.acceptor_sam.strand == \"-\" and not best_jct.took_reverse_compliment) or (\n                    best_jct.acceptor_sam.strand == \"+\" and best_jct.took_reverse_compliment):\n        best_jct.acceptor_sam.seq = \"\".join([comp[base] for base in best_jct_acc_seq_ref])[::-1]\n\n    gtf_denovo_junctions.append(best_jct)\n\n    #raw_input(\"Press Enter to continue...\")\n#raw_input(\"Press Enter to continue...\")\n#logs.write(str(count_forward) + \"\\n\")\n#logs.write(str(count_reverse) + \"\\n\")\n#logs.write(str(count_both) + \"\\n\")\n\ndenovo_junctions = gtf_denovo_junctions\n\npickle.dump(denovo_junctions, open(args.sample + \"_denovo_junctions_new.pickle\",\"wb\"), -1)",
                "filename": "create_junctions.py"
              },
              {
                "fileContent": "#Import sys to write to sys.stderr sometimes\nimport sys\n\n#Mapped Read class\nclass SAMEntry(object):\n    __slots__ = [\"read_id\",\"strand\",\"chromosome\",\"start\",\"stop\",\"seq\",\"seq_quality\",\"exists\", \"num_gaps\", \"md\", \"num_mismatches\",\"num_Ns\",\"mapping_quality\",\"alignment_score\",\"gtf\"]\n\n    def __init__(self,full_line = None):\n        \"\"\"\n        Goal: initialize a SAMEntry object\n        Arguments:\n            can take in a full sam line (which it then parses),\n            or nothing, in which case a \"null\" SAMEntry is created\n            with None for every member\n\n        Returns:\n            nothing\n        \"\"\"\n        #Create an empty None-Type ish SAMEntry\n        if not full_line:\n            self.exists          = False\n            self.read_id         = None\n            self.strand          = None\n            self.chromosome      = None\n            self.start           = None\n            self.mapping_quality = None\n            self.seq             = None\n            self.seq_quality     = None\n            self.alignment_score = None\n            self.num_Ns          = None\n            self.num_mismatches  = None\n            self.num_gaps        = None\n            self.md              = None\n            self.stop            = None\n            self.gtf             = None\n\n        #Otherwise actually parse the line\n        else:\n            split_line = full_line.split(\"\\t\")\n            #Example bowtie2 SAM line w/ annotation:\n            #[0:read_id               ] K00180:68:H5CF7BBXX:3:1122:4422:11442/5_prime\n            #[1 :strand (0/16)        ] 0\n            #[2 :chromosome           ] chr21\n            #[3 :position             ] 9827122\n            #[4 :map quality          ] 42\n            #[5 :CIGAR string         ] 33M\n            #[6 :name of mate         ] *\n            #[7 :pos of mate          ] 0\n            #[8 :template len         ] 0\n            #[9 :sequence             ] CTTTGGTCGCTCGCTCCTCTCCTACTTGGATAA\n            #[10:quality string       ] <AAAFJJJFJJJJJFJFJJFJJJJJAJJFAFFJ\n            #[11:Alignment score      ] AS:i:0\n            #[12:number of N's        ] XN:i:0\n            #[13:number of mismatches ] XM:i:0\n            #[14:number gap opens     ] XO:i:0\n            #[15:number gap extensions] XG:i:0\n            #[16:edit distance        ] NM:i:0\n            #[17:string for mismatches] MD:Z:33\n            #[18:whether or not paired] YT:Z:UU\n            self.exists          = True\n            self.read_id         = split_line[0]\n            self.strand          = \"+\" if split_line[1] == \"0\" or split_line[1] == \"256\" else \"-\"\n            self.chromosome      = split_line[2]\n            self.start           = int(split_line[3])\n            self.mapping_quality = int(split_line[4])\n            self.seq             = split_line[9]\n            self.seq_quality     = split_line[10]\n            self.alignment_score = int(split_line[11].split(\":\")[-1])\n\n            for value in split_line[11:]:\n                if value[0:3] == \"XN:\":\n                    self.num_Ns          = int(value.split(\":\")[-1])\n                if value[0:3] == \"XM:\":\n                    self.num_mismatches  = int(value.split(\":\")[-1])\n                if value[0:3] == \"XO:\":\n                    self.num_gaps        = int(value.split(\":\")[-1])\n                if value[0:3] == \"MD:\":\n                    self.md = value.split(\":\")[-1]\n\n            self.stop = self.start+len(self.seq)\n            self.gtf = None\n\n    def donor(self):\n        \"\"\"\n        Goal: return the donor position of the SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            The donor position as an integer\n        \"\"\"\n        don = self.stop if self.strand == \"+\" else self.start\n        return don\n\n    def acceptor(self):\n        \"\"\"\n        Goal: return the acceptor position of the SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            The acceptor position as an integer\n        \"\"\"\n        acc = self.start if self.strand == \"+\" else self.stop\n        return acc\n\n    def str_gene(self):\n        \"\"\"\n        Goal: return the gene name associated with this SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            None in string form if no gene, or the gene name in string form\n        \"\"\"\n        if self.gtf:\n            return str(self.gtf.gene_name)\n        else:\n            return str(self.gtf)\n\n    def gene_strand(self):\n        \"\"\"\n        Goal: return the gtf gene strand associated with this SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            None in string form if no gene, or the gene strand in string form\n        \"\"\"\n        if self.gtf:\n            return str(self.gtf.strand)\n        else:\n            return str(self.gtf)\n\n    def junction(self):\n        \"\"\"\n        Goal: get a string of SAMEntry that looks similar to junction fasta headers\n        Arguments:\n            none\n\n        Returns:\n            a string of this SAMEntry\n        \"\"\"\n        out_str = \"\"\n        out_str += \"jct|\"+self.chromosome.split(\"|\")[1] if \"|\" in self.chromosome else self.chromosome\n        out_str += \"|\"+str(self.start)\n        out_str += \"|\"+str(self.stop)\n        out_str += \"|\"+str(self.strand)\n        return out_str\n\n    def __str__(self):\n        \"\"\"\n        Goal: get a human friendly string representation of SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            a string of important information of self\n        \"\"\"\n        ret_str = \"\"\n        ret_str += str(self.read_id)+\"\\t\"\n        ret_str += str(self.seq)+\"\\t\"\n        ret_str += str(self.chromosome)+\"\\t\"\n        ret_str += str(self.start)+\"\\t\"\n        ret_str += str(self.stop)+\"\\n\"\n        return ret_str\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allow comparison between SAMEntries for sorting\n        Arguments:\n            other is of type SAMEntry as well\n\n        Returns:\n            true if self is on a smaller chromosome, or has a smaller\n            start if chromosomes are shared, otherwise false\n        \"\"\"\n        same_chr = self.chromosome == other.chromosome\n        if not same_chr:\n            return self.chromosome < other.chromosome\n        else:\n            return self.start < other.start",
                "filename": "SPORK_SAMEntry.py"
              }
            ]
          },
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "inputs": [
          {
            "sbg:altPrefix": "--splice_mapped_path",
            "label": "Splice SAM file",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-smp",
              "separate": true
            },
            "id": "#splice_sam_file",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "SAM",
            "description": "Splice SAM file.",
            "required": false
          },
          {
            "id": "#gtfs_info",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-gi",
              "separate": true
            },
            "required": false
          },
          {
            "sbg:altPrefix": "--denovo_junctions",
            "sbg:toolDefaultValue": "PICKLE",
            "label": "Denovo junctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-dj",
              "separate": true
            },
            "id": "#denovo_junctions_pickle",
            "type": [
              "null",
              "File"
            ],
            "description": "Denovo junctions.",
            "required": false
          },
          {
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 10,
              "prefix": "-bs"
            },
            "id": "#bin_size",
            "sbg:altPrefix": "--bin_size",
            "sbg:includeInPorts": true,
            "required": false
          }
        ],
        "outputs": [
          {
            "id": "#used_read_ids",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_used_read_ids.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.splice_sam_file && $job.inputs.splice_sam_file.metadata && $job.inputs.splice_sam_file.metadata.sample_id)\n      return $job.inputs.splice_sam_file.metadata.sample_id\n\treturn \"\"\n}"
                }
              }
            }
          },
          {
            "id": "#pre_collapse_novel_junctions_machete",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*pre_collapse_novel_junctions_machete.fasta"
            },
            "label": "Pre collapse novel junctions machete",
            "description": "Pre collapse novel junctions machete."
          },
          {
            "id": "#logs",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#splice_sam_file",
              "glob": "logs.info"
            }
          },
          {
            "id": "#fusion_junctions_new",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_fusion_junction_ids_new.pickle"
            },
            "label": "Fusion junctions new"
          },
          {
            "id": "#duplicate_junctions",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*duplicate_junctions.pickle"
            }
          },
          {
            "id": "#don_fasta",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_don.fasta",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.splice_sam_file && $job.inputs.splice_sam_file.metadata && $job.inputs.splice_sam_file.metadata.sample_id)\n      return $job.inputs.splice_sam_file.metadata.sample_id\n\treturn \"\"\n}"
                },
                "paired_end": "1"
              }
            },
            "label": "Donor fasta"
          },
          {
            "id": "#denovo_junctions_new",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*denovo_junctions_new.pickle",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.splice_sam_file && $job.inputs.splice_sam_file.metadata && $job.inputs.splice_sam_file.metadata.sample_id)\n      return $job.inputs.splice_sam_file.metadata.sample_id\n\treturn \"\"\n}"
                }
              }
            },
            "label": "Denovo junctions"
          },
          {
            "id": "#collapsing_group_log",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*collapsing_group_log.txt"
            },
            "label": "Collapsing group log",
            "description": "Collapsing group log."
          },
          {
            "id": "#acc_fasta",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_acc.fasta",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.splice_sam_file && $job.inputs.splice_sam_file.metadata && $job.inputs.splice_sam_file.metadata.sample_id)\n      return $job.inputs.splice_sam_file.metadata.sample_id\n\treturn \"\"\n}"
                },
                "paired_end": "2"
              }
            },
            "label": "Acceptor fasta"
          }
        ],
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "value": "c4.8xlarge.ebs20;ebs-gp2;1024",
            "class": "sbg:AWSInstanceType"
          }
        ],
        "baseCommand": [
          "python",
          "create_junctions.py"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n\tif($job.inputs.splice_sam_file && $job.inputs.splice_sam_file.metadata && $job.inputs.splice_sam_file.metadata.sample_id)\n      return \"-s \" + $job.inputs.splice_sam_file.metadata.sample_id\n}"
            },
            "separate": true
          }
        ],
        "sbg:image_url": null,
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520433140,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520433171,
            "sbg:revisionNotes": "revision 14 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520526290,
            "sbg:revisionNotes": "gtfs_info pickle type removed"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1525813957,
            "sbg:revisionNotes": "SPORK_Junction.py and SPORK_SAMEntry and create_junctions.py updated"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1526254853,
            "sbg:revisionNotes": "logs.info added"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1526909686,
            "sbg:revisionNotes": "create_junctions.py: consensus sequence creation updated"
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1526912476,
            "sbg:revisionNotes": "create_junctions.py comp added"
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527419817,
            "sbg:revisionNotes": "create_junctions.py and SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 8,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527425098,
            "sbg:revisionNotes": "SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 9,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527463676,
            "sbg:revisionNotes": "used_read_ids added"
          },
          {
            "sbg:revision": 10,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527504814,
            "sbg:revisionNotes": "SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 11,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527519763,
            "sbg:revisionNotes": "SPORK_Junction.py updated"
          },
          {
            "sbg:revision": 12,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527857127,
            "sbg:revisionNotes": "Continue commented"
          },
          {
            "sbg:revision": 13,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527977805,
            "sbg:revisionNotes": "span_cutoff=1e6"
          },
          {
            "sbg:revision": 14,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528043858,
            "sbg:revisionNotes": "span_cutoff=1e5"
          },
          {
            "sbg:revision": 15,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528207315,
            "sbg:revisionNotes": "SPORK_SAMEntry num_mismatches updated"
          },
          {
            "sbg:revision": 16,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1528293847,
            "sbg:revisionNotes": "create_junctions updated (includes dist)"
          },
          {
            "sbg:revision": 17,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529328937,
            "sbg:revisionNotes": "create_junctions.py and SPORK_utils handles multiple alignments"
          },
          {
            "sbg:revision": 18,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529331247,
            "sbg:revisionNotes": "import copy"
          },
          {
            "sbg:revision": 19,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529589228,
            "sbg:revisionNotes": "back to revision 16"
          },
          {
            "sbg:revision": 20,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529924269,
            "sbg:revisionNotes": "revision 16 + singular_jcts_filtered"
          },
          {
            "sbg:revision": 21,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1529928459,
            "sbg:revisionNotes": "singular_jcts_filtered fixed"
          },
          {
            "sbg:revision": 22,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530010375,
            "sbg:revisionNotes": "handles multiple_alignments"
          },
          {
            "sbg:revision": 23,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530013044,
            "sbg:revisionNotes": "build_and_score_consensus fixed"
          },
          {
            "sbg:revision": 24,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530055845,
            "sbg:revisionNotes": "SPORK_utils updated: handles multiple alignments"
          },
          {
            "sbg:revision": 25,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530107914,
            "sbg:revisionNotes": "consensus seq fixed"
          },
          {
            "sbg:revision": 26,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530137918,
            "sbg:revisionNotes": "continue commented"
          },
          {
            "sbg:revision": 27,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530182780,
            "sbg:revisionNotes": "back to revision 18"
          },
          {
            "sbg:revision": 28,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530216664,
            "sbg:revisionNotes": "SPORK_Junction: add_duplicates, SPORK_GTFEntry: synonyms, create_junctiond: duplicate_junctions.pickle"
          },
          {
            "sbg:revision": 29,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530225096,
            "sbg:revisionNotes": "SPORK_Junction: .gtf.synonyms"
          },
          {
            "sbg:revision": 30,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1530262060,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 31,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531178758,
            "sbg:revisionNotes": "SPORK_Junction: break-point added"
          },
          {
            "sbg:revision": 32,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1531209169,
            "sbg:revisionNotes": "SPORK_Junction: break-point added fixed"
          },
          {
            "sbg:revision": 33,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533115284,
            "sbg:revisionNotes": "sample[:-7] instead of sample"
          },
          {
            "sbg:revision": 34,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533127023,
            "sbg:revisionNotes": "sample[:-7] instead of sample"
          },
          {
            "sbg:revision": 35,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533132797,
            "sbg:revisionNotes": "args.sample instead of args.sample[:-7]"
          },
          {
            "sbg:revision": 36,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533160708,
            "sbg:revisionNotes": "do not collapse and identify fusions"
          },
          {
            "sbg:revision": 37,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533160924,
            "sbg:revisionNotes": "collapse_thresh removed as input"
          },
          {
            "sbg:revision": 38,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533164396,
            "sbg:revisionNotes": "denovo_junctions_new output: metadata: sample_id"
          },
          {
            "sbg:revision": 39,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533645305,
            "sbg:revisionNotes": "add_duplicate: break-point added"
          },
          {
            "sbg:revision": 40,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534781382,
            "sbg:revisionNotes": "SPORK_utils and SPORK_SAMEntry updated, create_junctions supports mismaches"
          },
          {
            "sbg:revision": 41,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534785478,
            "sbg:revisionNotes": "SPORK_SAMEntry fixed"
          },
          {
            "sbg:revision": 42,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534790572,
            "sbg:revisionNotes": "SPORK_SAMEntry fixed"
          },
          {
            "sbg:revision": 43,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534795507,
            "sbg:revisionNotes": "create_junctions fixed"
          },
          {
            "sbg:revision": 44,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534805305,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 45,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534945426,
            "sbg:revisionNotes": "SPORK_Junction updated, create_junctions updated"
          },
          {
            "sbg:revision": 46,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534955774,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 47,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534973542,
            "sbg:revisionNotes": "create_junction fixed: best_jct.consensus="
          },
          {
            "sbg:revision": 48,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535201834,
            "sbg:revisionNotes": "SPORK_Junction, get_fusion_type: span_cutoff=1e6"
          },
          {
            "sbg:revision": 49,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535537791,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 50,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535755023,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e0)"
          },
          {
            "sbg:revision": 51,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535846167,
            "sbg:revisionNotes": "def get_fusion_type(self, span_cutoff=1e3)"
          },
          {
            "sbg:revision": 52,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535908577,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 53,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536347566,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind updated"
          },
          {
            "sbg:revision": 54,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536350351,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 55,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536351481,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 56,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536359295,
            "sbg:revisionNotes": "SPORK_Junction: format_consensus updated"
          },
          {
            "sbg:revision": 57,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536363488,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 58,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536370380,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 59,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536370395,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e6)"
          },
          {
            "sbg:revision": 60,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536419392,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 61,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536448151,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 62,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536704405,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind()"
          },
          {
            "sbg:revision": 63,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536709973,
            "sbg:revisionNotes": "SPORK_Junction: fasta_header() added"
          },
          {
            "sbg:revision": 64,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536972643,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind() and fasta_header() updated"
          },
          {
            "sbg:revision": 65,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537020941,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 66,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537129910,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4)"
          },
          {
            "sbg:revision": 67,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537137833,
            "sbg:revisionNotes": "def get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 68,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537223243,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5), strand"
          },
          {
            "sbg:revision": 69,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537229355,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4), strand"
          },
          {
            "sbg:revision": 70,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537346759,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 71,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1538688886,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4)"
          },
          {
            "sbg:revision": 72,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1539077072,
            "sbg:revisionNotes": "is_at_boundary, get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 73,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545151740,
            "sbg:revisionNotes": "SPORK_utils.py: collapse_junctions"
          },
          {
            "sbg:revision": 74,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545866743,
            "sbg:revisionNotes": "SPORK_Junction.py: get_fusion_type fixed"
          },
          {
            "sbg:revision": 75,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1547547042,
            "sbg:revisionNotes": "SPORK_Junction: get_fusion_type fixed"
          },
          {
            "sbg:revision": 76,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550143569,
            "sbg:revisionNotes": "continue and distance check added"
          },
          {
            "sbg:revision": 77,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550146161,
            "sbg:revisionNotes": "bin_size argument added"
          },
          {
            "sbg:revision": 78,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550157583,
            "sbg:revisionNotes": "-bs instead of -bp"
          },
          {
            "sbg:revision": 79,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550770007,
            "sbg:revisionNotes": "SPORK_utils.py and SPORK_Junction.py updated to support uniformity_score and collapsed_num"
          },
          {
            "sbg:revision": 80,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550773124,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: _SAM instead of _sam"
          },
          {
            "sbg:revision": 81,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550774993,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: bin_pair. added"
          },
          {
            "sbg:revision": 82,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550779690,
            "sbg:revisionNotes": "SPORK_utils.py fixed: repr_jct"
          },
          {
            "sbg:revision": 83,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550785404,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: self.collapsed_num"
          },
          {
            "sbg:revision": 84,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550791493,
            "sbg:revisionNotes": "SPORK_Junction.py: round uniformity score"
          },
          {
            "sbg:revision": 85,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550795710,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: uniformity_score log"
          },
          {
            "sbg:revision": 86,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550959437,
            "sbg:revisionNotes": "SPORK_Junction: uniformity_score log \";\" and allow within gene splicing"
          },
          {
            "sbg:revision": 87,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561587427,
            "sbg:revisionNotes": "Distance problem fixed"
          }
        ],
        "sbg:cmdPreview": "python create_junctions.py  -s SAMPLE",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "splice_sam_file": {
              "metadata": {
                "sample_id": "SAMPLE"
              },
              "size": 0,
              "path": "/path/to/splice_sam_file.ext",
              "class": "File",
              "secondaryFiles": []
            },
            "denovo_junctions_pickle": {
              "secondaryFiles": [],
              "path": "/path/to/denovo_junctions_pickle.ext",
              "class": "File",
              "size": 0
            },
            "gtfs_info": {
              "secondaryFiles": [],
              "path": "/path/to/gtfs_info.ext",
              "class": "File",
              "size": 0
            },
            "bin_size": 8
          }
        },
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/create-junctions/87",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/create-junctions/87",
        "sbg:revision": 87,
        "sbg:revisionNotes": "Distance problem fixed",
        "sbg:modifiedOn": 1561587427,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520433140,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "sbg:latestRevision": 87,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "af580e71628e8814b4fecf591a6aa6c459586da9866590ebb9f2a782827afc917",
        "x": 2416.334812813391,
        "y": -102.31771761779183
      },
      "inputs": [
        {
          "id": "#SPORK_Create_Junctions.splice_sam_file",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.result_sam_file"
          ]
        },
        {
          "id": "#SPORK_Create_Junctions.gtfs_info",
          "source": [
            "#gtfs_info"
          ]
        },
        {
          "id": "#SPORK_Create_Junctions.denovo_junctions_pickle",
          "source": [
            "#SPORK_Build_Consensus_Sequences.denovo_junctions"
          ]
        },
        {
          "id": "#SPORK_Create_Junctions.bin_size",
          "default": 50,
          "source": [
            "#bin_size"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_Create_Junctions.used_read_ids"
        },
        {
          "id": "#SPORK_Create_Junctions.pre_collapse_novel_junctions_machete"
        },
        {
          "id": "#SPORK_Create_Junctions.logs"
        },
        {
          "id": "#SPORK_Create_Junctions.fusion_junctions_new"
        },
        {
          "id": "#SPORK_Create_Junctions.duplicate_junctions"
        },
        {
          "id": "#SPORK_Create_Junctions.don_fasta"
        },
        {
          "id": "#SPORK_Create_Junctions.denovo_junctions_new"
        },
        {
          "id": "#SPORK_Create_Junctions.collapsing_group_log"
        },
        {
          "id": "#SPORK_Create_Junctions.acc_fasta"
        }
      ],
      "sbg:x": 2416.334812813391,
      "sbg:y": -102.31771761779183,
      "scatter": "#SPORK_Create_Junctions.splice_sam_file"
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List Consensus",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String",
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ],
            "required": false
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 2261.6671635045122,
        "y": -96.6145240047718,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3"
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.suppress_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.report_k_alignments",
          "default": 10
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.read_sequence",
          "source": [
            "#SPORK_Build_Consensus_Sequences.putative_splices"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.output_file_suffix"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.number_of_cpu",
          "default": 1
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.coefficient_scoremin_b",
          "default": -0.4
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.aligned_reads_only"
        }
      ],
      "sbg:x": 2261.6671635045122,
      "sbg:y": -96.6145240047718,
      "scatter": "#Bowtie2_2_3_4_1_Aligner_Input_List_Consensus.read_sequence"
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List 5prime",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 3993.3363403215503,
        "y": -566.5629941581213
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.threads",
          "default": 2
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.suppress_sam_records"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.suppress_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.reference_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.read_sequence",
          "source": [
            "#SPORK_GetBasesAroundJunctionPoint.5prime_fasta"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.read_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.output_file_suffix",
          "default": "_5prime_SPORK"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.number_of_cpu",
          "default": 2
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.function_score_min"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.constant_scoremin_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.coefficient_scoremin_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.aligned_reads_only"
        }
      ],
      "sbg:x": 3993.3363403215503,
      "sbg:y": -566.5629941581213
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime",
      "run": {
        "class": "CommandLineTool",
        "label": "Bowtie2-2.3.4.1 Aligner Input List 3prime",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 3986.6682807207717,
        "y": -361.56264478217076
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.threads",
          "default": 2
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.suppress_sam_records"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.suppress_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.reference_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.read_sequence",
          "source": [
            "#SPORK_GetBasesAroundJunctionPoint.3prime_fasta"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.read_gap_penalties"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.output_file_suffix",
          "default": "_3prime_SPORK"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.number_of_cpu",
          "default": 2
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.input_fasta_files",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.function_score_min"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.constant_scoremin_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.coefficient_scoremin_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.aligned_reads_only"
        }
      ],
      "sbg:x": 3986.6682807207717,
      "sbg:y": -361.56264478217076
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2",
      "run": {
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434786,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520434814,
            "sbg:revisionNotes": "revision 2 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1525306849,
            "sbg:revisionNotes": "output unaligned reads updated"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533171459,
            "sbg:revisionNotes": "rm *bt2*"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533223927,
            "sbg:revisionNotes": "&& instead of &"
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String",
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              "File"
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ],
            "required": false
          }
        ],
        "baseCommand": [
          {
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "stdin": "",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "successCodes": [],
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:publisher": "sbg",
        "stdout": "",
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "class": "CommandLineTool",
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:revisionNotes": "&& instead of &",
        "temporaryFailCodes": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "label": "Bowtie2-2.3.4.1 Aligner FJ Indels R2",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "sbg:revision": 4,
        "sbg:modifiedOn": 1533223927,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520434786,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "sbg:latestRevision": 4,
        "sbg:content_hash": null,
        "x": 5215.000207225485,
        "y": 45.0520686461687,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4"
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.read_sequence",
          "source": [
            "#SPORK_Split_Fastq_Files.fastq_file_2"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.output_file_suffix",
          "default": "FJIndels2_SPORK"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.number_of_cpu",
          "default": 2
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.function_n_ceil"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.constant_nceil_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.coefficient_nceil_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.bowtie_index_archive",
          "source": [
            "#SPORK_Bowtie2_Indexer_Indels.bowtie_index_archive"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.aligned_reads_only"
        }
      ],
      "sbg:x": 5215.000207225485,
      "sbg:y": 45.0520686461687,
      "scatter": "#Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.bowtie_index_archive"
    },
    {
      "id": "#SPORK_concatenate_files",
      "run": {
        "class": "CommandLineTool",
        "label": "SPORK_concatenate_files",
        "description": "",
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          },
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import argparse\nimport pickle\nfrom SPORK_SAMEntry import SAMEntry\nfrom SPORK_utils import *\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('-djn', '--denovo_junctions_new', nargs = '+', required=True, help='list of denovo junctions to be concatenated')\n#parser.add_argument(\"-fjn\", \"--fusion_junction_ids_new\", nargs = '+', required=True, help=\"list of fusion junction ids new to be concatenated\")\n#parser.add_argument(\"-dup\", \"--duplicate_junctions\", nargs = '+', required=True, help=\"list of duplicate junctions to be concatenated\")\nparser.add_argument(\"-s\", \"--sample\", required=True, help = \"sample name\")\nparser.add_argument('-ct', '--collapse_thresh', help='collapse thresh')\nparser.add_argument('-gis', '--gtfs_info_seq', help='seq info')\n#parser.add_argument('-lg', '--list_of_genes', help='seq info')\n\nargs = parser.parse_args()\n\ncollapse_thresh = int(args.collapse_thresh)\n\n#list_of_genes = pickle.load(open(args.list_of_genes, \"rb\"))\ngtfs_info_seq = pickle.load(open(args.gtfs_info_seq, \"rb\"))\nchrom_seq_don = gtfs_info_seq[\"chrom_seq_don\"]\nchrom_seq_acc = gtfs_info_seq[\"chrom_seq_acc\"]\n\ndenovo_junctions = []\nfor tmp_name in args.denovo_junctions_new:\n    tmp = pickle.load(open(tmp_name, \"rb\"))\n    denovo_junctions += tmp\n\nlogs = open(\"logs.info\", \"w\")\n\n#machete_style_name = os.path.join(\"pre_collapse_novel_junctions_machete.fasta\")\n#machete_style_file = open(machete_style_name, \"w\")\n#for denovo_junction in denovo_junctions:\n#    jct_ind = denovo_junctions.index(denovo_junction)\n#    machete_style_file.write(denovo_junction.fasta_MACHETE())\n#    if denovo_junction.splice_gap() != 0:\n#        logs.write(str(jct_ind) + \"\\n\")\n#        logs.write(denovo_junction.bin_pair + \"\\n\")\n\n#machete_style_file.close()\n\n#fusion_junctions = identify_fusions(denovo_junctions)\n\ngroup_file_name = os.path.join(\"collapsing_group_log.txt\")\nsingular_jcts,collapsed_jcts = collapse_junctions(denovo_junctions, collapse_thresh, group_file_name)\n\nlogs.write(\"Singular junctions: \" + str(len(singular_jcts)) + \"\\n\")\nlogs.write(\"Collapsed junctions: \" + str(len(collapsed_jcts)) + \"\\n\")\ndenovo_junctions = singular_jcts+collapsed_jcts\n\nfusion_junctions = identify_fusions(denovo_junctions)\n\nfus_jct_dict = {}\nfor jct in fusion_junctions:\n    #if jct.donor_sam.gtf.gene_name in list_of_genes or jct.acceptor_sam.gtf.gene_name in list_of_genes:\n    fus_jct_dict[jct.jct_ind] = 0\n\njct_dict = {}\n\ndon_fasta = args.sample + \"_don.fasta\"\nacc_fasta = args.sample + \"_acc.fasta\"\n\ndon_fasta_f = open(don_fasta,\"w\")\nacc_fasta_f = open(acc_fasta,\"w\")\n\njct_dict = {}\n\nduplicate_junctions = {}\n\nused_read_ids = open(args.sample + \"_used_read_ids.txt\", \"w\")\n\nfor jct in denovo_junctions:\n    if jct.jct_ind in fus_jct_dict:\n\n        #default_don = -10\n        #default_acc = 10\n        don_seq = \"\"\n        acc_seq = \"\"\n        don_key = jct.donor_sam.gtf.chromosome + jct.donor_sam.gtf.strand\n        acc_key = jct.acceptor_sam.gtf.chromosome + jct.acceptor_sam.gtf.strand\n\n        if jct.donor_sam.gtf.strand == \"-\":\n            don_dist = jct.boundary_dist(\"donor\")\n            # default_don -= don_dist\n            don_pos = jct.donor_sam.gtf.start - 1\n            default_don = -chrom_seq_don[don_key][don_pos][\"previous_don\"]\n            # don_seq = chrom_seq_don[don_key][jct.donor_sam.gtf.start - 1][jct.donor_sam.gtf.gene_name][0][5:default_don]\n            # jct.donor_sam.seq = don_seq\n        else:\n            don_dist = jct.boundary_dist(\"donor\") - 1\n            # default_don += don_dist\n            don_pos = jct.donor_sam.gtf.stop\n            default_don = -chrom_seq_don[don_key][don_pos][\"next_don\"]\n            # don_seq = chrom_seq_don[don_key][jct.donor_sam.gtf.stop][jct.donor_sam.gtf.gene_name][0][5:default_don]\n            # jct.donor_sam.seq = don_seq\n\n        if jct.acceptor_sam.gtf.strand == \"-\":\n            acc_dist = jct.boundary_dist(\"acceptor\") - 1\n            # default_acc -= acc_dist\n            acc_pos = jct.acceptor_sam.gtf.stop\n            default_acc = chrom_seq_acc[acc_key][acc_pos][\"next_acc\"]\n            # acc_seq = chrom_seq_acc[acc_key][jct.acceptor_sam.gtf.stop][jct.acceptor_sam.gtf.gene_name][0][default_acc:-5]\n            # jct.acceptor_sam.seq = acc_seq\n        else:\n            acc_dist = jct.boundary_dist(\"acceptor\")\n            # default_acc += acc_dist\n            acc_pos = jct.acceptor_sam.gtf.start - 1\n            default_acc = chrom_seq_acc[acc_key][acc_pos][\"previous_acc\"]\n            # acc_seq = chrom_seq_acc[acc_key][jct.acceptor_sam.gtf.start - 1][jct.acceptor_sam.gtf.gene_name][0][default_acc:-5]\n            # jct.acceptor_sam.seq = acc_seq\n\n        #default_don = -chrom_seq_don[don_key][don_pos][\"next_don\"]\n        #default_acc = chrom_seq_acc[acc_key][acc_pos][\"previous_acc\"]\n\n        if jct.donor_sam.gtf.strand == \"-\" and jct.acceptor_sam.gtf.strand == \"-\" and don_dist < 0 and acc_dist < 0:\n            min_dist = min(-don_dist, -acc_dist)\n            if chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][(default_don - don_dist - min_dist):(default_don - don_dist)] == chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][(default_acc - acc_dist - min_dist):(default_acc - acc_dist)]:\n                don_dist += min_dist\n                acc_dist += min_dist\n\n        if jct.donor_sam.gtf.strand == \"-\" and jct.acceptor_sam.gtf.strand == \"-\" and don_dist > 0 and acc_dist > 0:\n            min_dist = min(don_dist, acc_dist)\n            if chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][(default_don - don_dist):(default_don - don_dist + min_dist)] == chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][(default_acc - acc_dist) : (default_acc - acc_dist + min_dist)]:\n                don_dist -= min_dist\n                acc_dist -= min_dist\n\n        if jct.donor_sam.gtf.strand == \"-\" and jct.acceptor_sam.gtf.strand == \"+\" and don_dist < 0 and acc_dist > 0:\n            min_dist = min(-don_dist, acc_dist)\n            if chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][(default_don - don_dist - min_dist):(default_don - don_dist)] == chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][(default_acc + acc_dist - min_dist):(default_acc + acc_dist)]:\n                don_dist += min_dist\n                acc_dist -= min_dist\n\n        if jct.donor_sam.gtf.strand == \"-\" and jct.acceptor_sam.gtf.strand == \"+\" and don_dist > 0 and acc_dist < 0:\n            min_dist = min(don_dist, -acc_dist)\n            if chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][(default_don - don_dist):(default_don - don_dist + min_dist)] == chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][(default_acc + acc_dist):(default_acc + acc_dist + min_dist)]:\n                don_dist -= min_dist\n                acc_dist += min_dist\n\n        if jct.donor_sam.gtf.strand == \"+\" and jct.acceptor_sam.gtf.strand == \"-\" and don_dist < 0 and acc_dist > 0:\n            min_dist = min(-don_dist, acc_dist)\n            if chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][(default_don + don_dist) : (default_don + don_dist + min_dist)] == chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][(default_acc - acc_dist) : (default_acc - acc_dist + min_dist)]:\n                don_dist += min_dist\n                acc_dist -= min_dist\n\n        if jct.donor_sam.gtf.strand == \"+\" and jct.acceptor_sam.gtf.strand == \"-\" and don_dist > 0 and acc_dist < 0:\n            min_dist = min(don_dist, -acc_dist)\n            if chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][(default_don + don_dist - min_dist):(default_don + don_dist)] == chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][(default_acc - acc_dist - min_dist):(default_acc - acc_dist)]:\n                don_dist -= min_dist\n                acc_dist += min_dist\n\n        if jct.donor_sam.gtf.strand == \"+\" and jct.acceptor_sam.gtf.strand == \"+\" and don_dist < 0 and acc_dist < 0:\n            min_dist = min(-don_dist, -acc_dist)\n            if chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][(default_don + don_dist) : (default_don + don_dist + min_dist)] == chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][(default_acc + acc_dist):(default_acc + acc_dist + min_dist)]:\n                don_dist += min_dist\n                acc_dist += min_dist\n\n        if jct.donor_sam.gtf.strand == \"+\" and jct.acceptor_sam.gtf.strand == \"+\" and don_dist > 0 and acc_dist > 0:\n            min_dist = min(don_dist, acc_dist)\n            if chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][(default_don + don_dist - min_dist):(default_don + don_dist)] == chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][(default_acc + acc_dist - min_dist):(default_acc + acc_dist)]:\n                don_dist -= min_dist\n                acc_dist -= min_dist\n\n        if don_dist==0 and acc_dist ==0:\n            jct.is_at_boundary = True\n\n        if jct.donor_sam.gtf.strand == \"-\":\n            default_don -= don_dist\n            if default_don == 0:\n                don_seq = chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][chrom_seq_don[don_key][don_pos][\"next_don\"]:]\n            else:\n                don_seq = chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][chrom_seq_don[don_key][don_pos][\"next_don\"]:default_don]\n        else:\n            default_don += don_dist\n            if default_don == 0:\n                don_seq = chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][chrom_seq_don[don_key][don_pos][\"previous_don\"]:]\n            else:\n                don_seq = chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][chrom_seq_don[don_key][don_pos][\"previous_don\"]:default_don]\n        if jct.acceptor_sam.gtf.strand == \"-\":\n            default_acc -= acc_dist\n            if default_acc == 0:\n                acc_seq = chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][:-chrom_seq_acc[acc_key][acc_pos][\"previous_acc\"]]\n            else:\n                acc_seq = chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][default_acc:-chrom_seq_acc[acc_key][acc_pos][\"previous_acc\"]]\n        else:\n            default_acc += acc_dist\n            if default_acc == 0:\n                acc_seq = chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][:-chrom_seq_acc[acc_key][acc_pos][\"next_acc\"]]\n            else:\n                acc_seq = chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][default_acc:-chrom_seq_acc[acc_key][acc_pos][\"next_acc\"]]\n\n        if don_seq == \"\":\n            if default_don == 0:\n                don_seq = chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][-150:default_don]\n            else:\n                don_seq = chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][default_don - 150:default_don]\n        if acc_seq == \"\":\n            if default_acc == 0:\n                acc_seq = chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][:150]\n            else:\n                acc_seq = chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][default_acc:default_acc + 150]\n        #don_seq = chrom_seq_don[don_key][don_pos][jct.donor_sam.gtf.gene_name][0][chrom_seq_don[don_key][don_pos][\"previous_don\"]:default_don]\n        #acc_seq = chrom_seq_acc[acc_key][acc_pos][jct.acceptor_sam.gtf.gene_name][0][default_acc:-chrom_seq_acc[acc_key][acc_pos][\"next_acc\"]]\n\n        jct.donor_sam.seq = don_seq\n        jct.acceptor_sam.seq = acc_seq\n\n        jct.consensus = don_seq + acc_seq\n\n        jct_dict[jct.jct_ind] = jct\n        header = \">\"+str(jct.jct_ind)\n        break_point = jct.splice_ind()\n        if break_point == -1:\n            logs.write(\"Break point,junctions splice_ind wrong: \" + str(jct.jct_ind))\n        don = jct.consensus[:break_point]\n        acc = jct.consensus[break_point:]\n\n        jct.add_duplicates(duplicate_junctions)\n\n        #RB: 5/26/17 Change this to map just the first and last 20 bases\n        #don_fasta_f.write(header+\"\\n\"+don+\"\\n\")\n        #acc_fasta_f.write(header+\"\\n\"+acc+\"\\n\")\n\n        if don[:20] != \"NNNNNNNNNNNNNNNNNNNN\" and acc[-20:] != \"NNNNNNNNNNNNNNNNNNNN\" and len(don) > 15 and len(acc) > 15:\n            don_fasta_f.write(header+\"\\n\"+don[:20]+\"\\n\")\n            acc_fasta_f.write(header+\"\\n\"+acc[-20:]+\"\\n\")\n\n        for bin_pair in jct.bin_pair_group:\n            used_read_id = bin_pair.five_prime_SAM.read_id\n            used_read_id = used_read_id[:-3]\n            used_read_ids.write(used_read_id + \"\\n\")\n\nused_read_ids.close()\ndon_fasta_f.close()\nacc_fasta_f.close()\n\npickle.dump(denovo_junctions, open(args.sample + \"_denovo_junctions_all.pickle\",\"wb\"), -1)\npickle.dump(fus_jct_dict, open(args.sample + \"_fusion_junction_ids_new.pickle\",\"wb\"), -1)\npickle.dump(duplicate_junctions, open(args.sample + \"_duplicate_junctions.pickle\",\"wb\"), -1)\n\nlogs.close()",
                "filename": "combine_files.py"
              },
              {
                "fileContent": "# General Imports\nfrom collections import defaultdict\nimport subprocess\nimport itertools\nimport zlib\nimport time\nimport sys\nimport os\nimport re\n\n# Specific Imports\nfrom SPORK_consensus_utils import *\nfrom SPORK_Junction import Junction\nfrom SPORK_BinPair import BinPair\nfrom SPORK_GTFEntry import GTFEntry\nfrom SPORK_SAMEntry import SAMEntry\nfrom SPORK_FastQEntry import FastQEntry\n\n\n\ndef get_ref_seq(read_seq, MD):\n\n    cur_pos = 0\n    reference_string = \"\"\n    k = 0\n    for i, c in enumerate(MD):\n        if c.isdigit():\n            continue\n        if cur_pos != i:\n            num_matches = int(MD[cur_pos:i])\n        else:\n            num_matches = 0\n        reference_string += read_seq[k: k + num_matches]\n        reference_string += c\n        cur_pos = i + 1\n        k = k + num_matches + 1\n    reference_string += read_seq[k:]\n\n    return reference_string\n\n#######################################\n#   Get Reference and GTF from Mode   #\n#######################################\n# Finding the correct reference index based on the mode\n# Human defaults are used and currently the only supported mode\n# Could imagine lots of if else statements with other supported references though\n# Putting this in the utils file should allow for easy reference addition\ndef get_reference_and_gtf_from_mode(ref_dir, abs_path, mode=\"hg19\"):\n    \"\"\"\n    Goal: take in the desired mode and return the index and gtf path\n    Arguments:\n        the path to the circ_ref directory that MACHETE also uses\n        the mode (currently only allows hg19, so this function is mostly for show)\n        will become an 'elif' tree as more and more indicies are added\n\n    Returns:\n        a tuple of (reference_path,gtf_path)\n    \"\"\"\n    # index_path = \"/scratch/PI/horence/rob/index/\"\n    # reference = index_path+\"hg19\"\n    reference = ref_dir\n    gtf_path = \"\"\n    if mode == \"hg19\":\n        sys.stdout.write('SPORK: Reference using hg19\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"hg19_gtfs\")\n        reference = os.path.join(reference, \"hg19_genome\")\n\n    elif mode == \"grch38\":\n        sys.stdout.write('SPORK: Reference using grch38\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"grch38_gtfs\")\n        reference = os.path.join(reference, \"grch38_genome\")\n\n    elif mode == \"mm10\":\n        sys.stdout.write('SPORK: Reference using mm10\\n')\n        gtf_path = os.path.join(abs_path, \"gtfs\", \"mm10_gtfs\")\n        reference = os.path.join(reference, \"mm10_genome\")\n\n    return reference, gtf_path\n\n\n#################################\n#   Find Bin Pair Group Ranges  #\n#################################\n# Run through the bin pair groupings to find the end index of each group\n# Example bin pair list:\n# [0] chr10:45_chr10:55\n# [2] chr10:45_chr10:55\n# [3] chr10:98_chr10:99\n# [4] chr10:145_chr10:155\n# [5] chr10:145_chr10:155\n# [6] chr10:145_chr10:155\n#\n# Output: [2,3,6]\ndef find_bin_pair_group_ranges(bin_pairs, constants_dict, bin_pairs_ids):\n    \"\"\"\n    Goal: take in a sorted list of bin_pairs and collapse them to ranges\n    Arguments:\n        bin_pairs is a list[BinPair] of the bin pairs\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        bin_pair_group_ranges which is a list[[start0,stop0],[start1,stop1],...]\n        also filters out groups that have less then a cutoff of members\n    \"\"\"\n    bin_pair_group_ends = []\n    prev_bin_pair = \"\"\n    for bin_pair_ind in range(len(bin_pairs)):\n        curr_bin_pair = bin_pairs[bin_pair_ind].bin_pair\n        if curr_bin_pair != prev_bin_pair:\n            bin_pair_group_ends.append(bin_pair_ind)\n            prev_bin_pair = curr_bin_pair\n\n    # Remove the 0 at the front of the bin_pair list\n    bin_pair_group_ends = bin_pair_group_ends[1:]\n\n    # Add on the last bin_pair end which will necessarily be the end of the bin_pair list\n    bin_pair_group_ends.append(len(bin_pairs))\n\n    # Find the bin pair ranges\n    bin_pair_group_ranges = []\n    to_remove_bin_pairs = []\n    to_keep_bin_pairs = []\n    for bin_pair_ind in range(len(bin_pair_group_ends) - 1):\n        start_ind = bin_pair_group_ends[bin_pair_ind]\n        stop_ind = bin_pair_group_ends[bin_pair_ind + 1]\n        if stop_ind - start_ind >= (constants_dict[\"group_member_cutoff\"]):  # The \"-1\" is for inclusive counting\n            bin_pair_group_ranges.append([start_ind, stop_ind])\n        else:\n            org_bin_pair = bin_pairs[start_ind].bin_pair\n            left_chr = org_bin_pair.split(\":\")[0]\n            left_pos = org_bin_pair.split(\":\")[1].split(\"_\")[0]\n            right_chr = \"_\".join(org_bin_pair.split(\":\")[1].split(\"_\")[1:])\n            right_pos = org_bin_pair.split(\":\")[2].split(\"_\")[0]\n            strand_left = \"+\" if org_bin_pair.split(\":\")[2].split(\"_\")[1][1] == \"-\" else \"-\"\n            strand_right = \"+\" if org_bin_pair.split(\":\")[2].split(\"_\")[1][3] == \"-\" else \"-\"\n\n            reverse_bin_pair = right_chr + \":\" + right_pos + \"_\" + left_chr + \":\" + left_pos + \"_(\" + strand_right + \",\" + strand_left + \")\"\n            if reverse_bin_pair in bin_pairs_ids:\n                bin_pair_group_ranges.append([start_ind, stop_ind])\n                to_keep_bin_pairs.append(org_bin_pair)\n            else:\n                to_remove_bin_pairs.append(org_bin_pair)\n    # print bin_pair_group_ends\n    # print bin_pair_group_ranges\n    # sys.stdout.flush()\n\n    #with open(\"to_remove_bin_pairs.txt\", \"w\") as f:\n    #    for bin_pair in to_remove_bin_pairs:\n    #        f.write(bin_pair + \"\\n\")\n\n    #with open(\"to_keep_bin_pairs.txt\", \"w\") as f:\n    #    for bin_pair in to_keep_bin_pairs:\n    #        f.write(bin_pair + \"\\n\")\n\n    return bin_pair_group_ranges\n\n\n\n################################\n#   Build Junction Sequences   #\n################################\n# Run through the bin_pair_group_ends to perform:\n# (1) checking if there are enough in each group\n# (2) padding the sequences in the first bin\n# (3) creating a consensus in the first bin\n# (4) scoring the consensus in the first bin\n# (5) repeat (2)-(4) for the second bin\n# (6) average the two consensus scores and see if they are below a cutoff\ndef build_junction_sequences(bin_pairs, bin_pair_group_ranges, full_path_name, constants_dict, read_num_to_read_id):\n    \"\"\"\n    Goal: convert the bin_pairs into a junction object for each bin_pair\n    Arguments:\n        bin_pairs is a list[BinPairs]\n        bin_pair_group_ranges is a list[[start0,stop0],[start1,stop1],...] so its a list of list\n        full_path_name is the 'spaces-removed' file that is looked at to get the full sequences\n            -> this is used to build the consensus for the junction\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        denovo_junctions which is a list[Junction]\n    \"\"\"\n    group_member_cutoff = constants_dict[\"group_member_cutoff\"]\n    consensus_score_cutoff = constants_dict[\"consensus_score_cutoff\"]\n    bin_size = constants_dict[\"bin_size\"]\n    #reference = constants_dict[\"reference\"]\n    denovo_junctions = []\n\n    # Look back at the original full path to get seq lines\n    unaligned_file = open(full_path_name, \"r\")\n    unaligned_reads = unaligned_file.readlines()\n    unaligned_file.close()\n    unaligned_reads = [unaligned_reads[ind] for ind in range(len(unaligned_reads)) if ind % 4 == 0 or ind % 4 == 1]\n    id_to_seq = {}\n\n    # Build the dictionary of read_id to the full read\n    for ind in range(0, len(unaligned_reads), 2):\n        key = unaligned_reads[ind].strip()\n        value = unaligned_reads[ind + 1].strip()\n        id_to_seq[key] = value\n\n    # walk through each bin_pair_group\n    #write_time(\"Working on the bin-pairs :\" + str(len(bin_pair_group_ranges)), time.time(), constants_dict[\"timer_file_path\"])\n\n    num_fail_size = 0\n    num_fail_score = 0\n    jct_ind = 0\n    for bin_pair_group_range in bin_pair_group_ranges:\n        # junction_num = \"(\"+str(bin_pair_group_ranges.index(bin_pair_group_range)+1)+\"/\"+str(len(bin_pair_group_ranges))+\")\"\n        # print junction_num\n        # sys.stdout.flush()\n\n        # start_build_junction = time.time()\n        start_ind = bin_pair_group_range[0]\n        stop_ind = bin_pair_group_range[1]\n        group_members = bin_pairs[start_ind:stop_ind]\n\n        # If there are not enough group members then skip this group\n        #if len(group_members) < group_member_cutoff:\n            # sys.stderr.write(\"Skipped group in build junction seqs\\n\") #expecting to have filtered out before this\n            # sys.stderr.write(\"len(group_members) == \"+str(len(group_members))+\"\\n\")\n            #num_fail_size += 1\n            #continue\n\n        # Otherwise start thinking about getting strandedness\n        five_prime_strand = group_members[0].five_prime_strand\n        three_prime_strand = group_members[0].three_prime_strand\n\n        # Find the consensus sequence and score\n        # Takes just the 5' ends to get the pos\n        # the full original unaligned seq\n        mapped_reads = [member.five_prime_SAM for member in group_members]\n        bin_consensus, bin_score = build_and_score_consensus(mapped_reads, five_prime_strand, id_to_seq, bin_size, constants_dict, read_num_to_read_id)\n        took_reverse_compliment = False\n\n        \"\"\"\n        # TODO what do I do if the five and three prime strands are not the same? (this represents a translocation)\n        # If the reverse compliment was taken above then take the rev compliment of the consensus too\n        # NOTE currently just taking reverse compliment whenever the 5' strand is negative to help groupings\n        #   i.e. if have 5' - and 3' + of a jct and 5' + and 3' - of the same jct, they should be collapsed, but won't be\n        #   unless I implement this\n        #if five_prime_strand == \"-\" and three_prime_strand == \"-\":\n        if five_prime_strand == \"-\":\n            group_members = [member.take_reverse_compliment() for member in group_members]\n            bin_consensus = reverse_compliment(bin_consensus)\n            took_reverse_compliment = True\n\n        \"\"\"\n        # If the bin score is good enough then add it\n        if bin_score < consensus_score_cutoff:\n            denovo_junction = Junction(bin_consensus, bin_score, group_members, jct_ind, took_reverse_compliment, constants_dict)\n            denovo_junctions.append(denovo_junction)\n            jct_ind += 1\n        else:\n            num_fail_score += 1\n\n    #write_time(\"Filtered out bin-pairs by size < \" + str(group_member_cutoff) + \" :\" + str(num_fail_size), time.time(), constants_dict[\"timer_file_path\"])\n    #write_time(\"Filtered out bin-pairs by score < \" + str(consensus_score_cutoff) + \" :\" + str(num_fail_score), time.time(), constants_dict[\"timer_file_path\"])\n    #write_time(\"Number of jcts after build jcts: \" + str(jct_ind), time.time(), constants_dict[\"timer_file_path\"])\n    return denovo_junctions\n\n\n##########################\n#   Find Splice Inds V2  #\n##########################\n# Runs bowtie on all of the possible splice sites of all possible junctions\n# Returns a dict keyed by jct_id and valued by a list of cut sites\ndef find_splice_inds_v2(denovo_junctions, constants_dict):\n    \"\"\"\n    Goal: find where in the consensus sequence to make and donor and acceptor cut\n    Arguments:\n        denovo_junctions is a list[Junction]\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        returns a tuple of (jcts_with_splice,jcts_without_splice)\n        to allow for continuing with only jcts that had a splice site found\n\n    Program flow:\n        1. Write all possible splice cuts for all possible\n           consensus seq jcts to a fasta file\n\n        2. Map this file to the genome reference\n           --> Don't allow gaps\n           --> Report the best k unique multiple mappings for each read\n\n        3. Look through the mapping file for each junction to find the best splice site\n           --> Preference should primarily be given to splits that map close to each other\n           --> Next preference is the most amount of the consensus successfully mapped\n    \"\"\"\n\n    # Get parameters from the constants_dict\n    splice_fasta_path = os.path.join(constants_dict[\"output_dir\"], \"putative_splices.fa\")\n    splice_mapped_path = os.path.join(constants_dict[\"output_dir\"], \"putative_splices.sam\")\n    flank_len = constants_dict[\"splice_finding_flank\"]\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    max_mismatches = int(constants_dict[\"splice_finding_allowed_mismatches\"])\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n    n_multimap = \"10\"\n\n    # 1. Write all possible splice cuts for all possible jcts to a fasta\n    #   if seq is abcdefghijklmnopqrstuvwxyz and thirds_len = 10 then you would want:\n    #       [abcdefghij]|[klmnopqrst]uvwxyz\n    #       a[bcdefghijk]|[lmnopqrstu]vwxyz\n    #       ab[cdefghijkl]|[mnopqrstuv]wxyz\n    #       abc[defghijklm]|[nopqrstuvw]xyz\n    #       abcd[efghijklmn]|[opqrstuvwx]yz\n    #       abcde[fghijklmno]|[pqrstuvwxy]z\n    #       abcdef[ghijklmnop]|[qrstuvwxyz]\n    #   where the first [] group is don and second [] group is acc\n    with open(splice_fasta_path, 'w') as splice_fasta:\n        for jct in denovo_junctions:\n            seq = jct.consensus\n            jct_ind = jct.jct_ind\n            for split_ind in range(flank_len, len(seq) - flank_len + 1):\n                don_seq = seq[:split_ind][-flank_len:]\n                acc_seq = seq[split_ind:][:flank_len]\n                base_header = '>' + str(jct_ind) + '_' + str(split_ind)\n\n                splice_fasta.write(base_header + '_don\\n' + don_seq + '\\n')\n                splice_fasta.write(base_header + '_acc\\n' + acc_seq + '\\n')\n\n    # 2. Map the splice fasta to the genome reference\n    with open(splice_mapped_path, \"w\") as splice_mapped:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-hd\", \"--no-unal\", min_score, read_gap_score,\n             ref_gap_score, \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, splice_fasta_path],\n            stdout=splice_mapped)\n\n    # 3. Look through the mapping file for each junction to find the best splice site\n    #   no sorting guarantees so have to read all in at once\n    #   (could pre-sort if this is too mem intensive)\n\n    # Maybe this is poor coding, but splice_dict is a 3-deep default dictionary\n    #   the 1st level is the jct_index\n    #   the 2nd level is the splice_index\n    #   the 3rd level is either 'don' or 'acc'\n    # Could have made a flat dict with a combination key of the levels\n    #   but then I would have to keep track of what the jct and splice indices are\n    splice_dict = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))\n    with open(splice_mapped_path, \"r\") as splice_mapped:\n        for line in splice_mapped:\n            sam = SAMEntry(line)\n            jct_ind, split_ind, kind = sam.read_id.split('_')\n            splice_dict[jct_ind][split_ind][kind].append(sam)\n\n    # Internal splice comparing function\n    def compare_don_acc(best_don, best_acc, test_don, test_acc):\n        # None case\n        if best_don == None and best_acc == None:\n            return test_don, test_acc\n\n        # If one pair is on the same chr and the other is not\n        best_same_chr = best_don.chromosome == best_acc.chromosome\n        test_same_chr = test_don.chromosome == test_acc.chromosome\n        if test_same_chr and not best_same_chr:\n            return test_don, test_acc\n        if best_same_chr and not test_same_chr:\n            return best_don, best_acc\n\n        # NOTE could extend this to do strand comparisons\n\n        # Now the pairs share chr status determine by which dropped less sequence\n        best_len = len(best_don.seq) + len(best_acc.seq)\n        test_len = len(test_don.seq) + len(test_acc.seq)\n        if best_len > test_len:\n            return best_don, best_acc\n        if test_len > best_len:\n            return test_don, test_acc\n\n        # Now determine by number of mismatches\n        best_mismatches = best_don.num_mismatches + best_acc.num_mismatches\n        test_mismatches = test_don.num_mismatches + test_acc.num_mismatches\n        if best_mismatches > test_mismatches:\n            return test_don, test_acc\n        else:\n            return best_don, best_acc\n\n    # Loop through the jcts looking throughout the entire splice_dict\n    jcts_with_splice = []\n    jcts_wout_splice = []\n\n    for jct in denovo_junctions:\n        best_don, best_acc = None, None\n        jct_ind = str(jct.jct_ind)\n        for splice_ind in splice_dict[jct_ind]:\n            dons = splice_dict[jct_ind][splice_ind]['don']\n            accs = splice_dict[jct_ind][splice_ind]['acc']\n\n            # NOTE Just a print out to check for multimappings\n            # if len(dons) > 1 or len(accs) > 1:\n            #    sys.stdout.write('MULTIMAPPING: '+jct_ind+'_'+splice_ind+'\\n')\n\n            for don, acc in itertools.product(dons, accs):\n                best_don, best_acc = compare_don_acc(best_don, best_acc, don, acc)\n\n        # If there is no splice\n        if best_don == None or best_acc == None:\n            jcts_wout_splice.append(jct)\n            continue\n\n        # Otherwise update jct data\n        jct.consensus = best_don.seq + best_acc.seq\n        jct.donor_sam = best_don\n        jct.acceptor_sam = best_acc\n        jcts_with_splice.append(jct)\n\n    # Return the jcts\n    sys.stdout.write('WITH SPLICE: ' + str(len(jcts_with_splice)) + ' WOUT SPLICE:' + str(len(jcts_wout_splice)) + '\\n')\n    return jcts_with_splice, jcts_wout_splice\n\n\n########################\n#   Find Splice Inds   #\n########################\n# Runs bowtie on all of the possible splice sites of all possible junctions\n# Returns a dict keyed by jct_id and valued by a list of cut sites\ndef find_splice_inds(denovo_junctions, constants_dict):\n    \"\"\"\n    Goal: find where in the consensus sequence to make and donor and acceptor cut\n    Arguments:\n        denovo_junctions is a list[Junction]\n        the constants_dict is a dictionary of global constants\n\n    Returns:\n        returns a tuple of (jcts_with_splice,jcts_without_splice)\n        to allow for continuing with only jcts that had a splice site found\n    \"\"\"\n    # Gather info from the constants dictionary\n    splice_finder_temp_name = os.path.join(constants_dict[\"output_dir\"], \"splice_finder_temp_\")\n    thirds_len = constants_dict[\"thirds_len\"]\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    max_mismatches = int(constants_dict[\"splice_finding_allowed_mismatches\"])\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    allowed_mappings = constants_dict[\"splice_finding_allowed_mappings\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n\n    # Handle temporary files\n    five_prime_mapped_name = splice_finder_temp_name + \"5_prime.sam\"\n    three_prime_mapped_name = splice_finder_temp_name + \"3_prime.sam\"\n    five_prime_fa_file = splice_finder_temp_name + \"5_prime.fa\"\n    three_prime_fa_file = splice_finder_temp_name + \"3_prime.fa\"\n    five_temp_file = open(five_prime_fa_file, \"w\")\n    three_temp_file = open(three_prime_fa_file, \"w\")\n\n    # Do all the aligning work only if there are no mapped files already\n    if use_prior and os.path.isfile(five_prime_mapped_name) and os.path.isfile(three_prime_mapped_name):\n        write_time(\"--Using existing files in splice ind id\", time.time(), constants_dict[\"timer_file_path\"])\n    else:\n        # Write out all the possible splice sites for every jct out to a 5' and 3' file\n        num_size_excluded = 0\n        avg_cons_len = 0\n        for jct_ind in range(len(denovo_junctions)):\n            sys.stdout.flush()\n            junction = denovo_junctions[jct_ind]\n            cons_len = len(junction.consensus)\n            avg_cons_len = (float(jct_ind * avg_cons_len) / (jct_ind + 1)) + (float(cons_len) / (jct_ind + 1))\n            # splice_map_size = len(junction.consensus)/3\n            # NOTE found that I was forcinng splice sites to be too central if I used the thirds len\n            # NOTE and lost BCR-ABL this way, so instead I'll stick with using 1/3 of the consensus\n            splice_map_size = thirds_len\n            # sys.stderr.write(\"Cons len \"+str(cons_len)+\" and thirds_len \"+str(splice_map_size)+\"\\n\")\n\n            five_prime_list = [junction.consensus[ind:ind + splice_map_size]\n                               for ind in range(0, cons_len - 2 * splice_map_size + 1)]\n\n            three_prime_list = [junction.consensus[ind:ind + splice_map_size]\n                                for ind in range(splice_map_size, cons_len - splice_map_size + 1)]\n\n            # Oh this is my problem, sometimes the consensus length is too small\n            # to try and find splice inds from, so I should just throw that out and iterate,\n            # otherwise I'll have blank lines added to my splice ind fa files and they will be\n            # incorrectly formatted\n            if len(five_prime_list) == 0 or len(three_prime_list) == 0:\n                num_size_excluded += 1\n                continue\n\n            five_prime_fa_list = [\">jct_\" + str(jct_ind) + \"_ind_\" + str(ind) + \"\\n\"\n                                  + five_prime_list[ind] for ind in range(len(five_prime_list))]\n\n            three_prime_fa_list = [\">jct_\" + str(jct_ind) + \"_ind_\" + str(ind) + \"\\n\"\n                                   + three_prime_list[ind] for ind in range(len(three_prime_list))]\n\n            five_temp_file.write(\"\\n\".join(five_prime_fa_list) + \"\\n\")\n            three_temp_file.write(\"\\n\".join(three_prime_fa_list) + \"\\n\")\n\n        # Don't forget to close the files :)\n        five_temp_file.close()\n        three_temp_file.close()\n        sys.stdout.write(\"SPORK: Average consensus length [\" + str(avg_cons_len) + \"]\\n\")\n        sys.stdout.write(\"SPORK: Splitting fqs, size excluded [\" + str(num_size_excluded) + \"] of [\" + str(\n            len(denovo_junctions)) + \"]\\n\")\n\n        # Map the temp files above to the reference and save in temp sam files\n        # Need to specify the -f flag because the inputs are fasta files\n        with open(five_prime_mapped_name, \"w\") as five_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-x\", reference, five_prime_fa_file], stdout=five_prime_mapped)\n\n        with open(three_prime_mapped_name, \"w\") as three_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-x\", reference, three_prime_fa_file], stdout=three_prime_mapped)\n\n        # Map the temp files above to the reference and save in temp sam files\n        # Need to specify the -f flag because the inputs are fasta files\n        \"\"\"\n        n_multimap = \"10\"\n        with open(five_prime_mapped_name,\"w\") as five_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, five_prime_fa_file], stdout=five_prime_mapped)\n\n        with open(three_prime_mapped_name,\"w\") as three_prime_mapped:\n            subprocess.call(\n                [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score,\n                 \"-p\", num_threads, \"-k\", n_multimap, \"-x\", reference, three_prime_fa_file], stdout=three_prime_mapped)\n        \"\"\"\n\n        # Sort the temp output files after removing the header lines\n        p1 = subprocess.Popen([\"grep\", \"-v\", \"@\", five_prime_mapped_name], stdout=subprocess.PIPE)\n        p2 = subprocess.Popen([\"sort\", \"-o\", five_prime_mapped_name], stdin=p1.stdout)\n        p2.communicate()\n\n        p3 = subprocess.Popen([\"grep\", \"-v\", \"@\", three_prime_mapped_name], stdout=subprocess.PIPE)\n        p4 = subprocess.Popen([\"sort\", \"-o\", three_prime_mapped_name], stdin=p3.stdout)\n        p4.communicate()\n\n    # Open the mapped, sorted, headerless files\n    five_prime_sam_file = open(five_prime_mapped_name, \"r\")\n    three_prime_sam_file = open(three_prime_mapped_name, \"r\")\n\n    # Try and find the best splice sites walking through both files at once\n    best_splices = {}\n    sam_five_list = []\n    sam_three_list = []\n    prev_jct_ind = 0\n    five_sam_line = five_prime_sam_file.readline()\n    three_sam_line = three_prime_sam_file.readline()\n    while five_sam_line and three_sam_line:\n        sys.stdout.flush()\n        five_sam_entry = SAMEntry(five_sam_line)\n        three_sam_entry = SAMEntry(three_sam_line)\n\n        five_jct_ind = int(five_sam_entry.read_id.split(\"_\")[1])\n        three_jct_ind = int(three_sam_entry.read_id.split(\"_\")[1])\n\n        # Both the 5' and 3' sam are the prev_jct_ind\n        if five_jct_ind == prev_jct_ind and three_jct_ind == prev_jct_ind:\n            if five_sam_entry.num_mismatches <= max_mismatches:\n                sam_five_list.append(five_sam_entry)\n            if three_sam_entry.num_mismatches <= max_mismatches:\n                sam_three_list.append(three_sam_entry)\n            five_sam_line = five_prime_sam_file.readline()\n            three_sam_line = three_prime_sam_file.readline()\n\n        # Only the 5' sam is at the prev_jct_ind\n        elif five_jct_ind == prev_jct_ind:\n            if five_sam_entry.num_mismatches <= max_mismatches:\n                sam_five_list.append(five_sam_entry)\n            five_sam_line = five_prime_sam_file.readline()\n\n        # Only the 3' sam is at the prev_jct_ind\n        elif three_jct_ind == prev_jct_ind:\n            if three_sam_entry.num_mismatches <= max_mismatches:\n                sam_three_list.append(three_sam_entry)\n            three_sam_line = three_prime_sam_file.readline()\n\n        # Niether the 5' nor 3' sam is at the prev_jct_ind\n        else:\n            # RB 11/18/16 Filter out 5' and 3' sams if chroms are not the same as the unsplit\n            # RB 11/21/16 Also imposing a radius on the same chromosome filter (start at 30, very tight)\n            # RB 05/26/17 Actually I don't want to impose this restriction, would be ok with\n            #            different alignments than the original\n            #            this boils down to just commenting out this 'extra' filtering\n            radius = 30\n            pj = denovo_junctions[prev_jct_ind]\n\n            \"\"\"\n            sam_five_list = [sam for sam in sam_five_list\n                             if (sam.chromosome == pj.donor_sam.chromosome and \n                                 abs(pj.donor_sam.start-sam.start) < radius)]\n\n            sam_three_list = [sam for sam in sam_three_list\n                              if (sam.chromosome == pj.acceptor_sam.chromosome and \n                                  abs(pj.acceptor_sam.start-sam.start) < radius)]\n            \"\"\"\n\n            # Get the best 5' and 3' pair of Sams\n            prev_consensus = pj.consensus\n            # best_five,best_three = get_best_splice(sam_five_list,sam_three_list,prev_consensus,max_mismatches)\n            best_five, best_three = get_multi_best_splice(sam_five_list, sam_three_list, prev_consensus, max_mismatches)\n\n            best_splices[prev_jct_ind] = [best_five, best_three]\n            sam_five_list = []\n            sam_three_list = []\n            prev_jct_ind = min(five_jct_ind, three_jct_ind)\n\n    # Have to push the last jct lists into the shared_dict\n    pj = denovo_junctions[prev_jct_ind]\n    prev_consensus = pj.consensus\n    sam_five_list = [sam for sam in sam_five_list if sam.chromosome == pj.donor_sam.chromosome]\n    sam_three_list = [sam for sam in sam_three_list if sam.chromosome == pj.acceptor_sam.chromosome]\n\n    # best_five,best_three = get_best_splice(sam_five_list,sam_three_list,prev_consensus,max_mismatches)\n    best_five, best_three = get_multi_best_splice(sam_five_list, sam_three_list, prev_consensus, max_mismatches)\n    best_splices[prev_jct_ind] = [best_five, best_three]\n\n    # Close the 5' and 3' sam files\n    five_prime_sam_file.close()\n    three_prime_sam_file.close()\n\n    # Loop through the jcts assigning the splice site info\n    jcts_with_splice = []\n    jcts_without_splice = []\n    for jct_ind in range(len(denovo_junctions)):\n        sys.stdout.flush()\n        jct = denovo_junctions[jct_ind]\n\n        # Use calculted best splice if was previously found and both the\n        # donor and acceptor elements exist\n        if jct_ind in best_splices and all([sam.exists for sam in best_splices[jct_ind]]):\n            donor_sam, acceptor_sam = best_splices[jct_ind]\n\n            # Need to include the donor seq not used in splitting\n            # gets complicated by + and - strand\n            donor_ind = int(donor_sam.read_id.split(\"_ind_\")[1])\n            donor_len = len(donor_sam.seq)\n            up_remaining = jct.consensus[:donor_ind]\n            if donor_sam.strand == \"+\":\n                donor_sam.seq = up_remaining + donor_sam.seq\n                donor_sam.start -= len(up_remaining)\n            elif donor_sam.strand == \"-\":\n                donor_sam.seq = up_remaining + reverse_compliment(donor_sam.seq)\n                donor_sam.stop += len(up_remaining)\n            jct.donor_sam = donor_sam\n\n            # Need to include the acceptor seq not used in splitting\n            # gets complicated by + and - strand\n            acceptor_ind = int(acceptor_sam.read_id.split(\"_ind_\")[1])\n            acceptor_len = len(acceptor_sam.seq)\n            down_remaining = jct.consensus[acceptor_ind + 2 * acceptor_len:]\n            if acceptor_sam.strand == \"+\":\n                acceptor_sam.seq = acceptor_sam.seq + down_remaining\n                acceptor_sam.stop += len(down_remaining) - 1\n            elif acceptor_sam.strand == \"-\":\n                acceptor_sam.seq = reverse_compliment(acceptor_sam.seq) + down_remaining\n                acceptor_sam.start -= len(down_remaining)\n            jct.acceptor_sam = acceptor_sam\n\n            jcts_with_splice.append(jct)\n\n        # If either the donor or acceptor doesn't map (or both), add it to the\n        # jcts_without_splice list instead NOTE this list is currently not used\n        else:\n            jcts_without_splice.append(jct)\n\n    # Choose either the forward or reverse form of the junction that yields\n    # the smaller donor site since this will help collapsing in the next step\n    # (could have chosen larger donor etc, just to flip them all same way)\n\n    write_time(\"Num Jcts w/ splice = \" + str(len(jcts_with_splice)), time.time(), timer_file_path)\n    write_time(\"Num Jcts w/out splice = \" + str(len(jcts_without_splice)), time.time(), timer_file_path)\n\n    small_don_jcts_with_splice = []\n    for jct in jcts_with_splice:\n        if jct.donor_sam.donor() < jct.acceptor_sam.acceptor():\n            small_don_jcts_with_splice.append(jct)\n        else:\n            small_don_jcts_with_splice.append(jct.yield_reverse())\n\n    # Return the jcts w/ and w/out splice separately\n    return small_don_jcts_with_splice, jcts_without_splice\n\n\n#######################\n#   Get Best Splice   #\n#######################\n# This is a helper function for the splice site finder\n# If there are multiple found splice, return the best from the shared sams dict from the two sam lists\ndef get_best_splice(sam_five_list, sam_three_list, consensus, max_mismatches):\n    \"\"\"\n    Goal: given a list of possible splice, return the best one for a junction\n    Arguments:\n        sam_five_list is a list[SAMEntry] for possible 5' cuts\n        sam_three_list is a list[SAMEntry] for possible 3' cuts\n        consensus is a str and the consensus sequence of this junction\n        max_mismatches is the maximum allowed mismatches in total for the 5' and 3' sides\n\n    Returns:\n        a tuple of the (best_5'_sam,best_3'_sam) to then be stored in the junction\n    \"\"\"\n    shared_dict = {}\n    id_dict = {}\n    best_sam_five = SAMEntry()\n    best_sam_five_len = 0\n    best_sam_three = SAMEntry()\n    best_sam_three_len = 0\n\n    # Populate the id_dict to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 5' mapping\n    for sam_five in sam_five_list:\n        id_dict[sam_five.read_id] = sam_five\n        if len(sam_five.seq) > best_sam_five_len:\n            best_sam_five_len = len(sam_five.seq)\n            best_sam_five = sam_five\n\n    # Check the id_dict to see if the 3' has a perfect 5' match\n    # Also keep track of the best (longest) 3' mapping\n    for sam_three in sam_three_list:\n        if len(sam_three.seq) > best_sam_three_len:\n            best_sam_three_len = len(sam_three.seq)\n            best_sam_three = sam_three\n        if sam_three.read_id in id_dict:\n            sam_five = id_dict[sam_three.read_id]\n            shared_dict[sam_three.read_id] = [sam_five, sam_three]\n\n    # Now pick out the best sam's to use\n    # If there is at least one shared perfect splice ind find the one w/ least mismatches\n    # then choose the perfect pair that has the least mismatches\n    if len(shared_dict) > 0:\n        best_key = \"\"\n        min_mismatches = max_mismatches + 1\n        for key in shared_dict:\n            sam1, sam2 = shared_dict[key]\n            num_mismatches = sam1.num_mismatches + sam2.num_mismatches\n            if best_key == \"\" or num_mismatches < min_mismatches:\n                best_key = key\n                min_mismatches = num_mismatches\n        best_five_sam, best_three_sam = shared_dict[best_key]\n        return best_five_sam, best_three_sam\n\n    # Otherwise there is a mapping for the left and right pieces, although there is space in between\n    # NOTE is it possible that the best 5' and 3' seqs have overlap in the middle?\n    else:\n        return best_sam_five, best_sam_three\n\n\n#############################\n#   Get Multi Best Splice   #\n#############################\n# This is a helper function for the splice site finder that takes into account\n# If there are multiple found splice, return the best from the shared sams dict from the two sam lists\ndef get_multi_best_splice(sam_five_list, sam_three_list, consensus, max_mismatches):\n    \"\"\"\n    Goal: given a list of possible splice, return the best one for a junction\n    Arguments:\n        sam_five_list is a list[SAMEntry] for possible 5' cuts\n        sam_three_list is a list[SAMEntry] for possible 3' cuts\n        consensus is a str and the consensus sequence of this junction\n        max_mismatches is the maximum allowed mismatches in total for the 5' and 3' sides\n\n    Returns:\n        a tuple of the (best_5'_sam,best_3'_sam) to then be stored in the junction\n    \"\"\"\n    shared_dict = defaultdict(list)\n    sam_fives = defaultdict(list)\n    sam_threes = defaultdict(list)\n    best_sam_five = SAMEntry()\n    best_sam_five_len = 0\n    best_sam_three = SAMEntry()\n    best_sam_three_len = 0\n\n    # Populate the sam_fives to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 5' mapping\n    for sam_five in sam_five_list:\n        sam_fives[sam_five.read_id].append(sam_five)\n        if len(sam_five.seq) > best_sam_five_len:\n            best_sam_five_len = len(sam_five.seq)\n            best_sam_five = sam_five\n\n    # Populate the sam_threes to find perfectly matched 5' and 3' splices\n    # Also keep track of the best (longest) 3' mapping\n    for sam_three in sam_three_list:\n        sam_threes[sam_three.read_id].append(sam_three)\n        if len(sam_three.seq) > best_sam_three_len:\n            best_sam_three_len = len(sam_three.seq)\n            best_sam_three = sam_three\n\n    # Check the id_dict to see if the 5' has a perfect 3' match\n    # Within the perfect match, if there are multi maps choose the one that is closest together\n    # NOTE the internal loop is O(n^2) but n = 10 right now so not too bad\n    for id_key in sam_fives:\n        if id_key in sam_threes:\n            fives = sam_threes[id_key]\n            threes = sam_threes[id_key]\n\n            # For each split index propose the one where the 5' and 3' are the closest\n            # and put this in the shared_dict\n            best_five = fives[0]\n            best_three = threes[0]\n            for five in fives[1:]:\n                for three in threes[1:]:\n                    # If the current best are on different chroms\n                    if best_five.chromosome != best_three.chromosome:\n                        if five.chromosome == three.chromosome:\n                            best_five = five\n                            best_three = three\n\n                    # If the current best are on the same chroms\n                    else:\n                        if five.chromosome == three.chromosome:\n                            if abs(five.start - three.start) < abs(best_five.start - best_three.start):\n                                best_five = five\n                                best_three = three\n\n            shared_dict[id_key] = [best_five, best_three]\n\n    # Now pick out the best sam's to use\n    # If there is at least one shared perfect splice ind find the one w/ least mismatches\n    # then choose the perfect pair that has the least mismatches\n    if len(shared_dict) > 0:\n        best_key = \"\"\n        min_mismatches = max_mismatches + 1\n        for key in shared_dict:\n            sam1, sam2 = shared_dict[key]\n            num_mismatches = sam1.num_mismatches + sam2.num_mismatches\n            if best_key == \"\" or num_mismatches < min_mismatches:\n                best_key = key\n                min_mismatches = num_mismatches\n        best_five_sam, best_three_sam = shared_dict[best_key]\n        return best_five_sam, best_three_sam\n\n    # Otherwise there is a mapping for the left and right pieces, although there is space in between\n    # NOTE is it possible that the best 5' and 3' seqs have overlap in the middle?\n    else:\n        return best_sam_five, best_sam_three\n\n\n##########################\n#   Filter Map Quality   #\n##########################\n# Function to take in Junctions after Splice Ind finding and map pieces right around ind\n# to filter out degenerate or multiple mapping pieces. Currently uses a hard threshold\ndef filter_map_quality(jcts, constants_dict):\n    \"\"\"\n    Goal: Map left and right 25-mers of splice ind and filter out jcts by mapping score\n    Arguments:\n        jcts is a list of type Junction\n        constants dict has all the constants used in the program\n\n    Returns:\n        (pass_jcts,fail_jcts, anom_jcts) is a tuple of \n            (1) list of type Junction of jcts that passed\n            (2) list of type Junction of jcts that failed\n            (3) list of type Junction of jcts that had some other error\n    \"\"\"\n\n    # Add map qualities and only keep those above the cutoff\n    mq_cutoff = constants_dict[\"mq_cutoff\"]\n    mq_len = constants_dict[\"mq_len\"]\n\n    # mqmallg=unique(mallg[(!is.na(match( paste(mallg$junction),paste(mq[mq3+mq5>lower.mq]$junction))))])\n\n    # Write out temp fasta for Bowtie2 calls\n    temp_fasta_name = os.path.join(constants_dict[\"output_dir\"], \"mapq_temp.fasta\")\n    with open(temp_fasta_name, \"w\") as temp_fasta:\n        for ind, jct in enumerate(jcts):\n            seq = jct.consensus\n            don_seq = seq[:jct.splice_ind()][-mq_len:]  # Get the last mq_len bases before splice\n            acc_seq = seq[jct.splice_ind():][:mq_len]  # Get the first mq_len bases after splice\n            temp_fasta.write(\">jct_\" + str(ind) + \"_don\" + \"\\n\" + don_seq + \"\\n\")\n            temp_fasta.write(\">jct_\" + str(ind) + \"_acc\" + \"\\n\" + acc_seq + \"\\n\")\n\n    # Get bowtie2 parameter constants\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n    use_prior = constants_dict[\"use_prior\"]\n    timer_file_path = constants_dict[\"timer_file_path\"]\n    mq_mapped_name = os.path.join(constants_dict[\"output_dir\"], \"mapq_mapped.sam\")\n\n    # Call bowtie2 to get map qualities\n    with open(mq_mapped_name, \"w\") as mq_mapped:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n             \"-x\", reference, temp_fasta_name], stdout=mq_mapped)\n\n    # Go through the mapped output file\n    pass_jcts = []\n    fail_jcts = []\n    anom_jcts = []\n    with open(mq_mapped_name, \"r\") as mq_mapped:\n        sam_line = mq_mapped.readline()\n\n        while sam_line:\n            # Skip header lines\n            if \"@\" in sam_line:\n                sam_line = mq_mapped.readline()\n                continue\n\n            # Get sam entry 1\n            sam_entry_1 = SAMEntry(sam_line)\n            x, jct_ind_1, don = sam_entry_1.read_id.split(\"_\")\n            jct_ind_1 = int(jct_ind_1)\n\n            # Get sam entry 2\n            sam_line = mq_mapped.readline()\n            sam_entry_2 = SAMEntry(sam_line)\n            if not sam_line:\n                anom_jcts.append(jcts[jct_ind_1])\n                continue\n            x, jct_ind_2, acc = sam_entry_2.read_id.split(\"_\")\n            jct_ind_2 = int(jct_ind_2)\n\n            # Check for different anomalous cases where a don/acc doesn't appear in output\n            # If any anomally is hit we start w/ sam_entry_2 next loop, don't advance\n            if don != \"don\" or acc != \"acc\" or jct_ind_1 != jct_ind_2:\n                anom_jcts.append(jcts[jct_ind_1])\n                continue\n\n            # Otherwise if they are don/acc from the same jct check if they passed mq_cutoff\n            jct_mapq = sam_entry_1.mapping_quality + sam_entry_2.mapping_quality\n            jcts[jct_ind_1].mapq = jct_mapq\n            if jct_mapq > mq_cutoff:\n                pass_jcts.append(jcts[jct_ind_1])\n            else:\n                fail_jcts.append(jcts[jct_ind_1])\n\n            # Move on to the next line\n            sam_line = mq_mapped.readline()\n\n    # Return the passed, failed, and anomalous jcts\n    return (pass_jcts, fail_jcts, anom_jcts)\n\n\n#####################\n#   Generate GTFS   #\n#####################\n# Helper function to generate a list of gtf objects from a gtf path full of gtf files\ndef generate_gtfs(gtf_path, allowed_feature_types=[\"exon\"]):\n    \"\"\"\n    Goal: open all the gtf_files and put all gtf objects in a list from the given path\n    Arguments:\n        gtf_file_name is the full path to the gtf files\n        allowed_feature_types is a list of string specifiying which feature types to add (default 'exon' only)\n\n    Returns:\n        gtfs is a list[GTFEntry]\n    \"\"\"\n    gtfs = []\n    gtf_file_names = [gtf_name for gtf_name in os.listdir(gtf_path) if \"gtf\" in gtf_name]\n    for gtf_file_name in gtf_file_names:\n        abs_gtf_file_path = os.path.join(gtf_path, gtf_file_name)\n        # sys.stdout.write(\"Reading in GTF file \"+abs_gtf_file_path+\"\\n\")\n        with open(abs_gtf_file_path, \"r\") as gtf_file:\n            for gtf_line in gtf_file.readlines():\n                # RB 6/6/17: Try to skip common header lines to avoid parsing error\n                if gtf_line[0] == '#' or gtf_line[0] == '@':\n                    continue\n                gtf = GTFEntry(gtf_line)\n                if gtf.feature in allowed_feature_types:\n                    gtfs.append(gtf)\n\n    sys.stdout.write('Len GTFs: ' + str(len(gtfs)) + '\\n')\n    return gtfs\n\n\n########################\n#   Get JCT GTF info   #\n########################\ndef get_jct_gtf_info(junctions, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs):\n    \"\"\"\n    Goal: for each junction find the closest gtf for donor and acceptor\n    Arguments:\n        junctions is a list[Junction]\n        gtfs is a list[GTF]\n\n    Returns:\n        nothing (just updates the junction objects as pass-by-reference)\n    \"\"\"\n    # Separate the gtfs by chromosome into a dictionary\n\n\n    for junction in junctions:\n        closest_results = find_closest_gtf(junction, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs)\n        if closest_results[\"donor\"] and not junction.best_don_list and not junction.rev_best_don_list:\n            junction.donor_sam.gtf = closest_results[\"donor\"]\n        elif closest_results[\"donor\"] and not junction.rev_best_don_list:\n            for index in range(len(closest_results[\"donor\"])):\n                junction.best_don_list[index].gtf = closest_results[\"donor\"][index]\n        elif closest_results[\"donor\"] and not junction.best_don_list:\n            for index in range(len(closest_results[\"donor\"])):\n                junction.rev_best_don_list[index].gtf = closest_results[\"donor\"][index]\n\n        if closest_results[\"acceptor\"] and not junction.best_acc_list and not junction.rev_best_acc_list:\n            junction.acceptor_sam.gtf = closest_results[\"acceptor\"]\n        elif closest_results[\"acceptor\"] and not junction.rev_best_acc_list:\n            for index in range(len(closest_results[\"acceptor\"])):\n                junction.best_acc_list[index].gtf = closest_results[\"acceptor\"][index]\n        elif closest_results[\"acceptor\"] and not junction.best_acc_list:\n            for index in range(len(closest_results[\"acceptor\"])):\n                junction.rev_best_acc_list[index].gtf = closest_results[\"acceptor\"][index]\n\n\n#################################\n#        Find Closest GTF       #\n#################################\ndef find_closest_gtf(jct, chrom_gtfs_don, chrom_gtfs_acc, chrom_don_libs, chrom_acc_libs):\n    \"\"\"\n    Goal: make it easier to call find closest gtf of donor and acceptor w/out code duplication\n    Arguments:\n        takes in a single junction\n        takes in chrom_gtfs_don which is a dict[\"chrom\":list[GTFEntry]] sorted by donor\n        takes in chrom_gtfs_acc which is a dict[\"chrom\":list[GTFEntry]] sorted by acceptor\n\n    Returns:\n        closest_results which is a dictionary keyed by\n        -> closest_results[\"donor\"] -> GTFEntry\n        -> closest_results[\"acceptor\"] -> GTFEntry\n    \"\"\"\n    closest_results = {\"donor\": None, \"acceptor\": None}\n\n    # Find the closest donor sam gtf\n    if jct.donor_sam.exists and not jct.best_don_list and not jct.rev_best_don_list:\n        query = jct.donor_sam.donor()\n        chrom = jct.donor_sam.chromosome\n        chrom_key = chrom + jct.donor_sam.strand\n        if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(chrom_don_libs[chrom_key])>0 and len(chrom_gtfs_don[chrom_key])>0:\n            gtfs_don = chrom_gtfs_don[chrom_key]\n            don_lib = chrom_don_libs[chrom_key]\n            # closest_don_ind,its = bin_search_gtf(query,don_lib)\n\n            closest_don_ind = brute_search_gtf(query, don_lib)  # <-- RB trying brute force\n            closest_results[\"donor\"] = gtfs_don[closest_don_ind]\n\n    elif jct.donor_sam.exists and not jct.rev_best_don_list:\n        closest_results[\"donor\"] = []\n        for index in range(len(jct.best_don_list)):\n            query = jct.best_don_list[index].donor()\n            chrom = jct.best_don_list[index].chromosome\n            chrom_key = chrom + jct.best_don_list[index].strand\n            if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(chrom_don_libs[chrom_key]) > 0 and len(\n                    chrom_gtfs_don[chrom_key]) > 0:\n                gtfs_don = chrom_gtfs_don[chrom_key]\n                don_lib = chrom_don_libs[chrom_key]\n                closest_don_ind = brute_search_gtf(query, don_lib)\n                closest_results[\"donor\"].append(gtfs_don[closest_don_ind])\n\n    elif jct.donor_sam.exists and not jct.best_don_list:\n        closest_results[\"donor\"] = []\n        for index in range(len(jct.rev_best_don_list)):\n            query = jct.rev_best_don_list[index].donor()\n            chrom = jct.rev_best_don_list[index].chromosome\n            chrom_key = chrom + jct.rev_best_don_list[index].strand\n            if chrom_key in chrom_gtfs_don and chrom_key in chrom_don_libs and len(\n                    chrom_don_libs[chrom_key]) > 0 and len(\n                    chrom_gtfs_don[chrom_key]) > 0:\n                gtfs_don = chrom_gtfs_don[chrom_key]\n                don_lib = chrom_don_libs[chrom_key]\n                closest_don_ind = brute_search_gtf(query, don_lib)\n                closest_results[\"donor\"].append(gtfs_don[closest_don_ind])\n\n    # Find the closest acceptor sam gtf\n    if jct.acceptor_sam.exists and not jct.best_acc_list and not jct.rev_best_acc_list:\n        query = jct.acceptor_sam.acceptor()\n        chrom = jct.acceptor_sam.chromosome\n        chrom_key = chrom + jct.acceptor_sam.strand\n        if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(chrom_gtfs_acc[chrom_key])>0 and len(chrom_acc_libs[chrom_key])>0:\n            gtfs_acc = chrom_gtfs_acc[chrom_key]\n            acc_lib = chrom_acc_libs[chrom_key]\n            # closest_acc_ind,its = bin_search_gtf(query,acc_lib)\n            closest_acc_ind = brute_search_gtf(query, acc_lib)  # <-- RB trying brute force\n            closest_results[\"acceptor\"] = gtfs_acc[closest_acc_ind]\n    elif jct.acceptor_sam.exists and not jct.rev_best_acc_list:\n        closest_results[\"acceptor\"] = []\n        for index in range(len(jct.best_acc_list)):\n            query = jct.best_acc_list[index].acceptor()\n            chrom = jct.best_acc_list[index].chromosome\n            chrom_key = chrom + jct.best_acc_list[index].strand\n            if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(\n                    chrom_gtfs_acc[chrom_key]) > 0 and len(chrom_acc_libs[chrom_key]) > 0:\n                gtfs_acc = chrom_gtfs_acc[chrom_key]\n                acc_lib = chrom_acc_libs[chrom_key]\n                closest_acc_ind = brute_search_gtf(query, acc_lib)\n                closest_results[\"acceptor\"].append(gtfs_acc[closest_acc_ind])\n\n    elif jct.acceptor_sam.exists and not jct.best_acc_list:\n        closest_results[\"acceptor\"] = []\n        for index in range(len(jct.rev_best_acc_list)):\n            query = jct.rev_best_acc_list[index].acceptor()\n            chrom = jct.rev_best_acc_list[index].chromosome\n            chrom_key = chrom + jct.rev_best_acc_list[index].strand\n            if chrom_key in chrom_gtfs_acc and chrom_key in chrom_acc_libs and len(\n                    chrom_gtfs_acc[chrom_key]) > 0 and len(chrom_acc_libs[chrom_key]) > 0:\n                gtfs_acc = chrom_gtfs_acc[chrom_key]\n                acc_lib = chrom_acc_libs[chrom_key]\n                closest_acc_ind = brute_search_gtf(query, acc_lib)\n                closest_results[\"acceptor\"].append(gtfs_acc[closest_acc_ind])\n\n    return closest_results\n\n\n#################################\n#    Binary Search Closest GTF  #\n#################################\n# Recursive binary search function\n# NOTE this could probably be sped up using bisectleft, but I doubt by much\ndef bin_search_gtf(query, library, start_ind=0, end_ind=-1, its=1, disp=False):\n    \"\"\"\n    Goal: do a binary search through the library for the closest ind\n    Arguments:\n        query is an int\n        library is a list[int] of genomic positions to look through\n        start_ind is defaulted to 0 and keeps track of where to look\n        end_ind is defaulted to -1 and keeps track of where to look\n\n    Returns:\n        the index of the closest matching library value to the query\n    \"\"\"\n    # First iteration\n    if its == 1 and end_ind == -1:\n        end_ind = len(library) - 1\n\n    # Base case\n    if end_ind - start_ind <= 1:\n        sys.stdout.flush()\n        start_dist = abs(query - library[start_ind])\n        end_dist = abs(library[end_ind] - query)\n        ret_ind = start_ind if start_dist <= end_dist else end_ind\n        if disp:\n            sys.stdout.write(str(its) + \")\" + \" Found closest to:[\" + library[ret_ind] + \"]\\n\")\n        return ret_ind, its\n    # Recursive case\n    else:\n        mid_ind = (start_ind + end_ind) / 2\n        # Determine whether or not to print this line\n        # (almost never want to except when debugging)\n        if disp:\n            print str(its) + \")\", library[start_ind], \"--\", library[mid_ind], \"--\", library[end_ind]\n\n        # Check to see how to recurse\n        if query < library[mid_ind]:\n            return bin_search_gtf(query, library, start_ind, mid_ind, its + 1, disp=disp)\n        else:\n            return bin_search_gtf(query, library, mid_ind, end_ind, its + 1, disp=disp)\n\n            #####################################\n\n\n# Brute Force Closest GTF        #\n#####################################\ndef brute_search_gtf(query, library):\n    \"\"\"\n    Goal: do brute search through the library for the closest ind\n    Arguments:\n        query is an int\n        library is a list[int] of genomic positions to look through\n\n    Returns:\n        the index of the closest matching library value to the query\n    \"\"\"\n\n    closest_ind = 0\n    closest_dist = abs(library[0] - query)\n    for ind, val in enumerate(library[1:]):\n        if abs(val - query) < closest_dist:\n            closest_ind = ind + 1  # <-- have to add 1 since skipping first ind\n            closest_dist = abs(val - query)\n\n    return closest_ind\n\n\n#####################################\n#         Identify Fusions          #\n#####################################\n# Takes junctions that already have gtf info\n# If a junction has the following properties call it a 'fusion':\n#   IF donor and acceptor sams are at_boundary:\n#       IF donor and acceptor are on different chromosomes\n#           [yes fusion]\n#       ELIF donor and acceptor are on different strands\n#       ELIF distance between donor and acceptor > threshold\n#           [yes fusion]\n#       ELSE\n#           [no fusion]\n#   ELSE:\n#       [no fusion]\n#\n# Returns a list of junctions that are deemed 'fusions'\ndef identify_fusions(junctions):\n    \"\"\"\n    Goal: take the junctions and find the ones that could be fusions\n    Arguments:\n        junctions is a list[Junction] objects\n        span_cutoff is an optional int or float defining min distance for a fusion\n            on the same chromosome\n    Returns:\n        fusion_jcts as a list[Junction] with the junctions defined as fusions\n    \"\"\"\n    #span_cutoff = constants_dict[\"span_cutoff\"]\n    fusion_jcts = []\n    for jct in junctions:\n        fusion_type = jct.get_fusion_type()\n        if \"fusion\" in fusion_type and \"no_fusion\" not in fusion_type:\n            fusion_jcts.append(jct)\n    return fusion_jcts\n\n\n####################\n#   Assign Class   #\n####################\n# Assigns a pair of R1 and R2 to a class based on certain factors. These are both SAMEntry objects.\n# Possible classes. R1 always maps to a denovo jct, and R2 somewhere else.\n# NOTE I currently have no confidence that this function works\n# TODO update the logic to allow 'Fusion' classification\n# TODO use regex to parse the chromosome rather than all this messy splitting (it looks terrible)\n# [1] Linear\n# [2] Linear Anomally\n# [3] Circular\n# [4] Circular Anomally\n# [5] None <-- kind of in the place of fusions for now\ndef assign_class(sam_R1, sam_R2):\n    \"\"\"\n    Goal: take the donor and acceptor sam and categorize them\n    Arguments:\n        sam_R1 is of type SAMEntry\n        sam_R2 is of type SAMEntry\n\n    Returns:\n        a string of the generated type\n    \"\"\"\n    jct_chrom_1 = sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[1]\n    jct_chrom_2 = sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[0]\n\n    # If the jct splices 2 chromosomes together just skip it for now\n    if jct_chrom_1 != jct_chrom_2:\n        return \"None\"\n    # If the R1 and R2 are on different chromosomes just skip it for now\n    if jct_chrom_1 != sam_R2.chromosome:\n        return \"None\"\n\n    span = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[5].split(\":\")[1])\n\n    # Linear case\n    if span > 0:\n        if sam_R1.strand != sam_R2.strand:\n            return \"Linear\"\n        else:\n            return \"Linear_Anomaly\"\n\n    # Circular case\n    else:\n        start_1 = int(sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[3].split(\":\")[1])\n        stop_1 = int(sam_R1.chromosome.split(\"|_|\")[0].split(\"|\")[4].split(\":\")[1])\n        start_2 = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[2].split(\":\")[1])\n        stop_2 = int(sam_R1.chromosome.split(\"|_|\")[1].split(\"|\")[3].split(\":\")[1])\n        if sam_R1.strand == sam_R2.strand:\n            return \"Circular_Anomaly\"\n        elif start_2 <= sam_R2.start <= stop_1:\n            return \"Circular\"\n        else:\n            return \"Circular_Anomaly\"\n\n\n############################\n#   Write GLM Class File   #\n############################\n# Simple function to print out GLM class file in the right format\n# NOTE I don't think this function currently works\ndef write_glm_class_file(class_file_name, sam_list):\n    \"\"\"\n    Goal: print out a class file for the GLM\n    Arguments:\n        class_file_name is the name of the save file for the GLM\n        sam_list is a list[[SAMEntry,SAMEntry,str,list[string],list[string]],...]\n\n    Returns:\n        nothing (just prints to the file instead)\n    \"\"\"\n    header = \"\"\n    header += \"id\\t\"\n    header += \"class\\t\"\n    header += \"pos\\t\"\n    header += \"qual\\t\"\n    header += \"aScore\\t\"\n    header += \"numN\\t\"\n    header += \"readLen\\t\"\n    header += \"junction\\t\"\n    header += \"strand\\t\"\n    header += \"posR2\\t\"\n    header += \"qualR2\\t\"\n    header += \"aScoreR2\\t\"\n    header += \"numNR2\\t\"\n    header += \"readLenR2\\t\"\n    header += \"junctionR2\\t\"\n    header += \"strandR2\\n\"\n    with open(class_file_name, \"w\") as class_file:\n        class_file.write(header)\n        for read_pair in sam_list:\n            sam_R1, sam_R2, pair_class, sam_R1_genes, sam_R2_genes = read_pair\n\n            # Add general info to the out_line\n            out_line = \"\"\n            out_line += str(sam_R1.read_id.split(\"/\")[0]) + \"\\t\"\n            out_line += str(pair_class) + \"\\t\"\n\n            # Add R1 info to the out_line\n            out_line += str(sam_R1.start) + \"\\t\"\n            out_line += str(sam_R1.mapping_quality) + \"\\t\"\n            out_line += str(sam_R1.alignment_score) + \"\\t\"\n            out_line += str(sam_R1.num_Ns) + \"\\t\"\n            out_line += str(len(sam_R1.seq)) + \"\\t\"\n            out_line += str(sam_R1.junction()) + \"|\" + sam_R1_genes + \"\\t\"\n            out_line += str(sam_R1.strand) + \"\\t\"\n\n            # Add R2 info to the out_line\n            out_line += str(sam_R2.start) + \"\\t\"\n            out_line += str(sam_R2.mapping_quality) + \"\\t\"\n            out_line += str(sam_R2.alignment_score) + \"\\t\"\n            out_line += str(sam_R2.num_Ns) + \"\\t\"\n            out_line += str(len(sam_R2.seq)) + \"\\t\"\n            out_line += str(sam_R2.junction()) + \"|\" + sam_R2_genes + \"\\t\"\n            out_line += str(sam_R2.strand) + \"\\n\"\n\n            # Write the built up out_line to the glm input class file\n            class_file.write(out_line)\n\n\n##################\n#   Write Time   #\n##################\n# Helper function to write out the timing of something\n# Takes in the message, a start time in seconds, and a timer_file_path\n# Appends to the timer file by default, first call should overwrite\ndef write_time(message, start_time, timer_file_path, append=True, uniform_len=70):\n    \"\"\"\n    Goal: write a timed event out to a file\n    Arguments:\n        message is the text of the job to put next to the time (i.e. 'Time to align reads')\n        start_time is the start of the job gotten by time.time()\n        time_file_path is the full path to the timer store file\n        append is a boolean saying whether or not to append to the file vs. overwriting (default append)\n        uniform_len is the max message length to allow aligning the timer output file\n\n    Returns:\n        nothing (just writes to the timer file)\n    \"\"\"\n    seconds_duration = float(time.time() - start_time)\n    minutes_duration = seconds_duration / 60\n    hours_duration = seconds_duration / 3600\n    seconds_str = (\"{:3.2f}\".format(seconds_duration)).rjust(5, \" \")\n    minutes_str = (\"{:3.2f}\".format(minutes_duration)).rjust(5, \" \")\n    hours_str = (\"{:3.2f}\".format(hours_duration)).rjust(5, \" \")\n\n    if len(message) < uniform_len:\n        message += \" \" * (uniform_len - len(message))\n    else:\n        message = message[:uniform_len]\n    time_out_str = message + \":    \"\n    time_out_str += seconds_str + \":seconds    \"\n    time_out_str += minutes_str + \":minutes    \"\n    time_out_str += hours_str + \":hours\\n\"\n    timer_file = open(timer_file_path, \"a\") if append else open(timer_file_path, \"w\")\n    timer_file.write(time_out_str)\n    timer_file.close()\n\n\n##########################\n#   Collapse Junctions   #\n##########################\ndef collapse_junctions(jcts, collapse_thresh, group_out_file_name=None):\n    \"\"\"\n    Goal: take in the junctions and collapse ones at or near the same\n          splice sites\n    Arguments:\n        junctions is a list[Junction] object\n        full_path_name points to the the combined fastq file\n        constants dict is a dictionary of global constants\n\n    Returns:\n        a tuple with the first element as the singles \"uncollapsed list\"\n        and the second being the collapsed list of junctions list[Junction]\n    \"\"\"\n    # Get the collapsing threshold (radius of donor and acceptor to collapse in)\n    #collapse_thresh = constants_dict[\"collapse_thresh\"]\n\n    # Separate the jcts by chromosome pairs to make later O(N^2) less painful\n    # so will have one entry for chr1:chr2, chr1:chr3 etc\n    # it will be combinations, not permutations (chr1:chr2 == chr2:chr1)\n    splices_by_chroms = {}\n    for jct in jcts:\n        chrom_1 = \"chr\" + str(jct.donor_sam.chromosome)\n        chrom_2 = \"chr\" + str(jct.acceptor_sam.chromosome)\n        if chrom_1 + chrom_2 in splices_by_chroms:\n            splices_by_chroms[chrom_1 + chrom_2].append(jct)\n        #elif chrom_2 + chrom_1 in splices_by_chroms:\n        #    splices_by_chroms[chrom_2 + chrom_1].append(jct)\n        else:\n            splices_by_chroms[chrom_1 + chrom_2] = [jct]\n\n    groupings = {}\n    for chroms in splices_by_chroms:\n        groupings[chroms] = []\n        for jct in splices_by_chroms[chroms]:\n            don = jct.donor_sam.donor()\n            acc = jct.acceptor_sam.acceptor()\n            found_prev_group = False\n\n            # Only compare jct to other jcts if both\n            # don and acc are not None\n            if don and acc:\n                for prev_group in groupings[chroms]:\n                    for prev_jct in prev_group:\n                        prev_don = prev_jct.donor_sam.donor()\n                        prev_acc = prev_jct.acceptor_sam.acceptor()\n                        # If any one of the acceptor/donors are None\n                        if not prev_don or not prev_acc:\n                            continue\n                        if abs(don - prev_don) <= collapse_thresh and abs(acc - prev_acc) <= collapse_thresh:\n                            # sys.stderr.write(\"Found match for:\\n\")\n                            # sys.stderr.write(jct.verbose_fasta_string())\n                            prev_group.append(jct)\n                            found_prev_group = True\n                            break\n\n                    # If found a prev_group, don't need to look through\n                    # other prev groups\n                    if found_prev_group:\n                        break\n\n            # If it didn't find any of the prev_groups, start a new group\n            if not found_prev_group:\n                groupings[chroms].append([jct])\n\n    # Separate singles from groups\n    singles = []\n    groups = []\n    group_out_file = None\n    if group_out_file_name:\n        group_out_file = open(group_out_file_name, \"w\")\n\n    for chroms in groupings:\n        for group in groupings[chroms]:\n            if len(group) <= 1:\n                singles += group\n            else:\n                if group_out_file_name:\n                    group_out_file.write(\"Group info:\\n\")\n                    group_out_file.write(\"\".join([m.verbose_fasta_string() for m in group]) + \"\\n\")\n                counts = [len(member.bin_pair_group) for member in group]\n                max_ind = counts.index(max(counts))\n                repr_jct = group[max_ind]\n                repr_jct.collapsed_num = sum(counts)\n                groups.append(repr_jct)\n\n    if group_out_file_name:\n        group_out_file.close()\n\n\n    return singles, groups\n\n\n########################\n#   Badfj3 fusions     #\n########################\ndef badfj3_fusions(junctions, constants_dict):\n    # Bowtie params\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n\n    # Build up file stems\n    badfj3_stem = os.path.join(constants_dict[\"output_dir\"], \"badfj3_\")\n    don_fasta = badfj3_stem + \"don.fasta\"\n    acc_fasta = badfj3_stem + \"acc.fasta\"\n    badfj3_mapped = badfj3_stem + \"mapped.sam\"\n\n    # Open the R1 and R2\n    don_fasta_f = open(don_fasta, \"w\")\n    acc_fasta_f = open(acc_fasta, \"w\")\n\n    # Build up the \"paired end\" files\n    jct_dict = {}\n    for jct in junctions:\n        jct_dict[jct.jct_ind] = jct\n        header = \">\" + str(jct.jct_ind)\n        break_point = jct.splice_ind()\n        don = jct.consensus[:break_point]\n        acc = jct.consensus[break_point:]\n\n        # RB: 5/26/17 Change this to map just the first and last 20 bases\n        # don_fasta_f.write(header+\"\\n\"+don+\"\\n\")\n        # acc_fasta_f.write(header+\"\\n\"+acc+\"\\n\")\n        don_fasta_f.write(header + \"\\n\" + don[:20] + \"\\n\")\n        acc_fasta_f.write(header + \"\\n\" + acc[-20:] + \"\\n\")\n\n    # Close the R1 and R2 fastqs\n    don_fasta_f.close()\n    acc_fasta_f.close()\n\n    badfj3_gap = \"500000\"  # If the don/acc can map within 1/2 Mb, then jct not fusion\n\n    # Run bowtie2 on the R1 and R2\n    with open(badfj3_mapped, \"w\") as badfj3_mapped_f:\n        subprocess.call([\n            \"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", \"--no-mixed\", \"--no-hd\",\n            min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n            \"-x\", reference, \"-X\", badfj3_gap, \"--ff\", \"-1\",\n            don_fasta, \"-2\", acc_fasta\n        ],\n            stdout=badfj3_mapped_f)\n\n    # Read back the sam file\n    flags = [\"paired\", \"proper\", \"no_align\", \"paired_no_align\", \"minus\", \"mate_minus\", \"R1\", \"R2\"]\n    seen_jct_inds = []\n    with open(badfj3_mapped, \"r\") as badfj3_mapped_f:\n        for line in badfj3_mapped_f:\n            # NOTE this is a sloppy way of parsing a PE SAM file (should use samtools view)\n            split_line = line.split('\\t')\n            jct_ind = int(split_line[0])\n            flag = int(split_line[1])\n\n            # Does sloppy binary flag parsing\n            jct_flags = {flags[ind]: bool(int(bit)) for ind, bit in enumerate(format(flag, \"08b\"))}\n\n            # If it didn't align, then just skip it, it can't be a badfj3\n            if jct_flags[\"no_align\"] or jct_flags[\"paired_no_align\"]:\n                continue\n            # If it did align AND it has already been seen this is a badfj3\n            elif jct_ind in seen_jct_inds:\n                jct_dict[jct_ind].badfj3 = True\n            # If it did align but has not already been seen put it in the see_jct_inds\n            else:\n                seen_jct_inds.append(jct_ind)\n\n    return junctions\n\n\n############################\n#   Old Badfj3 fusions     #\n############################\n\"\"\"\ndef badfj3_fusions(fusion_junctions,constants_dict):\n\n    #Bowtie params\n    min_score = constants_dict[\"splice_finding_min_score\"]\n    read_gap_score = constants_dict[\"read_gap_score\"]\n    ref_gap_score = constants_dict[\"ref_gap_score\"]\n    num_threads = constants_dict[\"num_threads\"]\n    reference = constants_dict[\"reference\"]\n\n    #Build up file stems\n    badfj3_stem = os.path.join(constants_dict[\"output_dir\"],\"badfj3_\")\n    don_fasta = badfj3_stem+\"don.fasta\"\n    acc_fasta = badfj3_stem+\"acc.fasta\"\n    badfj3_mapped = badfj3_stem+\"mapped.sam\"\n\n    #Open the R1 and R2\n    don_fasta_f = open(don_fasta,\"w\")\n    acc_fasta_f = open(acc_fasta,\"w\")\n\n    #Build up the \"paired end\" files\n    for fusion in fusion_junctions:\n        header = \">\"+str(fusion.jct_ind)+\"\\n\"\n        break_point = fusion.splice_ind()\n        don = fusion.consensus[:break_point]\n        acc = fusion.consensus[break_point:]\n        don_fasta_f.write(header+don+\"\\n\")\n        acc_fasta_f.write(header+acc+\"\\n\")\n\n    #Close the R1 and R2\n    don_fasta_f.close()\n    acc_fasta_f.close()\n\n    badfj3_gap = \"500000\" #If the don/acc can map within 1/2 Mb, then jct not fusion\n\n    #Run bowtie2 on the R1 and R2\n    with open(badfj3_mapped,\"w\") as badfj3_mapped_f:\n        subprocess.call(\n            [\"bowtie2\", \"-f\", \"--no-sq\", \"--no-unal\", min_score, read_gap_score, ref_gap_score, \"-p\", num_threads,\n             \"-x\", reference, \"-X\", badfj3_gap, \"--ff\", \"-1\", don_fasta, \"-2\", acc_fasta], stdout=badfj3_mapped_f)\n\n\n    still_fusions = []\n    now_jcts = []\n\n    #Read back the sam file\n    with open(badfj3_mapped,\"r\") as badfj3_mapped_f:\n        for line in badfj3_mapped_f:\n            print line #NOTE!!! need to see how PE output looks\n\n    return still_fusions,now_jcts\n\"\"\"\n\n\n##########################\n#   Reverse Compliment   #\n##########################\n# Just a little helper function to give the reverse compliment of a sequence\ndef reverse_compliment(seq):\n    \"\"\"\n    Goal: take a sequence and return the reverse compliment\n    Arguments:\n        seq is a string of A's,T's,C's,G's, and N's\n\n    Returns:\n        the reverse compliment string\n    \"\"\"\n    comp_dict = {\"A\": \"T\",\n                 \"a\": \"t\",\n                 \"T\": \"A\",\n                 \"t\": \"a\",\n                 \"C\": \"G\",\n                 \"c\": \"g\",\n                 \"G\": \"C\",\n                 \"g\": \"c\",\n                 \"N\": \"N\",\n                 \"n\": \"n\"}\n\n    rev_comp_seq = \"\".join([comp_dict[base] for base in seq])[::-1]\n    return rev_comp_seq\n\n\n################################################################\n#   Print out the constants dict for better version tracking   #\n################################################################\ndef write_constants_dict(constants_dict, params_out_name):\n    \"\"\"\n    Goal: print out the constants dict to inform what parameters were used on the run\n    Arguments:\n        constants_dict is a dict keyed by string and valued by numeric or string\n        params_out_name is the file path to store the constants dict info\n    Returns:\n        None, everything is written to the file\n    \"\"\"\n    uniform_len = max([len(str(key)) for key in constants_dict])\n    spaces = \" \" * uniform_len\n\n    with open(params_out_name, \"w\") as params_out:\n        # Header info with date and time\n        params_out.write(\"Parameter file used for SPORK run\\n\")\n        params_out.write(\"\\tDate \" + time.strftime(\"%d/%m/%y\") + \" (day/month/year)\\n\")\n        params_out.write(\"\\tTime \" + time.strftime(\"%H:%M:%S\") + \"\\n\")\n        params_out.write(\"\\nParameters:\\n\")\n        params_out.write(\"-\" * (uniform_len + 4) + \"\\n\")\n\n        # Loop through the parameters printing nicely\n        len_sorted_params = sorted(constants_dict.keys(), key=lambda k: len(k))\n        for param in len_sorted_params:\n            padded_param = param[:uniform_len] + spaces[:uniform_len - len(param)]\n            param_val = str(constants_dict[param])\n            params_out.write(padded_param + \"    :    \" + param_val + \"\\n\")\n\n\n###################################\n#   Track NUP214 as a test case   #\n###################################\ndef follow_nup214(forward_jct, reverse_jct):\n    \"\"\"\n    Goal: check if forward or reverse nup214 makes more sense in terms\n          of donor and acceptor sites\n    Arguments:\n        forward_jct is of type Junction\n        reverse_jct is of type Junction and is the rev-comp of forward_jct\n\n    Returns:\n        nothing, just writes out info to stdout\n    \"\"\"\n    if (forward_jct.donor_sam.str_gene() == \"NUP214\" or\n                forward_jct.acceptor_sam.str_gene() == \"NUP214\" or\n                reverse_jct.donor_sam.str_gene() == \"NUP214\" or\n                reverse_jct.acceptor_sam.str_gene() == \"NUP214\"):\n        sys.stdout.write(\"Found a NUP214\\n\")\n        sys.stdout.write(forward_jct.verbose_fasta_string())\n        sys.stdout.write(str(forward_jct.donor_sam.gtf) + \"\\n\")\n        sys.stdout.write(str(forward_jct.acceptor_sam.gtf) + \"\\n\")\n        sys.stdout.write(reverse_jct.verbose_fasta_string())\n        sys.stdout.write(str(reverse_jct.donor_sam.gtf) + \"\\n\")\n        sys.stdout.write(str(reverse_jct.acceptor_sam.gtf) + \"\\n\")\n        sys.stdout.write(\"Forward dist: \" + str(forward_dist) + \" reverse_dist: \" + str(reverse_dist) + \"\\n\")\n        sys.stdout.write(\"Forward donor gtf span:\" + str(forward_jct.donor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Forward acceptor gtf span:\" + str(forward_jct.acceptor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Reverse donor gtf span:\" + str(reverse_jct.donor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"Reverse acceptor gtf span:\" + str(reverse_jct.acceptor_sam.gtf.span) + \"\\n\")\n        sys.stdout.write(\"\\n\")\n        sys.stdout.flush()\n\n\n###################################\n#   Track NUP214 as a test case   #\n###################################\ndef get_seq_complexity(seq):\n    \"\"\"\n    Goal: take in a string and return the sequence complexity. Makes use of zlib to compress\n          the string and see how much compression occurred. If lots of compression, then seq was low complexity\n\n    Arguments:\n        seq is a sequence (or really any string)\n\n    Return:\n        a float for the string complexity between 0 and 1 (0 is least complex, 1 is most)\n    \"\"\"\n    uncompressed = sys.getsizeof(seq)\n    compressed = sys.getsizeof(zlib.compress(seq))\n    compression = float(compressed) / uncompressed  # 0 is worst, 1 is best (visually making 0.675 cutoff)\n    return compression",
                "filename": "SPORK_utils.py"
              },
              {
                "fileContent": "# Identified junction class\n\n# Imports\nfrom SPORK_SAMEntry import SAMEntry\nimport copy\nimport sys\nimport itertools\nfrom scipy.stats import chisquare\n\n\n# Junction class\nclass Junction(object):\n    __slots__ = [\"consensus\", \"score\", \"bin_pair\", \"bin_pair_group\", \"took_reverse_compliment\", \"constants_dict\",\n                 \"badfj3\", \"donor_sam\", \"acceptor_sam\", \"mapq\", \"jct_ind\", \"best_don_list\", \"best_acc_list\",\n                 \"rev_best_don_list\", \"rev_best_acc_list\", \"is_at_boundary\", \"uniformity_score\", \"collapsed_num\"]\n\n    def __init__(self, consensus, score, bin_pair_group, jct_ind, took_reverse_compliment, constants_dict):\n        \"\"\"\n        Goal: Initialization function of junction\n        Arguments:\n            consensus                -- str\n            score                    -- float\n            bin_pair_group           -- list[bin_pair]\n            took_reverse_coompliment -- bool\n            constants_dict           -- dict[str->multiple types]\n\n        Returns:\n            nothing\n        \"\"\"\n        # Read in arguments\n        self.consensus = consensus\n        self.score = score\n        self.bin_pair_group = bin_pair_group\n        self.jct_ind = jct_ind\n        self.took_reverse_compliment = took_reverse_compliment\n        self.constants_dict = constants_dict\n        self.mapq = 0\n        self.badfj3 = False\n\n        # Find chromosome, bin_pair and strand info from the first mapped read\n        rep_bin_pair = self.bin_pair_group[0]\n        self.bin_pair = rep_bin_pair.bin_pair\n        self.donor_sam = SAMEntry()\n        self.acceptor_sam = SAMEntry()\n\n        # Get some information for the donor sam from the five_prime sam of the bin pair\n        self.donor_sam.chromosome = rep_bin_pair.five_prime_chr\n        self.donor_sam.start = rep_bin_pair.five_prime_SAM.start\n        self.donor_sam.stop = rep_bin_pair.five_prime_SAM.stop\n\n        # Get some information for the acceptor sam from the three_prime sam of the bin pair\n        self.acceptor_sam.chromosome = rep_bin_pair.three_prime_chr\n        self.acceptor_sam.start = rep_bin_pair.three_prime_SAM.start\n        self.acceptor_sam.stop = rep_bin_pair.three_prime_SAM.stop\n\n        self.best_don_list = None\n        self.best_acc_list = None\n        self.rev_best_don_list = None\n        self.rev_best_acc_list = None\n        self.uniformity_score = [-1, 1]\n\n        bin_size = constants_dict[\"bin_size\"]\n        three_prime_loc = [0] * bin_size\n        five_prime_loc = [0] * bin_size\n\n        for bin_pair in bin_pair_group:\n            three_prime_loc[bin_pair.three_prime_SAM.start % bin_size] += 1\n            five_prime_loc[bin_pair.five_prime_SAM.start % bin_size] += 1\n\n        self.uniformity_score = [round(chisquare(three_prime_loc)[1], 5), round(chisquare(five_prime_loc)[1], 5)]\n        self.collapsed_num = 0\n        self.is_at_boundary = False\n\n    # Use the sam's to find the splice index in reference to the concensus\n    def splice_ind(self):\n        \"\"\"\n        Goal: Get the splice site in consensus coordinates [0,len(consensus)-1]\n        Arguments:\n            none\n\n        Returns:\n            the 3' edge of the donor sequence if both sams are defined\n            otherwise returns the middle index of the consensus as a guess\n        \"\"\"\n\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            # NOTE currently doesn't handle gaps well (just returns the donor side index of gap)\n            # comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n            #        \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n            #        \"N\": \"N\", \"n\": \"n\"}\n            acc_seq = self.acceptor_sam.seq\n            # if (self.acceptor_sam.strand == \"-\" and not self.took_reverse_compliment) or (self.acceptor_sam.strand == \"+\" and self.took_reverse_compliment):\n            #    acc_seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n            return self.consensus.find(acc_seq)\n\n        else:\n            return len(self.consensus) / 2\n\n    # Use the sam's again to find the size of the gap between the two pieces\n    def splice_gap(self):\n        \"\"\"\n        Goal: Find the distance between the donor and acceptor splice sites\n              in consensus coordinates [0,len(consensus)-1]\n        Arguments:\n            none\n\n        Returns:\n            the distance between the 3' end of the donor and 5' end of the acceptor\n            if one or both of the sam's are undefined return None\n        \"\"\"\n        # if self.donor_sam.exists and self.acceptor_sam.exists:\n        # RB 5/26/17: Having strange index errors, I think going by lengths is equivalent\n        #    return len(self.consensus) - len(self.donor_sam.seq) - len(self.acceptor_sam.seq)\n\n        # sys.stderr.write(self.consensus+':  '+self.donor_sam.seq+'\\n')\n        # donor_pos = self.consensus.index(self.donor_sam.seq)+len(self.donor_sam.seq)\n        # sys.stderr.write(self.consensus+':  '+self.acceptor_sam.seq+'\\n')\n        # acceptor_pos = self.consensus.index(self.acceptor_sam.seq)\n        # return donor_pos-acceptor_pos\n        # else:\n        #    return None\n        return 0\n\n    # Use the sam's again to find the size of the gap between the two pieces\n    def span(self):\n        \"\"\"\n        Goal: find the genomic span between the sams\n        Arguments:\n            none\n\n        Returns:\n            if both exist subtract the donor and acceptor sites\n            this distance will always be positive\n            if one or both don't exist just return -1\n        \"\"\"\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            span = self.donor_sam.donor() - self.acceptor_sam.acceptor()\n            return abs(span)\n        else:\n            return -1\n\n    # Give a name to the splice type for this junction\n    def splice_type(self):\n        \"\"\"\n        Goal: get the type of splice this junction represents\n        Arguments:\n            none\n\n        Returns:\n            \"Full\" if both sams exist and have zero gaps in the split\n            \"Gapped\" if both sams exist but there is space in the middle\n            \"Five_Only\" if only the donor sam exists\n            \"Three_Only\" if only the acceptor sam exists\n            \"None\" if niether sam exists\n        \"\"\"\n        if self.donor_sam.exists and self.acceptor_sam.exists:\n            if self.splice_gap() == 0:\n                return \"Full\"\n            else:\n                return \"Gapped\"\n        elif self.donor_sam.exists:\n            return \"Five_Only\"\n        elif self.acceptor_sam.exists:\n            return \"Three_Only\"\n        else:\n            return \"None\"\n\n    # Check to see if this jct represents a fusion\n    def get_fusion_type(self, span_cutoff=1e5):\n        \"\"\"\n        Goal: check if this junction represents a fusion\n        Arguments:\n            none\n\n        Returns:\n            bool of whether or not the donor and acceptor have different genes\n            if one or more don't exists then return False\n        \"\"\"\n        anonat = \"\"  # Can be 'bot', 'donor', 'acceptor', or 'none'\n        chroms = \"\"  # Can be 'interchrom', 'distant-intrachrom', or 'local-intrachrom'\n        strand = \"\"  # Can be 'inversion', 'plus', or 'minus'\n        revreg = \"\"  # Can be 'rev', 'reg', or 'invert'\n\n        # Get the anonat type\n        if self.at_boundary(\"donor\") and self.at_boundary(\"acceptor\"):\n            anonat = \"both\"\n        elif self.at_boundary(\"donor\"):\n            anonat = \"donor\"\n        elif self.at_boundary(\"acceptor\"):\n            anonat = \"acceptor\"\n        else:\n            anonat = \"niether\"\n\n        # Get the strand type\n        if self.donor_sam.strand != self.acceptor_sam.strand:\n            strand = \"inversion\"\n        elif self.donor_sam.strand == \"+\":\n            strand = \"plus\"\n        elif self.donor_sam.strand == \"-\":\n            strand = \"minus\"\n\n        # Get the chromosomes type\n        if self.donor_sam.chromosome != self.acceptor_sam.chromosome:\n            chroms = \"interchrom\"\n        elif strand == \"inversion\":\n            chroms = \"inversion-intrachrom\"\n        elif self.span() >= span_cutoff:\n            chroms = \"distant-intrachrom\"\n        else:\n            chroms = \"local-intrachrom\"\n\n        # Get the revreg type\n        if strand == \"inversion\":\n            revreg = \"invert\"\n        elif self.donor_sam.donor() < self.acceptor_sam.acceptor() and self.donor_sam.strand == \"+\":\n            revreg = \"reg\"\n        elif self.donor_sam.donor() > self.acceptor_sam.acceptor() and self.donor_sam.strand == \"-\":\n            revreg = \"reg\"\n        else:\n            revreg = \"rev\"\n\n        # Should this be considered a fusion?\n        fusion = \"no_fusion\"\n\n        if anonat == \"both\":\n            if self.splice_gap() != None and abs(self.splice_gap()) <= self.constants_dict[\"fusion_max_gap\"]:\n                #if chroms != \"local-intrachrom\":\n                #    fusion = \"fusion\"\n                fusion = \"fusion\"\n\n        # Concatenate them into one string\n        fusion_type = fusion + \"-\" + anonat + \"_\" + chroms + \"_\" + strand + \"_\" + revreg\n        return fusion_type\n\n    # Get distance to closest splice boundary\n    def boundary_dist(self, splice_site, bowtie_style=True):\n        \"\"\"\n        Goal: get the distance of the specified splice site from the closest exon\n        Arguments:\n            splice_site which is a string and can be either \"donor\" or \"acceptor\"\n            bowtie_style is an optional boolean argument\n                if True (default), then if a donor/acceptor falls to the 'right' of the gtf-site,\n                regardless of strand, it will be a positive distance\n\n                if False, then the strand does matter, and being 5' of gtf is negative and 3' is positive\n\n\n        Returns:\n            the distance to the closest gtf of the specified splice_site\n            the distance being positive or negative means different things based on the bowtie_style parameter\n            explained above\n        \"\"\"\n        # If donor distance is requested\n        if splice_site == \"donor\" and self.donor_sam.gtf:\n            donor_dist = 0\n            if not bowtie_style:\n                if self.donor_sam.strand == \"+\":\n                    donor_dist = self.donor_sam.donor() - self.donor_sam.gtf.donor\n                elif self.donor_sam.strand == \"-\":\n                    donor_dist = self.donor_sam.gtf.donor - self.donor_sam.donor()\n                else:\n                    sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect strand option \\n\")\n                    sys.exit(1)\n            elif bowtie_style:\n                donor_dist = self.donor_sam.donor() - self.donor_sam.gtf.donor\n\n            return donor_dist\n\n        # If acceptor distance is requested\n        elif splice_site == \"acceptor\" and self.acceptor_sam.gtf:\n            acceptor_dist = 0\n            if not bowtie_style:\n                if self.acceptor_sam.strand == \"+\":\n                    acceptor_dist = self.acceptor_sam.acceptor() - self.acceptor_sam.gtf.acceptor\n                elif self.acceptor_sam.strand == \"-\":\n                    acceptor_dist = self.acceptor_sam.gtf.acceptor - self.acceptor_sam.acceptor()\n                else:\n                    sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect strand option \\n\")\n                    sys.exit(1)\n            elif bowtie_style:\n                acceptor_dist = self.acceptor_sam.acceptor() - self.acceptor_sam.gtf.acceptor\n\n            return acceptor_dist\n\n        # If a different string was passed in or the specified gtf doesn't exist\n        else:\n            sys.stderr.write(str(self) + '\\n')\n            sys.stderr.write(\"SPORK ERROR: in Junction boundary dist, incorrect str or gtf doesn't exist\\n\")\n            sys.exit(1)\n\n    # Return whether or not an donor and acceptor is at a boundary\n    def at_boundary(self, splice_site):\n        \"\"\"\n        Goal: check to see if the specified sam is at an exon boundary\n        Arguments:\n            splice_site of type string. should be \"donor\" or \"acceptor\"\n            to specify which sam to check\n\n            radius is optional and signifies the maximum distance from\n            an exon boundary to consider a sam. Default is 3\n\n        Returns:\n            a boolean of whether or not the specified sam is within\n            'radius' distance of any exon boundary\n        \"\"\"\n        dist = self.boundary_dist(splice_site)\n        if abs(dist) <= self.constants_dict[\"at_boundary_cutoff\"]:\n            return True\n        else:\n            return False\n\n    # Returns whether or not this junction is linear\n    def linear(self):\n        \"\"\"\n        Goal: check to see if this junction in linear\n        Arguments:\n            none\n\n        Returns:\n            a boolean of whether the junction is linear or not\n        \"\"\"\n        five_prime_bin, three_prime_bin, strand_info = self.bin_pair.split(\"_\")\n        five_prime_chr = five_prime_bin.split(\":\")[0]\n        five_prime_bin = five_prime_bin.split(\":\")[1]\n        three_prime_chr = three_prime_bin.split(\":\")[0]\n        three_prime_bin = three_prime_bin.split(\":\")[1]\n        linear = True if int(five_prime_bin) <= int(three_prime_bin) else False\n        # RB 04/25/17: I'm not sure this is correct, took_reverse_compliment is always False\n        linear = not linear if self.took_reverse_compliment else linear\n        return linear\n\n    # Returns this junction and a reverse compliment of this junction\n    # to facilitate finding the gtf's of each and seeing which form is better\n    def yield_forward_and_reverse(self):\n        \"\"\"\n        Goal: return a copy of self and a reverse compliment of self\n        Arguments:\n            none\n\n        Returns:\n            a tuple of Junction where the first entry is self and the\n            second is a reverse compliment of self\n        \"\"\"\n        # sys.stdout.write(\"Before copy in yield_forward_and_reverse\\n\")\n        rev_self = Junction(self.consensus, self.score, self.bin_pair_group, self.jct_ind, self.took_reverse_compliment,\n                            self.constants_dict)\n        # rev_self = copy.deepcopy(self)\n        # sys.stdout.write(\"After copy in yield_forward_and_reverse\\n\")\n        rev_self.took_reverse_compliment = not rev_self.took_reverse_compliment\n\n        comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n                \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n                \"N\": \"N\", \"n\": \"n\"}\n\n        # Take the reverse compliments of the seqs and switch them between donor and acceptor\n        rev_self.consensus = \"\".join([comp[base] for base in self.consensus])[::-1]\n        rev_self.donor_sam.seq = \"\".join([comp[base] for base in self.donor_sam.seq])[::-1]\n        rev_self.acceptor_sam.seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n        rev_self.donor_sam.seq, rev_self.acceptor_sam.seq = rev_self.acceptor_sam.seq, rev_self.donor_sam.seq\n\n        rev_self.donor_sam.strand = \"-\" if self.acceptor_sam.strand == \"+\" else \"+\"\n        rev_self.acceptor_sam.strand = \"-\" if self.donor_sam.strand == \"+\" else \"+\"\n\n        rev_self.donor_sam.start, rev_self.acceptor_sam.start = self.acceptor_sam.start, self.donor_sam.start\n        rev_self.donor_sam.stop, rev_self.acceptor_sam.stop = self.acceptor_sam.stop, self.donor_sam.stop\n\n        rev_self.donor_sam.md, rev_self.acceptor_sam.md = self.acceptor_sam.md, self.donor_sam.md\n\n        rev_self.donor_sam.chromosome, rev_self.acceptor_sam.chromosome = self.acceptor_sam.chromosome, self.donor_sam.chromosome\n        rev_self.donor_sam.exists = True\n        rev_self.acceptor_sam.exists = True\n\n        if self.best_don_list:\n            rev_self.rev_best_don_list = []\n            rev_self.rev_best_acc_list = []\n            for index in range(len(self.best_don_list)):\n                rev_don = copy.deepcopy(self.best_don_list[index])\n                rev_acc = copy.deepcopy(self.best_acc_list[index])\n\n                rev_don.seq = \"\".join([comp[base] for base in self.best_acc_list[index].seq])[::-1]\n                rev_acc.seq = \"\".join([comp[base] for base in self.best_don_list[index].seq])[::-1]\n\n                rev_don.strand = \"-\" if self.best_acc_list[index].strand == \"+\" else \"+\"\n                rev_acc.strand = \"-\" if self.best_don_list[index].strand == \"+\" else \"+\"\n\n                rev_don.md = self.best_acc_list[index].md\n                rev_acc.md = self.best_don_list[index].md\n\n                rev_don.start = self.best_acc_list[index].start\n                rev_acc.start = self.best_don_list[index].start\n\n                rev_don.stop = self.best_acc_list[index].stop\n                rev_acc.stop = self.best_don_list[index].stop\n\n                rev_don.chromosome = self.best_acc_list[index].chromosome\n                rev_acc.chromosome = self.best_don_list[index].chromosome\n\n                rev_self.rev_best_don_list.append(rev_don)\n                rev_self.rev_best_acc_list.append(rev_acc)\n\n        return self, rev_self\n\n    # Returns this junction and a reverse compliment of this junction\n    # to facilitate finding the gtf's of each and seeing which form is better\n    def yield_reverse(self):\n        \"\"\"\n        Goal: return a reversed self\n        Arguments:\n            none\n\n        Returns:\n            a Junction which is the reverse of self (note does change original)\n        \"\"\"\n        self.took_reverse_compliment = not self.took_reverse_compliment\n\n        comp = {\"A\": \"T\", \"a\": \"t\", \"T\": \"A\", \"t\": \"a\",\n                \"G\": \"C\", \"g\": \"c\", \"C\": \"G\", \"c\": \"g\",\n                \"N\": \"N\", \"n\": \"n\"}\n\n        # Take the reverse compliments of the seqs and switch them between donor and acceptor\n        self.consensus = \"\".join([comp[base] for base in self.consensus])[::-1]\n        self.donor_sam.seq = \"\".join([comp[base] for base in self.donor_sam.seq])[::-1]\n        self.acceptor_sam.seq = \"\".join([comp[base] for base in self.acceptor_sam.seq])[::-1]\n        self.donor_sam.seq, self.acceptor_sam.seq = self.acceptor_sam.seq, self.donor_sam.seq\n\n        # Flip the strands of both SAMs\n        # NOTE only switch the strands if both are + or -, don't do it otherwise\n        # Interesting that it works this way, but I drew it out and I'm confident\n        if self.donor_sam.strand == self.acceptor_sam.strand:\n            self.donor_sam.strand = \"-\" if self.donor_sam.strand == \"+\" else \"+\"\n            self.acceptor_sam.strand = \"-\" if self.acceptor_sam.strand == \"+\" else \"+\"\n\n        # Trade starts and stops of donor and acceptor and chromosome\n        self.donor_sam.start, self.acceptor_sam.start = self.acceptor_sam.start, self.donor_sam.start\n        self.donor_sam.stop, self.acceptor_sam.stop = self.acceptor_sam.stop, self.donor_sam.stop\n        self.donor_sam.chromosome, self.acceptor_sam.chromosome = self.acceptor_sam.chromosome, self.donor_sam.chromosome\n\n        return self\n\n    # Format the junction for MACHETE in fasta form\n    # NOTE only call this function on 'fusion' identified junctions\n    def fasta_MACHETE(self):\n        \"\"\"\n        Goal: produce a fasta_string for MACHETE\n        Arguments:\n            none\n        Returns:\n            a fasta formatted string (with a newline between header and sequence)\n        \"\"\"\n        # Make the necessary variables\n        chrom1 = self.donor_sam.chromosome\n        chrom2 = self.acceptor_sam.chromosome\n        genes1 = self.donor_sam.str_gene()\n        genes2 = self.acceptor_sam.str_gene()\n        pos1 = self.donor_sam.donor()\n        pos2 = self.acceptor_sam.acceptor()\n        strand1 = self.donor_sam.strand\n        strand2 = self.acceptor_sam.strand\n        fusion_type = self.get_fusion_type()\n\n        # Start building the fasta string\n        fasta_str = \"\"\n        fasta_str += \">\"\n        fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n        fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n        fasta_str += fusion_type\n        fasta_str += \",num=\" + str(len(self.bin_pair_group))\n        fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n        fasta_str += \",score=\" + str(self.score)\n        fasta_str += \",gap=\" + str(self.splice_gap())\n        fasta_str += \",break-point=\" + str(self.splice_ind())\n        fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(self.uniformity_score[1]) + \")\"\n        fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n        fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n        fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n        fasta_str += \",mapq=\" + str(self.mapq)\n        fasta_str += \",badfj3:\" + str(self.badfj3)\n        fasta_str += \",jct_ind=\" + str(self.jct_ind)\n        fasta_str += \"\\n\"\n\n        # Add the actual padded consensus to the output string\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n\n        return fasta_str\n\n    def fasta_header(self):\n        \"\"\"\n        Goal: produce a fasta_string for MACHETE\n        Arguments:\n            none\n        Returns:\n            a fasta formatted string (with a newline between header and sequence)\n        \"\"\"\n        # Make the necessary variables\n        chrom1 = self.donor_sam.chromosome\n        chrom2 = self.acceptor_sam.chromosome\n        genes1 = self.donor_sam.str_gene()\n        genes2 = self.acceptor_sam.str_gene()\n        pos1 = self.donor_sam.donor()\n        pos2 = self.acceptor_sam.acceptor()\n        strand1 = self.donor_sam.strand\n        strand2 = self.acceptor_sam.strand\n        fusion_type = self.get_fusion_type()\n\n        # Start building the fasta string\n        fasta_str = \"\"\n        fasta_str += \">\"\n        fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n        fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n        fasta_str += fusion_type\n        fasta_str += \",num=\" + str(len(self.bin_pair_group))\n        fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n        fasta_str += \",score=\" + str(self.score)\n        fasta_str += \",gap=\" + str(self.splice_gap())\n        fasta_str += \",break-point=\" + str(self.splice_ind())\n        fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n            self.uniformity_score[1]) + \")\"\n        fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n        fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n        fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n        fasta_str += \",mapq=\" + str(self.mapq)\n        fasta_str += \",badfj3:\" + str(self.badfj3)\n        fasta_str += \",jct_ind=\" + str(self.jct_ind)\n\n        return fasta_str\n\n    # Format the junction to print in fasta-esque form\n    def log_string(self):\n        \"\"\"\n        Goal: produce a fasta_string\n        Arguments:\n            optionally include a junction index.\n            if it is included, it will be printed out\n\n        Returns:\n            a description of the junction over multiple lines\n        \"\"\"\n        fasta_str = \"\"\n        fasta_str += \">|\" + str(self.donor_sam.chromosome) + \"|\"\n        fasta_str += str(self.donor_sam.str_gene()) + \" \"\n        fasta_str += str(self.donor_sam.gene_strand()) + \" strand|\"\n        fasta_str += str(self.donor_sam.start) + \"-\"\n        fasta_str += str(self.donor_sam.stop) + \"|\"\n        fasta_str += \"strand1:\" + str(self.donor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist1:\" + str(self.boundary_dist(\"donor\")) + \"|\"\n        fasta_str += \"at_boundary1:\" + str(self.at_boundary(\"donor\")) + \"|\\n\"\n\n        fasta_str += \">|\" + str(self.acceptor_sam.chromosome) + \"|\"\n        fasta_str += str(self.acceptor_sam.str_gene()) + \" \"\n        fasta_str += str(self.acceptor_sam.gene_strand()) + \" strand|\"\n        fasta_str += str(self.acceptor_sam.start) + \"-\"\n        fasta_str += str(self.acceptor_sam.stop) + \"|\"\n        fasta_str += \"strand2:\" + str(self.acceptor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist2:\" + str(self.boundary_dist(\"acceptor\")) + \"|\"\n        fasta_str += \"at_boundary2:\" + str(self.at_boundary(\"acceptor\")) + \"|\\n\"\n\n        fasta_str += \">|splice:\" + str(self.splice_ind()) + \"|\"\n        fasta_str += \"score:\" + str(self.score) + \"|\"\n        fasta_str += \"fusion:\" + str(self.get_fusion_type()) + \"|\"\n        fasta_str += \"num:\" + str(len(self.bin_pair_group)) + \"|\"\n        fasta_str += \"splice:\" + str(self.splice_type()) + \"|\"\n        fasta_str += \"mapq=\" + str(self.mapq) + \"|\"\n        fasta_str += \"badfj3:\" + str(self.badfj3) + \"|\"\n        fasta_str += \"jct_ind:\" + str(self.jct_ind) + \"|\\n\"\n\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n        fasta_str += str(self.donor_sam.seq) + \"\\n\"\n        fasta_str += \" \" * self.splice_ind() + str(self.acceptor_sam.seq) + \"\\n\"\n\n        # Also printing out gtf information\n        # fasta_str += \"Donor_gtf:\"+str(self.donor_sam.gtf)+\"\\n\"\n        # fasta_str += \"Acceptor_gtf:\"+str(self.acceptor_sam.gtf)+\"\\n\"\n        return fasta_str\n\n    # Format the junction to print in fasta form\n    def verbose_fasta_string(self):\n        \"\"\"\n        Goal: produce a fasta formatted string of this junction with lots of header info\n        Arguments:\n            none\n\n        Returns:\n            a fasta string (with a newline between the header and sequence)\n        \"\"\"\n        fasta_str = \"\"\n        fasta_str += \">|chromosome1:\" + str(self.donor_sam.chromosome) + \"|\"\n        fasta_str += \"genes1:\" + str(self.donor_sam.str_gene()) + \"|\"\n        fasta_str += \"start1:\" + str(self.donor_sam.start) + \"|\"\n        fasta_str += \"stop1:\" + str(self.donor_sam.stop) + \"|\"\n        fasta_str += \"strand1:\" + str(self.donor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist1:\" + str(self.boundary_dist(\"donor\")) + \"|\"\n        fasta_str += \"at_boundary1:\" + str(self.at_boundary(\"donor\")) + \"|_\"\n\n        fasta_str += \"|chromosome2:\" + str(self.acceptor_sam.chromosome) + \"|\"\n        fasta_str += \"genes2:\" + str(self.acceptor_sam.str_gene()) + \"|\"\n        fasta_str += \"start2:\" + str(self.acceptor_sam.start) + \"|\"\n        fasta_str += \"stop2:\" + str(self.acceptor_sam.stop) + \"|\"\n        fasta_str += \"strand2:\" + str(self.acceptor_sam.strand) + \"|\"\n        fasta_str += \"boundary_dist2:\" + str(self.boundary_dist(\"acceptor\")) + \"|\"\n        fasta_str += \"at_boundary2:\" + str(self.at_boundary(\"acceptor\")) + \"|_|\"\n\n        fasta_str += \"jct_ind:\" + str(self.jct_ind) + \"|\"\n        fasta_str += \"splice:\" + str(self.splice_ind()) + \"|\"\n        fasta_str += \"span:\" + str(self.span()) + \"|\"\n        fasta_str += \"score:\" + str(self.score) + \"|\"\n        fasta_str += \"fusion:\" + str(self.get_fusion_type()) + \"|\"\n        fasta_str += \"num:\" + str(len(self.bin_pair_group)) + \"|\"\n        fasta_str += \"splice-gap:\" + str(self.splice_gap()) + \"|\"\n        fasta_str += \"splice-type:\" + str(self.splice_type()) + \"|\"\n        fasta_str += \"badfj3:\" + str(self.badfj3) + \"|\"\n        fasta_str += \"took-rev-comp:\" + str(self.took_reverse_compliment) + \"|\\n\"\n\n        # Add N padding to the consensus to get a uniform len\n        splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n        full_consensus = self.format_consensus(splice_flank_len)\n        fasta_str += str(full_consensus) + \"\\n\"\n        return fasta_str\n\n    # Add N padding to the consensus to get a uniform len\n    # With the splice site in the middle\n    def format_consensus(self, splice_flank_len):\n        \"\"\"\n        Goal: return the consensus properly formatted centered and uniform len\n        Arguments:\n            splice_flank_len is an int deciding how long either side should be\n            from the consensus\n        Returns:\n            a string of either the full consensus of None if there is no splice ind\n        \"\"\"\n        full_consensus = None\n        if self.splice_ind() != -1:\n            splice_flank_len = int(self.constants_dict[\"splice_flank_len\"])\n            left_padding = \"N\" * (splice_flank_len - self.splice_ind())\n            right_padding = \"N\" * (splice_flank_len - (len(self.consensus) - self.splice_ind()))\n            if self.splice_ind() <= splice_flank_len:\n                five_consensus = self.consensus[:self.splice_ind()]\n            else:\n                five_consensus = self.consensus[self.splice_ind() - splice_flank_len:self.splice_ind()]\n            if self.splice_ind() + splice_flank_len >= len(self.consensus):\n                three_consensus = self.consensus[self.splice_ind():]\n            else:\n                three_consensus = self.consensus[self.splice_ind():self.splice_ind() + splice_flank_len]\n            full_consensus = left_padding + five_consensus + three_consensus + right_padding\n        return str(full_consensus)\n\n    # Give back the R1 readIDs used to make this junction\n    def get_read_ids(self):\n        \"\"\"\n        Goal: return a list of the read ids (strings) that made this junction\n        Arguments:\n            none\n        Returns:\n            a list[string] of the read-ids for this junction\n        \"\"\"\n        read_ids = []\n        for bin_pair in self.bin_pair_group:\n            donor_id = bin_pair.five_prime_SAM.read_id.replace(\"/5_prime\", \"\")\n            acceptor_id = bin_pair.five_prime_SAM.read_id.replace(\"/3_prime\", \"\")\n            if donor_id == acceptor_id:\n                read_ids.append(donor_id)\n            else:\n                sys.stderr.write(\"SPORK ERROR, nonmatching ids in jct: [\" + donor_id + \"] vs [\" + acceptor_id + \"]\\n\")\n                sys.exit(1)\n\n        return read_ids\n\n    def add_duplicates(self, duplicate_junctions):\n\n        if self.donor_sam.gtf.synonyms or self.acceptor_sam.gtf.synonyms:\n            chrom1 = self.donor_sam.chromosome\n            chrom2 = self.acceptor_sam.chromosome\n            genes1 = self.donor_sam.str_gene()\n            genes2 = self.acceptor_sam.str_gene()\n            pos1 = self.donor_sam.donor()\n            pos2 = self.acceptor_sam.acceptor()\n            strand1 = self.donor_sam.strand\n            strand2 = self.acceptor_sam.strand\n            fusion_type = self.get_fusion_type()\n\n            # Start building the fasta string\n            fasta_str_org = \"\"\n            fasta_str_org += \">\"\n            fasta_str_org += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n            fasta_str_org += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n            fasta_str_org += fusion_type\n            fasta_str_org += \",num=\" + str(len(self.bin_pair_group))\n            fasta_str_org += \",collapsed_num=\" + str(self.collapsed_num)\n            fasta_str_org += \",score=\" + str(self.score)\n            fasta_str_org += \",gap=\" + str(self.splice_gap())\n            fasta_str_org += \",break-point=\" + str(self.splice_ind())\n            fasta_str_org += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                self.uniformity_score[1]) + \")\"\n            fasta_str_org += \",at_boundary=\" + str(self.is_at_boundary)\n            fasta_str_org += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n            fasta_str_org += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n            fasta_str_org += \",mapq=\" + str(self.mapq)\n            fasta_str_org += \",badfj3:\" + str(self.badfj3)\n            fasta_str_org += \",jct_ind=\" + str(self.jct_ind)\n            fasta_str_org += \"\\n\"\n            if self.donor_sam.gtf.synonyms and self.acceptor_sam.gtf.synonyms:\n                for genes1, genes2 in itertools.product(self.donor_sam.gtf.synonyms, self.acceptor_sam.gtf.synonyms):\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    # genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if self.donor_sam.gtf.synonyms and not self.acceptor_sam.gtf.synonyms:\n                for genes1 in self.donor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if self.donor_sam.gtf.synonyms and not self.acceptor_sam.gtf.synonyms:\n                for genes1 in self.donor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    # genes1 = self.donor_sam.str_gene()\n                    genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n            if not self.donor_sam.gtf.synonyms and self.acceptor_sam.gtf.synonyms:\n                for genes2 in self.acceptor_sam.gtf.synonyms:\n                    chrom1 = self.donor_sam.chromosome\n                    chrom2 = self.acceptor_sam.chromosome\n                    genes1 = self.donor_sam.str_gene()\n                    # genes2 = self.acceptor_sam.str_gene()\n                    pos1 = self.donor_sam.donor()\n                    pos2 = self.acceptor_sam.acceptor()\n                    strand1 = self.donor_sam.strand\n                    strand2 = self.acceptor_sam.strand\n                    fusion_type = self.get_fusion_type()\n\n                    # Start building the fasta string\n                    fasta_str = \"\"\n                    fasta_str += \">\"\n                    fasta_str += str(chrom1) + \":\" + str(genes1) + \":\" + str(pos1) + \":\" + str(strand1) + \"|\"\n                    fasta_str += str(chrom2) + \":\" + str(genes2) + \":\" + str(pos2) + \":\" + str(strand2) + \"|\"\n                    fasta_str += fusion_type\n                    fasta_str += \",num=\" + str(len(self.bin_pair_group))\n                    fasta_str += \",collapsed_num=\" + str(self.collapsed_num)\n                    fasta_str += \",score=\" + str(self.score)\n                    fasta_str += \",gap=\" + str(self.splice_gap())\n                    fasta_str += \",break-point=\" + str(self.splice_ind())\n                    fasta_str += \",uniformity_score=\" + \"(\" + str(self.uniformity_score[0]) + \";\" + str(\n                        self.uniformity_score[1]) + \")\"\n                    fasta_str += \",at_boundary=\" + str(self.is_at_boundary)\n                    fasta_str += \",don-dist:\" + str(self.boundary_dist(\"donor\"))\n                    fasta_str += \",acc-dist:\" + str(self.boundary_dist(\"acceptor\"))\n                    fasta_str += \",mapq=\" + str(self.mapq)\n                    fasta_str += \",badfj3:\" + str(self.badfj3)\n                    fasta_str += \",jct_ind=\" + str(self.jct_ind)\n                    fasta_str += \"\\n\"\n                    duplicate_junctions[fasta_str] = fasta_str_org\n\n    # More human readable format\n    def __str__(self):\n        \"\"\"\n        Goal: output the junction in an expanded human readable form\n        Arguments:\n            none\n\n        Returns:\n            the string to be printed out\n        \"\"\"\n        out_str = \"\"\n        out_str += \"Junction with bin pair [\" + self.bin_pair + \"] with [\" + str(\n            len(self.bin_pair_group)) + \"] reads mapped\\n\"\n        out_str += \"Linear \" if self.linear() else \"Non-Linear \"\n        out_str += \"Donor on the \" + str(self.donor_sam.strand) + \" strand and acceptor on the \" + str(\n            self.acceptor_sam.strand) + \"\\n\"\n        out_str += \"5' map position [\" + str(self.donor_sam.start) + \"-\" + str(self.donor_sam.stop) + \"]\\n\"\n        out_str += \"3' map position [\" + str(self.acceptor_sam.start) + \"-\" + str(self.acceptor_sam.stop) + \"]\\n\"\n        out_str += \"badfj3:\" + str(self.badfj3) + \"\\n\"\n        out_str += \"Consensus with score [\" + str(self.score) + \"] and donor splice site [\" + str(\n            self.donor_sam.stop) + \"]:\\n\"\n        out_str += str(self.consensus) + \"\\n\"\n        out_str += str(self.donor_sam.seq) + \"\\n\"\n        out_str += \" \" * len(str(self.donor_sam.seq)) + str(self.acceptor_sam.seq) + \"\\n\"\n        out_str += \"Donor genes [\" + str(self.donor_sam.str_gene()) + \"]\\n\"\n        out_str += \"Acceptor genes [\" + str(self.acceptor_sam.str_gene()) + \"]\\n\"\n        return out_str\n\n    # Rank junctions in order of bin_pairs when sorted\n    def __lt__(self, other):\n        \"\"\"\n        Goal: give a comparison operator for the Junction class\n        Arguments:\n            other junction to compare to\n\n        Returns:\n            a boolean of whether or not this bin_pair\n            is smaller than the other bin_pair\n        \"\"\"\n        return self.bin_pair < other.bin_pair",
                "filename": "SPORK_Junction.py"
              },
              {
                "fileContent": "#Class to store GTF entries\n#TODO give this better documentation\n\n#Imports\nimport re\nimport sys\n\nclass GTFEntry(object):\n    __slots__ = [\"chromosome\",\"source\",\"feature\", \"start\",\"stop\",\"score\",\"strand\", \"frame\",\"gene_name\", \"donor\",\"acceptor\",\"span\", \"synonyms\"]\n\n    def __init__(self,gtf_line='chr\\tsrc\\tfeat\\t-1\\t-1\\t-1\\t+\\t0\\tgene_name \"default\";'):\n        \"\"\"\n        Goal: initialize a GTFEntry\n        Arguments:\n            a gtf_line from a standard gtf file, optional, if none given default made\n\n        Returns:\n            nothing\n        \"\"\"\n        split_gtf_line = gtf_line.split(\"\\t\")\n        self.chromosome = split_gtf_line[0]\n        self.source = split_gtf_line[1]\n        self.feature = split_gtf_line[2]\n        self.start = int(split_gtf_line[3])\n        self.stop = int(split_gtf_line[4])\n        self.score = split_gtf_line[5]\n        self.strand = split_gtf_line[6]\n        self.frame = split_gtf_line[7]\n        self.donor = self.stop if self.strand == \"+\" else self.start\n        self.acceptor = self.start if self.strand == \"+\" else self.stop\n        self.span = abs(self.donor-self.acceptor)\n        group_info = split_gtf_line[8]\n        gene_name_pattern = re.compile('gene_name \"(.*?)\";')\n        gene_name = gene_name_pattern.findall(group_info)\n        if len(gene_name) == 0:\n            gene_id_pattern = re.compile('gene_id \"(.*?)\";')\n            gene_name = gene_id_pattern.findall(group_info)\n            if len(gene_name) == 0:\n                sys.stdout.write(\"SPORK ERROR: in gtf init. No found gene_name or gene_id\")\n                sys.stderr.write(\"SPORK ERROR: in gtf init. No found gene_name or gene_id\")\n                sys.exit(1)\n        self.gene_name = gene_name[0]\n        self.synonyms = set()\n    def __str__(self):\n        \"\"\"\n        Goal: yield a string representation of this GTFEntry\n        Arguments:\n            none\n\n        Returns:\n            a string of important info about this GTFEntry\n        \"\"\"\n        ret_str = \"\"\n        ret_str += \"chromosome: \"+self.chromosome+\"\\t\"\n        ret_str += \"name: \"+self.gene_name+\"\\t\"\n        ret_str += \"donor: \"+str(self.donor)+\"\\t\"\n        ret_str += \"accep: \"+str(self.acceptor)+\"\\t\"\n        ret_str += \"strand: \"+self.strand+\"\\t\"\n        ret_str += \"start: \"+str(self.start)+\"\\t\"\n        ret_str += \"stop: \"+str(self.stop)+\"\\t\"\n        return ret_str\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allows comparison between GTFEntries\n        Arguments:\n            other is also a GTFEntry\n\n        Returns:\n            true if self's chromosome is smaller than other's,\n            or if they are shared and self's start position is smaller\n            false otherwise\n        \"\"\"\n        if self.chromosome != other.chromosome:\n            return self.chromosome < other.chromosome\n        else:\n            return self.start < other.start",
                "filename": "SPORK_GTFEntry.py"
              },
              {
                "fileContent": "# Fastq entry class\n\n# Imports\nimport sys\n\n\nclass FastQEntry(object):\n    __slots__ = [\"read_id\", \"seq\", \"plus_line\", \"quality\"]\n\n    def __init__(self, read_id, seq, plus_line, quality):\n        \"\"\"\n        Goal: initialize the FastQEntry object with the appropriate info\n        Arguments:\n            all of the fastq lines one at a time\n            read_id, seq, plus_line, and quality\n\n        Returns:\n            nothing\n        \"\"\"\n        self.read_id = read_id\n        self.seq = seq\n        self.plus_line = plus_line\n        self.quality = quality\n        self.clean()\n\n    def get_edge_thirds(self, min_third=20):\n        \"\"\"\n        Goal: split this FastQEntry into a 5' and 3' FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            a tuple of FastQEntry objects [5',3']\n        \"\"\"\n        third_len = len(self.seq) / 3\n        if third_len < min_third:\n            # sys.stderr.write(\"Skipping read too short to split in thirds: \"+self.read_id+\"\\n\")\n            return None, None\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[2 * third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[2 * third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def get_first_last_n(self, third_len=36):\n        \"\"\"\n        Goal: very similar to the edge \n        Arguments:\n            optional length of n to take (defaulted at 36)\n\n        Returns:\n            a tuple of 5' and 3' FastQEntry objects\n        \"\"\"\n        # Check to make sure can at least get the first and last third in length\n        if len(self.seq) <= third_len * 2:\n            # sys.stderr.write(\"SPORK: Skipping read too short to split in thirds: \"+self.read_id+\" len = \"+str(len(self.seq))+\"\\n\")\n            return None, None\n        five_prime_seq = self.seq[:third_len]\n        three_prime_seq = self.seq[-third_len:]\n        five_prime_read = FastQEntry(self.read_id + \"/5_prime\", five_prime_seq, self.plus_line,\n                                     self.quality[:third_len])\n        three_prime_read = FastQEntry(self.read_id + \"/3_prime\", three_prime_seq, self.plus_line,\n                                      self.quality[-third_len:])\n\n        return five_prime_read, three_prime_read\n\n    def clean(self):\n        \"\"\"\n        Goal: clean up the read id, sequence, plus line, and quality\n        Arguments:\n            none\n\n        Returns:\n            nothing\n        \"\"\"\n        # self.read_id = self.read_id.replace(\" \",\"_\").replace(\"\\t\",\"_\").replace(\"\\n\",\"\")\n        self.read_id = self.read_id.replace(\"\\n\", \"\")\n        self.seq = self.seq.replace(\"U\", \"T\").replace(\"\\n\", \"\")\n        self.plus_line = self.plus_line.replace(\" \", \"_\").replace(\"\\n\", \"\")\n        self.quality = self.quality.replace(\"\\n\", \"\")\n\n    def __str__(self):\n        \"\"\"\n        Goal: return an easy to print string of a FastQEntry\n        Arguments:\n            none\n\n        Returns:\n            An output string\n        \"\"\"\n        ret_str = \"\"\n        ret_str += self.read_id + \"\\n\"\n        ret_str += self.seq + \"\\n\"\n        ret_str += self.plus_line + \"\\n\"\n        ret_str += self.quality + \"\\n\"\n        return ret_str\n\n    def __lt__(self, other):\n        \"\"\"\n        Goal: allow comparison between two FastQEntry objects based on read_id\n        Arguments:\n            other is a FastQEntry to compare to\n\n        Returns:\n            True if the read id of this object is 'less' than that of the other\n        \"\"\"\n        return self.read_id < other.read_id",
                "filename": "SPORK_FastQEntry.py"
              },
              {
                "fileContent": "#Imports\nimport sys\n\n#build and score consensus function\n#(1) pads the left and right side of each sequence depending on where it mapped in the bin\n#(2) finds a consensus using a majority vote\n#(3) calculates a consensus score as the (number of mismatches)/(total_possible_mismatches)\ndef build_and_score_consensus(mapped_reads, strand, id_to_seq, bin_size, constants_dict, read_num_to_read_id):\n    #Add padding to the left sides of the reads based on where they fell in the bin pair\n    #Note that for the plus strand, more padding should be added the larger ther pos%bin_size value\n    #while this should have less padding on a minus strand read. This is implemented w/ the ternary expression\n    #read_num_to_read_id = constants_dict[\"read_num_to_read_id\"]\n    padded_seqs = []\n    left_padded_seqs = []\n    for mapped_read in mapped_reads:\n        id_key = mapped_read.read_id\n        id_key = id_key.replace(\"/5_prime\",\"\")\n        id_key = id_key.replace(\"/3_prime\",\"\")\n        id_key = read_num_to_read_id[id_key]\n        #id_key = id_key.replace(\"_\",\" \")\n        if id_key in id_to_seq:\n            full_seq = id_to_seq[id_key]\n        else:\n            sys.stderr.write(\"SPORK ERROR: Couldn't find sequence \"+id_key+\" in consensus building\\n\")\n            sys.exit(1)\n        mapped_read.read_id = id_key\n        left_padding = int(mapped_read.start%bin_size) if strand == \"+\" else int(bin_size-mapped_read.start%bin_size)\n        left_padded_seq = \" \"*left_padding+full_seq\n\n        #Don't allow exact sequence duplicates\n        if left_padded_seq not in left_padded_seqs:\n            left_padded_seqs.append(left_padded_seq)\n\n    #Add padding on the right sides so that every sequence is the same length\n    #Handled the same for plus and minus strand\n    max_len_seq = max([len(seq) for seq in left_padded_seqs])\n    for left_padded_seq in left_padded_seqs:\n        left_padded_len = len(left_padded_seq)\n        padding_to_add = max_len_seq-left_padded_len\n        padded_seq = left_padded_seq+\" \"*padding_to_add\n        padded_seqs.append(padded_seq)\n\n    #Go through each position and get the majority vote as the consensus base\n    #The dictionaries are just to help convert letters into indices and back\n    min_bases_per_col = constants_dict[\"min_bases_per_col\"]\n    consensus = \"\"\n    empty_spaces = 0\n    num_possible_discrepancies = 0\n    num_discrepancies = 0\n    base_dict = {\"A\":0,\"C\":1,\"G\":2,\"T\":3}\n    rev_base_dict = {0:\"A\",1:\"C\",2:\"G\",3:\"T\"}\n    for seq_ind in range(max_len_seq):\n        counts = [0,0,0,0]\n        for seq in padded_seqs:\n            base = seq[seq_ind].upper()\n            if base in base_dict:\n                counts[base_dict[base]] += 1\n        total_bases = sum(counts)\n        if total_bases >= min_bases_per_col:\n            num_possible_discrepancies += total_bases\n            max_count = max(counts)\n            num_discrepancies += total_bases-max_count\n            max_index = counts.index(max_count)\n            consensus += rev_base_dict[max_index]\n        else: empty_spaces += 1\n\n    #Give a terrible score if there are 0 possible discrepancies\n    #This arises most often when a junction only has one unique sequence\n    if int(num_possible_discrepancies) <= 0:\n        consensus_score = 999999\n        #sys.stderr.write(\"Null consensus:\\n\"+\"\\n\".join(padded_seqs)+\"\\n\")\n    else:\n        consensus_score = float(num_discrepancies)/int(num_possible_discrepancies)\n\n    #Print out the consensus's in a nice way\n    print_consensus = False\n    if print_consensus:\n        print \"Strand: \"+strand\n        print \"Discrepancies: \"+str(num_discrepancies)\n        print \"=\"*(len(seq)+2)\n        for seq in padded_seqs:\n            print \"|\"+seq+\"|\"\n        print \"=\"*(len(seq)+2)\n        print \"|\"+\" \"*(len(seq)-len(consensus)-min_bases_per_col)+consensus+\" \"*min_bases_per_col+\"|\"\n        left_score_str = \"|Score: \"+str(consensus_score)+\" \"\n        right_score_str = \" \"*(len(seq)+2-len(left_score_str)-1)+\"|\"\n        print left_score_str+right_score_str\n        print \"=\"*(len(seq)+2)\n        print \"\"\n\n    return consensus,consensus_score",
                "filename": "SPORK_consensus_utils.py"
              },
              {
                "fileContent": "#BinPair class\nclass BinPair(object):\n    __slots__ = [\"five_prime_SAM\",\"three_prime_SAM\",\"five_prime_bin\",\"three_prime_bin\", \"five_prime_strand\",\"three_prime_strand\",\"bin_pair\",\"five_prime_chr\",\"three_prime_chr\"]\n\n    def __init__(self,five_prime_SAM,three_prime_SAM,five_prime_bin,three_prime_bin):\n        \"\"\"\n        Goal: setup a BinPair object\n        Arguments:\n            a 5' SAMEntry object, a 3' SAMEntry object, and a bin from each (bins are ints)\n\n        Returns:\n            nothing\n        \"\"\"\n        self.five_prime_SAM = five_prime_SAM\n        self.three_prime_SAM = three_prime_SAM\n        self.five_prime_bin = int(five_prime_bin)\n        self.three_prime_bin = int(three_prime_bin)\n        self.five_prime_strand = five_prime_SAM.strand\n        self.three_prime_strand = three_prime_SAM.strand\n        self.five_prime_chr = five_prime_SAM.chromosome\n        self.three_prime_chr = three_prime_SAM.chromosome\n        self.bin_pair = self.five_prime_chr+\":\"+str(self.five_prime_bin)+\"_\"+self.three_prime_chr+\":\"+str(self.three_prime_bin)+\"_(\"+self.five_prime_strand+\",\"+self.three_prime_strand+\")\"\n\n    #Schematic of what the reverse compliment aims to do:\n    #================\n    #Before flipping:\n    #================\n    #\n    #(+ strand)-----------------------------------------\n    #\n    #             (*)  (#)                (*)  (#)\n    #              ======                  ======\n    #(- strand)----| 3' |------------------| 5' |-------\n    #              ======                  ======\n    #\n    #(*)'s are the upstream positions and (#)'s are the downstream positions\n    #\n    #===============\n    #After flipping:\n    #===============\n    #\n    #             (*)  (#)                (*)  (#)\n    #              ======                  ======\n    #(+ strand)----| 5' |------------------| 3' |-------\n    #              ======                  ======\n    #\n    #(- strand)-----------------------------------------\n    #\n    #So the 5' box got the orig 3' positions and should have the rev comp seq of the orig 3' seq\n    #the same thing happens to the 3' box\n    def take_reverse_compliment(self):\n        \"\"\"\n        Goal: take the reverse compliment of this bin pair\n        Arguments:\n            none\n\n        Returns:\n            itself for use in list comprehensions\n        \"\"\"\n        #Switch all the strands\n        self.five_prime_SAM.strand = \"-\" if self.five_prime_SAM.strand == \"+\" else \"+\"\n        self.three_prime_SAM.strand = \"-\" if self.three_prime_SAM.strand == \"+\" else \"+\"\n        self.five_prime_strand = \"-\" if self.five_prime_strand == \"+\" else \"+\"\n        self.three_prime_strand = \"-\" if self.three_prime_strand == \"+\" else \"+\"\n\n        #Swap the positions of the five and three prime SAMs\n        hold_five_prime_start = self.five_prime_SAM.start\n        hold_five_prime_stop = self.five_prime_SAM.stop\n        self.five_prime_SAM.start = self.three_prime_SAM.start\n        self.five_prime_SAM.stop = self.three_prime_SAM.stop\n        self.three_prime_SAM.start = hold_five_prime_start\n        self.three_prime_SAM.stop = hold_five_prime_stop\n\n        #Take the reverse compliment of the 5' and 3' seqs\n        #The list comprehensions are complicated but I like doing it in one line:\n        #   The [rev_comp_dict[base] for base in self.five_prime_SAM.seq] builds a list of complimentary bases\n        #   The \"\".join takes that list and turns it into a string\n        #   The [::-1] at the very end reverses the string to turn the compliment string into the rev comp string\n        rev_comp_dict = {\"A\":\"T\",\"a\":\"t\",\"T\":\"A\",\"t\":\"a\",\n                         \"C\":\"G\",\"c\":\"g\",\"G\":\"C\",\"g\":\"c\",\n                         \"N\":\"N\",\"n\":\"n\"}\n        rev_comp_5_prime_seq = \"\".join([rev_comp_dict[base] for base in self.five_prime_SAM.seq])[::-1]\n        rev_comp_3_prime_seq = \"\".join([rev_comp_dict[base] for base in self.three_prime_SAM.seq])[::-1]\n\n        #Then put the orig 3' rev comp into the new 5' and vice versa\n        self.five_prime_SAM.seq = rev_comp_3_prime_seq\n        self.three_prime_SAM.seq = rev_comp_5_prime_seq\n\n        #Switch the chromosomes too in case this is a fusion\n        hold_chromosome = self.five_prime_SAM.chromosome\n        self.five_prime_SAM.chromosome = self.three_prime_SAM.chromosome\n        self.three_prime_SAM.chromosome = hold_chromosome\n\n        #Using this in a list comprehension, so I want it to return itself\n        return self\n\n    def __str__(self):\n        \"\"\"\n        Goal: make this object into a string for easy printing\n        Arguments:\n            none\n\n        Returns:\n            a string representation of a bin pair\n        \"\"\"\n        return \"Bin Pair: \"+self.bin_pair+\" Left: \"+self.five_prime_SAM.read_id+\" Right: \"+self.three_prime_SAM.read_id+\"\\n\"\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allow comparison between two binpair objects\n        Arguments:\n            other is a binpair object just like self\n\n        Returns:\n            true if the bin_pair string of self is less than that of other\n        \"\"\"\n        return self.bin_pair < other.bin_pair",
                "filename": "SPORK_BinPair.py"
              },
              {
                "fileContent": "#Import sys to write to sys.stderr sometimes\nimport sys\n\n#Mapped Read class\nclass SAMEntry(object):\n    __slots__ = [\"read_id\",\"strand\",\"chromosome\",\"start\",\"stop\",\"seq\",\"seq_quality\",\"exists\", \"num_gaps\", \"md\", \"num_mismatches\",\"num_Ns\",\"mapping_quality\",\"alignment_score\",\"gtf\"]\n\n    def __init__(self,full_line = None):\n        \"\"\"\n        Goal: initialize a SAMEntry object\n        Arguments:\n            can take in a full sam line (which it then parses),\n            or nothing, in which case a \"null\" SAMEntry is created\n            with None for every member\n\n        Returns:\n            nothing\n        \"\"\"\n        #Create an empty None-Type ish SAMEntry\n        if not full_line:\n            self.exists          = False\n            self.read_id         = None\n            self.strand          = None\n            self.chromosome      = None\n            self.start           = None\n            self.mapping_quality = None\n            self.seq             = None\n            self.seq_quality     = None\n            self.alignment_score = None\n            self.num_Ns          = None\n            self.num_mismatches  = None\n            self.num_gaps        = None\n            self.md              = None\n            self.stop            = None\n            self.gtf             = None\n\n        #Otherwise actually parse the line\n        else:\n            split_line = full_line.split(\"\\t\")\n            #Example bowtie2 SAM line w/ annotation:\n            #[0:read_id               ] K00180:68:H5CF7BBXX:3:1122:4422:11442/5_prime\n            #[1 :strand (0/16)        ] 0\n            #[2 :chromosome           ] chr21\n            #[3 :position             ] 9827122\n            #[4 :map quality          ] 42\n            #[5 :CIGAR string         ] 33M\n            #[6 :name of mate         ] *\n            #[7 :pos of mate          ] 0\n            #[8 :template len         ] 0\n            #[9 :sequence             ] CTTTGGTCGCTCGCTCCTCTCCTACTTGGATAA\n            #[10:quality string       ] <AAAFJJJFJJJJJFJFJJFJJJJJAJJFAFFJ\n            #[11:Alignment score      ] AS:i:0\n            #[12:number of N's        ] XN:i:0\n            #[13:number of mismatches ] XM:i:0\n            #[14:number gap opens     ] XO:i:0\n            #[15:number gap extensions] XG:i:0\n            #[16:edit distance        ] NM:i:0\n            #[17:string for mismatches] MD:Z:33\n            #[18:whether or not paired] YT:Z:UU\n            self.exists          = True\n            self.read_id         = split_line[0]\n            self.strand          = \"+\" if split_line[1] == \"0\" or split_line[1] == \"256\" else \"-\"\n            self.chromosome      = split_line[2]\n            self.start           = int(split_line[3])\n            self.mapping_quality = int(split_line[4])\n            self.seq             = split_line[9]\n            self.seq_quality     = split_line[10]\n            self.alignment_score = int(split_line[11].split(\":\")[-1])\n\n            for value in split_line[11:]:\n                if value[0:3] == \"XN:\":\n                    self.num_Ns          = int(value.split(\":\")[-1])\n                if value[0:3] == \"XM:\":\n                    self.num_mismatches  = int(value.split(\":\")[-1])\n                if value[0:3] == \"XO:\":\n                    self.num_gaps        = int(value.split(\":\")[-1])\n                if value[0:3] == \"MD:\":\n                    self.md = value.split(\":\")[-1]\n\n            self.stop = self.start+len(self.seq)\n            self.gtf = None\n\n    def donor(self):\n        \"\"\"\n        Goal: return the donor position of the SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            The donor position as an integer\n        \"\"\"\n        don = self.stop if self.strand == \"+\" else self.start\n        return don\n\n    def acceptor(self):\n        \"\"\"\n        Goal: return the acceptor position of the SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            The acceptor position as an integer\n        \"\"\"\n        acc = self.start if self.strand == \"+\" else self.stop\n        return acc\n\n    def str_gene(self):\n        \"\"\"\n        Goal: return the gene name associated with this SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            None in string form if no gene, or the gene name in string form\n        \"\"\"\n        if self.gtf:\n            return str(self.gtf.gene_name)\n        else:\n            return str(self.gtf)\n\n    def gene_strand(self):\n        \"\"\"\n        Goal: return the gtf gene strand associated with this SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            None in string form if no gene, or the gene strand in string form\n        \"\"\"\n        if self.gtf:\n            return str(self.gtf.strand)\n        else:\n            return str(self.gtf)\n\n    def junction(self):\n        \"\"\"\n        Goal: get a string of SAMEntry that looks similar to junction fasta headers\n        Arguments:\n            none\n\n        Returns:\n            a string of this SAMEntry\n        \"\"\"\n        out_str = \"\"\n        out_str += \"jct|\"+self.chromosome.split(\"|\")[1] if \"|\" in self.chromosome else self.chromosome\n        out_str += \"|\"+str(self.start)\n        out_str += \"|\"+str(self.stop)\n        out_str += \"|\"+str(self.strand)\n        return out_str\n\n    def __str__(self):\n        \"\"\"\n        Goal: get a human friendly string representation of SAMEntry\n        Arguments:\n            none\n\n        Returns:\n            a string of important information of self\n        \"\"\"\n        ret_str = \"\"\n        ret_str += str(self.read_id)+\"\\t\"\n        ret_str += str(self.seq)+\"\\t\"\n        ret_str += str(self.chromosome)+\"\\t\"\n        ret_str += str(self.start)+\"\\t\"\n        ret_str += str(self.stop)+\"\\n\"\n        return ret_str\n\n    def __lt__(self,other):\n        \"\"\"\n        Goal: allow comparison between SAMEntries for sorting\n        Arguments:\n            other is of type SAMEntry as well\n\n        Returns:\n            true if self is on a smaller chromosome, or has a smaller\n            start if chromosomes are shared, otherwise false\n        \"\"\"\n        same_chr = self.chromosome == other.chromosome\n        if not same_chr:\n            return self.chromosome < other.chromosome\n        else:\n            return self.start < other.start",
                "filename": "SPORK_SAMEntry.py"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:altPrefix": "--gtfs_info_seq",
            "id": "#gtfs_info_seq",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "sbg:cmdInclude": true,
              "prefix": "-gis",
              "position": 10,
              "separate": true
            },
            "required": false
          },
          {
            "id": "#denovo_junctions_new",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "id": "#collapse_threshold",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          }
        ],
        "outputs": [
          {
            "id": "#used_read_ids",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_used_read_ids.txt",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tdenovo_junctions_new = [].concat($job.inputs.denovo_junctions_new)\n\tfor (i=0; i<denovo_junctions_new.length; i++)\n    {\n      \tif (denovo_junctions_new[i].metadata && denovo_junctions_new[i].metadata.sample_id){\n    \t\treturn denovo_junctions_new[i].metadata.sample_id\n        \n        }\n    }\n}"
                }
              }
            }
          },
          {
            "id": "#fusion_junction_ids_new",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*fusion_junction_ids_new.pickle",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tdenovo_junctions_new = [].concat($job.inputs.denovo_junctions_new)\n\tfor (i=0; i<denovo_junctions_new.length; i++)\n    {\n      \tif (denovo_junctions_new[i].metadata && denovo_junctions_new[i].metadata.sample_id){\n    \t\treturn denovo_junctions_new[i].metadata.sample_id\n        \n        }\n    }\n}"
                }
              }
            }
          },
          {
            "id": "#duplicate_junctions",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*duplicate_junctions.pickle",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tdenovo_junctions_new = [].concat($job.inputs.denovo_junctions_new)\n\tfor (i=0; i<denovo_junctions_new.length; i++)\n    {\n      \tif (denovo_junctions_new[i].metadata && denovo_junctions_new[i].metadata.sample_id){\n    \t\treturn denovo_junctions_new[i].metadata.sample_id\n        \n        }\n    }\n}"
                }
              }
            }
          },
          {
            "id": "#don_fasta",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*don.fasta",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tdenovo_junctions_new = [].concat($job.inputs.denovo_junctions_new)\n\tfor (i=0; i<denovo_junctions_new.length; i++)\n    {\n      \tif (denovo_junctions_new[i].metadata && denovo_junctions_new[i].metadata.sample_id){\n    \t\treturn denovo_junctions_new[i].metadata.sample_id\n        \n        }\n    }\n}"
                }
              }
            }
          },
          {
            "id": "#denovo_junctions_all",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*_denovo_junctions_all.pickle",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tdenovo_junctions_new = [].concat($job.inputs.denovo_junctions_new)\n\tfor (i=0; i<denovo_junctions_new.length; i++)\n    {\n      \tif (denovo_junctions_new[i].metadata && denovo_junctions_new[i].metadata.sample_id){\n    \t\treturn denovo_junctions_new[i].metadata.sample_id\n        \n        }\n    }\n}"
                }
              }
            }
          },
          {
            "id": "#acc_fasta",
            "type": [
              "null",
              "File"
            ],
            "outputBinding": {
              "glob": "*acc.fasta",
              "sbg:metadata": {
                "sample_id": {
                  "engine": "#cwl-js-engine",
                  "class": "Expression",
                  "script": "{\n  \tdenovo_junctions_new = [].concat($job.inputs.denovo_junctions_new)\n\tfor (i=0; i<denovo_junctions_new.length; i++)\n    {\n      \tif (denovo_junctions_new[i].metadata && denovo_junctions_new[i].metadata.sample_id){\n    \t\treturn denovo_junctions_new[i].metadata.sample_id\n        \n        }\n    }\n}"
                }
              }
            }
          }
        ],
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "dockerImageId": "",
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/milos_radovic/python_statsmodels_sklearn_scipy:1.0"
          }
        ],
        "baseCommand": [
          ""
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "position": 0,
            "valueFrom": {
              "engine": "#cwl-js-engine",
              "class": "Expression",
              "script": "{\n    sample_id = \"\"    \n    \n    command = \"python combine_files.py -djn\"\n    denovo_junctions_new = [].concat($job.inputs.denovo_junctions_new)\n   \t\n    for (i=0; i<denovo_junctions_new.length; i++)\n    {\n    \tcommand += \" \" + denovo_junctions_new[i].path\n    }\n  \n  \tfor (i=0; i<denovo_junctions_new.length; i++)\n    {\n      \tif (denovo_junctions_new[i].metadata && denovo_junctions_new[i].metadata.sample_id){\n    \t\tsample_id = denovo_junctions_new[i].metadata.sample_id\n            break\n        }\n    }\n  \n  \tcommand += \" -ct \" + $job.inputs.collapse_threshold\n  \tcommand += \" -s \" + sample_id\n    \n    return command \n}"
            },
            "separate": true
          }
        ],
        "sbg:image_url": null,
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533115855,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533118861,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533119292,
            "sbg:revisionNotes": "get outputs sample_id from don_fasta instead of denovo_junctions"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533120838,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533120872,
            "sbg:revisionNotes": "sample_name input removed"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533130375,
            "sbg:revisionNotes": "docker updated"
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533132739,
            "sbg:revisionNotes": "get sample_id from don_fasta"
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533136537,
            "sbg:revisionNotes": "combine_files fixed"
          },
          {
            "sbg:revision": 8,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533142768,
            "sbg:revisionNotes": "SPORK additional files added"
          },
          {
            "sbg:revision": 9,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533160859,
            "sbg:revisionNotes": "do collapse and identify fusions"
          },
          {
            "sbg:revision": 10,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533161030,
            "sbg:revisionNotes": "collapse_threshold input added"
          },
          {
            "sbg:revision": 11,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533164566,
            "sbg:revisionNotes": "fusion_junction_ids_new and duplicate_junctions inputs removed"
          },
          {
            "sbg:revision": 12,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533168441,
            "sbg:revisionNotes": "output changed"
          },
          {
            "sbg:revision": 13,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533169341,
            "sbg:revisionNotes": "denovo_junctions_all instead of denovo_junctions_new in output"
          },
          {
            "sbg:revision": 14,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533505832,
            "sbg:revisionNotes": "writing to file \"pre_collapse_novel_junctions_machete\" commented"
          },
          {
            "sbg:revision": 15,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533767185,
            "sbg:revisionNotes": "SPORK_Junctions updated: add_duplicates: break-point added"
          },
          {
            "sbg:revision": 16,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1533925020,
            "sbg:revisionNotes": "used_read_ids output file"
          },
          {
            "sbg:revision": 17,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534766536,
            "sbg:revisionNotes": "identify fusions first and then collapse"
          },
          {
            "sbg:revision": 18,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534781464,
            "sbg:revisionNotes": "back to rev 16 and SPORK_utils and SPORK_SAMEntry updated"
          },
          {
            "sbg:revision": 19,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534785502,
            "sbg:revisionNotes": "SPORK_SAMEntry fixed"
          },
          {
            "sbg:revision": 20,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534790550,
            "sbg:revisionNotes": "SPORK_SAMEntry fixed"
          },
          {
            "sbg:revision": 21,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534805354,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 22,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534945355,
            "sbg:revisionNotes": "SPORK_Junction updated"
          },
          {
            "sbg:revision": 23,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1534955799,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 24,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535201916,
            "sbg:revisionNotes": "SPORK_Junction, get_fusion_type: span_cutoff=1e6"
          },
          {
            "sbg:revision": 25,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535537867,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 26,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535754977,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e0)"
          },
          {
            "sbg:revision": 27,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535846235,
            "sbg:revisionNotes": "def get_fusion_type(self, span_cutoff=1e3)"
          },
          {
            "sbg:revision": 28,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1535908535,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 29,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536347405,
            "sbg:revisionNotes": "combin_files updated to get consensus from gtfs_info_seq, SPORK_Junction: splice_ind updated"
          },
          {
            "sbg:revision": 30,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536347458,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 31,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536350416,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 32,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536351417,
            "sbg:revisionNotes": "SPORK_Junction fixed"
          },
          {
            "sbg:revision": 33,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536355425,
            "sbg:revisionNotes": "combine_files.py fixed"
          },
          {
            "sbg:revision": 34,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536359252,
            "sbg:revisionNotes": "SPORK_Junction format_consensus updated"
          },
          {
            "sbg:revision": 35,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536363558,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 36,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536370303,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e6)"
          },
          {
            "sbg:revision": 37,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536417234,
            "sbg:revisionNotes": "combine_files.py, -5, 5 fixed"
          },
          {
            "sbg:revision": 38,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536419333,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 39,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536448180,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 40,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536704295,
            "sbg:revisionNotes": "without genome"
          },
          {
            "sbg:revision": 41,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536710000,
            "sbg:revisionNotes": "SPORK_Junction: fasta_header() added"
          },
          {
            "sbg:revision": 42,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1536972565,
            "sbg:revisionNotes": "SPORK_Junction: splice_ind() and fasta_header() updated, combine_files: correct don_dist and acc_dist"
          },
          {
            "sbg:revision": 43,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537010154,
            "sbg:revisionNotes": "-10, 10 instead of -5, 5"
          },
          {
            "sbg:revision": 44,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537020982,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e4)"
          },
          {
            "sbg:revision": 45,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537129863,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4)"
          },
          {
            "sbg:revision": 46,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537137886,
            "sbg:revisionNotes": "def get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 47,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537223172,
            "sbg:revisionNotes": "def get_fusion_type(self, span_cutoff=1e5), strand"
          },
          {
            "sbg:revision": 48,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537229650,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4), strand"
          },
          {
            "sbg:revision": 49,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537346720,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 50,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1537697537,
            "sbg:revisionNotes": "combine_files fixed"
          },
          {
            "sbg:revision": 51,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1538688924,
            "sbg:revisionNotes": "get_fusion_type(self, span_cutoff=5e4)"
          },
          {
            "sbg:revision": 52,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1539077246,
            "sbg:revisionNotes": "is_at_boundary, get_fusion_type(self, span_cutoff=1e5)"
          },
          {
            "sbg:revision": 53,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1540576303,
            "sbg:revisionNotes": "\"previous\" and \"next\" included"
          },
          {
            "sbg:revision": 54,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1541462825,
            "sbg:revisionNotes": "previous, next fixed"
          },
          {
            "sbg:revision": 55,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1541523772,
            "sbg:revisionNotes": "default don, default acc fixed"
          },
          {
            "sbg:revision": 56,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1542070709,
            "sbg:revisionNotes": "modifying splicing_site fixed"
          },
          {
            "sbg:revision": 57,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545151805,
            "sbg:revisionNotes": "SPORK_utils.py: collapse_junctions"
          },
          {
            "sbg:revision": 58,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545785921,
            "sbg:revisionNotes": "no identify fusions"
          },
          {
            "sbg:revision": 59,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1545866600,
            "sbg:revisionNotes": "SPORK_Junction.py: get_fusion_type fixed, combine_files: identify_fusions returned"
          },
          {
            "sbg:revision": 60,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1546131423,
            "sbg:revisionNotes": "SPORK_Junction: get_fusion_type updated"
          },
          {
            "sbg:revision": 61,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550514716,
            "sbg:revisionNotes": "allow splicing on the same chr, strand and dist<1e5"
          },
          {
            "sbg:revision": 62,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550770157,
            "sbg:revisionNotes": "SPORK_utils.py and SPORK_Junction.py updated to support collapsed_num and uniformity score"
          },
          {
            "sbg:revision": 63,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550773036,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: _SAM instead of _sam"
          },
          {
            "sbg:revision": 64,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550775036,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: bin_pair. added"
          },
          {
            "sbg:revision": 65,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550779716,
            "sbg:revisionNotes": "SPORK_utils.py fixed: repr_jct"
          },
          {
            "sbg:revision": 66,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550785375,
            "sbg:revisionNotes": "SPORK_Junction.py: self.collapsed_num"
          },
          {
            "sbg:revision": 67,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550791521,
            "sbg:revisionNotes": "SPORK_Junction.py: round uniformity score"
          },
          {
            "sbg:revision": 68,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550795680,
            "sbg:revisionNotes": "SPORK_Junction.py fixed: uniformity_score log"
          },
          {
            "sbg:revision": 69,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1550959908,
            "sbg:revisionNotes": "SPORK_Junction.py: uniformity_score log \";\" and allow within gene splicing"
          },
          {
            "sbg:revision": 70,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1553890095,
            "sbg:revisionNotes": "SPORK_Junction.py: get_fusion_type(): if chroms != \"local-intrachrom\": allow only fusions"
          },
          {
            "sbg:revision": 71,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1556053521,
            "sbg:revisionNotes": "list of genes added"
          },
          {
            "sbg:revision": 72,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1562427099,
            "sbg:revisionNotes": "allow within gene splicing as well"
          },
          {
            "sbg:revision": 73,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1563309848,
            "sbg:revisionNotes": "protect _don.fasta and _acc.fasta to have empty reads"
          }
        ],
        "sbg:cmdPreview": "python combine_files.py -djn /path/to/denovo_junctions_new-1.ext /path/to/denovo_junctions_new-2.ext -ct 8 -s SAMPLE_ID_2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "abg:revisionNotes": "SPORK_Junctions updated: add_duplicates: break-point added",
        "cwlVersion": "sbg:draft-2",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "collapse_threshold": 8,
            "gtfs_info_seq": {
              "secondaryFiles": [],
              "path": "/path/to/gtfs_info_seq.ext",
              "class": "File",
              "size": 0
            },
            "denovo_junctions_new": [
              {
                "secondaryFiles": [],
                "path": "/path/to/denovo_junctions_new-1.ext",
                "class": "File",
                "size": 0
              },
              {
                "metadata": {
                  "sample_id": "SAMPLE_ID_2"
                },
                "size": 0,
                "path": "/path/to/denovo_junctions_new-2.ext",
                "class": "File",
                "secondaryFiles": []
              }
            ]
          }
        },
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/spork-concatenate-files/73",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/spork-concatenate-files/73",
        "sbg:revision": 73,
        "sbg:revisionNotes": "protect _don.fasta and _acc.fasta to have empty reads",
        "sbg:modifiedOn": 1563309848,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1533115855,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 73,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a8cd4f5c9cf5590b9e604369d8262ee1952f339b54d3b585ecfceecbd6f3ef003",
        "x": 2543.3370965720696,
        "y": -114.9997714757835
      },
      "inputs": [
        {
          "id": "#SPORK_concatenate_files.gtfs_info_seq",
          "source": [
            "#gtfs_info_seq"
          ]
        },
        {
          "id": "#SPORK_concatenate_files.denovo_junctions_new",
          "source": [
            "#SPORK_Create_Junctions.denovo_junctions_new"
          ]
        },
        {
          "id": "#SPORK_concatenate_files.collapse_threshold",
          "default": 5,
          "source": [
            "#collapse_threshold"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SPORK_concatenate_files.used_read_ids"
        },
        {
          "id": "#SPORK_concatenate_files.fusion_junction_ids_new"
        },
        {
          "id": "#SPORK_concatenate_files.duplicate_junctions"
        },
        {
          "id": "#SPORK_concatenate_files.don_fasta"
        },
        {
          "id": "#SPORK_concatenate_files.denovo_junctions_all"
        },
        {
          "id": "#SPORK_concatenate_files.acc_fasta"
        }
      ],
      "sbg:x": 2543.3370965720696,
      "sbg:y": -114.9997714757835
    },
    {
      "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME",
      "run": {
        "class": "CommandLineTool",
        "label": "KNIFE Bowtie2-2.3.4.1 Aligner Input List GENOME",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String",
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ],
            "required": false
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 893.3334705564756,
        "y": -324.9479499239898,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3"
      },
      "inputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.unpaired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.unpaired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.trim_from_5"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.trim_from_3"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.threads",
          "default": 16
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.suppress_sam_records",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.suppress_header_lines"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.sort_sam",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.skip_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.set_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.set_match_bonus"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.seed_substring_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.seed_extension_attempts"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.report_k_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.report_all_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.reorder_output"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.read_sequence",
          "source": [
            "#fastq_files"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.quality_scale"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.preset_option"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.paired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.paired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.output_file_suffix",
          "default": "genome"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.omit_seq_and_qual"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.number_of_cpu",
          "default": 9
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.non_deterministic"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.minimum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.maximum_mismatch_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.maximum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.max_number_of_re_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.mates_alignment_orientation"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.integer_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.input_fasta_files"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.ignore_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.function_n_ceil"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.function_i"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.dynamic_padding"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.dont_align_reverse_complement"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.dont_align_forward"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.disallow_gaps"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.disable_unpaired_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.disable_overlapping_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.disable_dovetail_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.disable_discordant_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.disable_containing_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.disable_1_mismatch_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.constant_nceil_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.constant_i_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.coefficient_nceil_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.coefficient_i_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.ambiguous_character_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.allowed_mismatch_number"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.alignment_mode"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.unaligned_reads_only"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.result_sam_file"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.aligned_reads_only"
        }
      ],
      "sbg:x": 893.3334705564756,
      "sbg:y": -324.9479499239898,
      "scatter": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.read_sequence"
    },
    {
      "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL",
      "run": {
        "class": "CommandLineTool",
        "label": "KNIFE Bowtie2-2.3.4.1 Aligner Input List RIBOSOMAL",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String",
            "required": false
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ],
            "required": false
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ],
            "required": false
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ],
            "required": false
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 895.0002579026846,
        "y": -186.61464710823577,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3"
      },
      "inputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.unpaired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.unpaired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.trim_from_5"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.trim_from_3"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.threads",
          "default": 16
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.suppress_sam_records",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.suppress_header_lines"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.sort_sam",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.skip_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.set_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.set_match_bonus"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.seed_substring_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.seed_extension_attempts"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.report_k_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.report_all_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.reorder_output"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.read_sequence",
          "source": [
            "#fastq_files"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.quality_scale"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.preset_option"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.paired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.paired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.output_file_suffix",
          "default": "ribosomal"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.omit_seq_and_qual"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.number_of_cpu",
          "default": 5
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.non_deterministic"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.minimum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.maximum_mismatch_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.maximum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.max_number_of_re_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.mates_alignment_orientation"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.integer_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.input_fasta_files"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.ignore_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.function_n_ceil"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.function_i"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.dynamic_padding"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.dont_align_reverse_complement"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.dont_align_forward"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.disallow_gaps"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.disable_unpaired_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.disable_overlapping_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.disable_dovetail_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.disable_discordant_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.disable_containing_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.disable_1_mismatch_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.constant_nceil_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.constant_i_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.coefficient_nceil_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.coefficient_i_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_ribosomal"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.ambiguous_character_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.allowed_mismatch_number"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.alignment_mode"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.unaligned_reads_only"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.result_sam_file"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.aligned_reads_only"
        }
      ],
      "sbg:x": 895.0002579026846,
      "sbg:y": -186.61464710823577,
      "scatter": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.read_sequence"
    },
    {
      "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS",
      "run": {
        "class": "CommandLineTool",
        "label": "KNIFE Bowtie2-2.3.4.1 Aligner Input List REGULAR JUNCTIONS",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 888.3334083292241,
        "y": -58.28126133605871
      },
      "inputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.unpaired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.unpaired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.trim_from_5"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.trim_from_3"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.threads",
          "default": 16
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.suppress_sam_records",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.suppress_header_lines"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.sort_sam",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.skip_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.set_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.set_match_bonus"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.seed_substring_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.seed_extension_attempts"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.report_k_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.report_all_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.reorder_output"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.read_sequence",
          "source": [
            "#fastq_files"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.quality_scale"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.preset_option"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.paired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.paired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.output_file_suffix",
          "default": "regular"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.omit_seq_and_qual"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.number_of_cpu",
          "default": 7
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.non_deterministic"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.minimum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.maximum_mismatch_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.maximum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.max_number_of_re_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.mates_alignment_orientation"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.integer_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.input_fasta_files"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.ignore_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.function_i"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.dynamic_padding"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.dont_align_reverse_complement"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.dont_align_forward"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.disallow_gaps"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.disable_unpaired_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.disable_overlapping_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.disable_dovetail_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.disable_discordant_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.disable_containing_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.disable_1_mismatch_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.constant_i_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.coefficient_i_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_junctions"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.ambiguous_character_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.allowed_mismatch_number"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.alignment_mode"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.unaligned_reads_only"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.result_sam_file"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.aligned_reads_only"
        }
      ],
      "sbg:x": 888.3334083292241,
      "sbg:y": -58.28126133605871,
      "scatter": "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.read_sequence"
    },
    {
      "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS",
      "run": {
        "class": "CommandLineTool",
        "label": "KNIFE Bowtie2-2.3.4.1 Aligner Input List SCRAMBLED JUNCTIONS",
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ]
          }
        ],
        "inputs": [
          {
            "sbg:category": "Output",
            "id": "#unpaired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired unaligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#unpaired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Unpaired aligned reads",
            "type": [
              "null",
              {
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_5",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim5"
            },
            "label": "Trim from 5'",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:altPrefix": "-5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#trim_from_3",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--trim3"
            },
            "label": "Trim from 3'",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:altPrefix": "-3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sq_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-sq"
            },
            "label": "Suppress SQ header lines",
            "description": "Suppress @SQ SAM header lines.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_sam_records",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-unal"
            },
            "label": "Suppress SAM records for unaligned reads",
            "description": "Suppress SAM records for reads that failed to align.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#suppress_header_lines",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-hd"
            },
            "label": "Suppress header lines",
            "description": "Suppress SAM header lines (starting with @).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#sort_sam",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#skip_reads",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--skip"
            },
            "label": "Skip reads",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:altPrefix": "-s",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#set_seed",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seed"
            },
            "label": "Set seed",
            "description": "Set the seed for pseudo-random number generator.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#set_match_bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ma"
            },
            "label": "Set match bonus",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#seed_substring_length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "label": "Seed substring length",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#seed_extension_attempts",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "label": "Seed extension attempts",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_k_alignments",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "label": "Report k alignments",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Reporting",
            "id": "#report_all_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--all"
            },
            "label": "Report all alignments",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:altPrefix": "-a",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Performance",
            "id": "#reorder_output",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--reorder"
            },
            "label": "Reorder output",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#reference_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rfg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Reference gap penalties",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#read_sequence",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "label": "Read sequence",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "read_sequence",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#read_gap_penalties",
            "sbg:toolDefaultValue": "5,3",
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "--rdg",
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Read gap penalties",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#quality_scale",
            "sbg:toolDefaultValue": "Phred+33",
            "description": "Set quality scale.",
            "label": "Quality scale",
            "type": [
              "null",
              {
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Presets",
            "id": "#preset_option",
            "sbg:toolDefaultValue": "Sensitive",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Preset",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "type": [
              "null",
              {
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_unaligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired unaligned reads",
            "type": [
              "null",
              {
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Output",
            "id": "#paired_aligned_reads",
            "sbg:toolDefaultValue": "None",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "label": "Paired aligned reads",
            "type": [
              "null",
              {
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "description": "Output Suffix String.",
            "id": "#output_file_suffix",
            "type": [
              "null",
              "string"
            ],
            "label": "Output Suffix String"
          },
          {
            "sbg:category": "Output",
            "id": "#omit_seq_and_qual",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--omit-sec-seq"
            },
            "label": "Omit SEQ and QUAL",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "id": "#number_of_cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "label": "Number of cpu",
            "sbg:stageInput": null,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Other",
            "id": "#non_deterministic",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--non-deterministic"
            },
            "label": "Non deterministic",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#minimum_fragment_length",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--minins"
            },
            "label": "Minimum fragment length",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-I",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Scoring",
            "id": "#maximum_mismatch_penalty",
            "sbg:toolDefaultValue": "6",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mp"
            },
            "label": "Maximum mismatch penalty",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#maximum_fragment_length",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--maxins"
            },
            "label": "Maximum fragment length",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:altPrefix": "-X",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Effort",
            "id": "#max_number_of_re_seed",
            "sbg:toolDefaultValue": "2",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "label": "Max number of re-seed",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#mates_alignment_orientation",
            "sbg:toolDefaultValue": "--fr",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            },
            "label": "Mates alignment orientation",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "type": [
              "null",
              {
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#integer_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--int-quals"
            },
            "label": "Integer qualities",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "sbg:stageInput": null,
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#ignore_qualities",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--ignore-quals"
            },
            "label": "Ignore qualities",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#ignore_paired_end_metadata",
            "sbg:toolDefaultValue": "False",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "label": "Ignore paired_end metadata",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#function_score_min",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#function_n_ceil",
            "sbg:toolDefaultValue": "Linear",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#function_i",
            "sbg:toolDefaultValue": "Square-root",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "label": "Function type",
            "type": [
              "null",
              {
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dynamic_padding",
            "sbg:toolDefaultValue": "15",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--dpad"
            },
            "label": "Dynamic padding",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_reverse_complement",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--norc"
            },
            "label": "Don't align reverse complement",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#dont_align_forward",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--nofw"
            },
            "label": "Don't align forward",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disallow_gaps",
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--gbar"
            },
            "label": "Disallow gaps",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_unpaired_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-mixed"
            },
            "label": "Disable unpaired alignments",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_overlapping_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-overlap"
            },
            "label": "Disable overlapping alignments",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_dovetail_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-dovetail"
            },
            "label": "Disable dovetail alignments",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_discordant_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-discordant"
            },
            "label": "Disable discordant alignments",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Paired-end",
            "id": "#disable_containing_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-contain"
            },
            "label": "Disable containing alignments",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#disable_1_mismatch_alignments",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--no-1mm-upfront"
            },
            "label": "Disable 1 mismatch alignments",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#constant_scoremin_a",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#constant_nceil_a",
            "sbg:toolDefaultValue": "0",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Constant A",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#constant_i_a",
            "sbg:toolDefaultValue": "1",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "label": "Constant A",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Alignment score function",
            "id": "#coefficient_scoremin_b",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Ambiguous chars function",
            "id": "#coefficient_nceil_b",
            "sbg:toolDefaultValue": "0.15",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "label": "Coefficient B",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "sbg:category": "Interval function",
            "id": "#coefficient_i_b",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "label": "Coefficient B",
            "type": [
              "null",
              "float"
            ]
          },
          {
            "sbg:category": "Input files",
            "id": "#bowtie_index_archive",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "label": "Bowtie index archive",
            "sbg:stageInput": "link",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "sbg:category": "Scoring",
            "id": "#ambiguous_character_penalty",
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--np"
            },
            "label": "Ambiguous character penalty",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "sbg:stageInput": null,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#allowed_mismatch_number",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-N"
            },
            "label": "Allowed mismatch number",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "sbg:stageInput": null,
            "type": [
              "null",
              {
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Alignment",
            "id": "#alignment_mode",
            "sbg:toolDefaultValue": "End-to-end",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "label": "Alignment mode",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "type": [
              "null",
              {
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ],
                "type": "enum"
              }
            ]
          },
          {
            "sbg:category": "Input",
            "id": "#align_next_n_reads",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--upto"
            },
            "label": "Align next n reads",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:altPrefix": "-u",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*_unaligned*fastq",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#unaligned_reads_only",
            "description": "FASTQ file with reads that failed to align.",
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": "*.sam",
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#result_sam_file",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "glob": {
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:inheritMetadataFrom": "#read_sequence",
              "streamable": false
            },
            "id": "#aligned_reads_only",
            "description": "FASTQ file with reads that align at least once.",
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "baseCommand": [
          "bowtie2"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100,
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101,
            "prefix": "-S"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive[0].metadata.reference_genome\n  \n  return index_prefix\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-x"
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": ""
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 103,
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 102,
            "valueFrom": {
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 104,
            "valueFrom": {
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133237,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561133423,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561134083,
            "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner rev 4 copied + input list"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1561543136,
            "sbg:revisionNotes": "reference_genome metadata fixed"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:job": {
          "inputs": {
            "bowtie_index_archive": [
              {
                "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
                "secondaryFiles": [],
                "metadata": {
                  "reference_genome": "genome_name"
                }
              },
              {
                "path": "File"
              }
            ],
            "function_n_ceil": "Square-root",
            "quality_scale": "Phred+33",
            "number_of_cpu": 7,
            "allowed_mismatch_number": "0",
            "ignore_paired_end_metadata": false,
            "coefficient_scoremin_b": 0,
            "alignment_mode": "Local",
            "sort_sam": true,
            "constant_nceil_a": "0",
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "file_format": "fastq",
                  "quality_scale": "illumina15",
                  "paired_end": "1"
                }
              }
            ],
            "paired_aligned_reads": "gzip compressed",
            "suppress_sam_records": true,
            "function_i": "Linear",
            "read_gap_penalties": [
              0
            ],
            "unpaired_aligned_reads": "gzip compressed",
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "reference_gap_penalties": [
              0
            ],
            "paired_unaligned_reads": "raw",
            "unpaired_unaligned_reads": "gzip compressed",
            "disable_overlapping_alignments": false,
            "threads": 7,
            "coefficient_nceil_b": 4,
            "mates_alignment_orientation": "--rf",
            "preset_option": "Very fast",
            "constant_scoremin_a": "0",
            "constant_i_a": 0,
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "input_fasta_files": true,
            "output_file_suffix": "",
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "coefficient_i_b": 0
          },
          "allocatedResources": {
            "mem": 6000,
            "cpu": 7
          }
        },
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "cwlVersion": "sbg:draft-2",
        "sbg:links": [
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html",
            "label": "Publication"
          },
          {
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml",
            "label": "Manual"
          },
          {
            "id": "https://github.com/BenLangmead/bowtie2",
            "label": "Source Code"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:toolkit": "Bowtie2",
        "sbg:cmdPreview": "bowtie2 -x genome_name  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-aligner-input-list/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "reference_genome metadata fixed",
        "sbg:modifiedOn": 1561543136,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1561133237,
        "sbg:createdBy": "jordanski.milos",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7fbc77f2b1304f98afa2ce638483dd1c6dc903637bc620723149ba358e8e35df",
        "x": 891.6668445136874,
        "y": 73.38543229839922
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.unpaired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.unpaired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.trim_from_5"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.trim_from_3"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.threads",
          "default": 16
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.suppress_sam_records",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.suppress_header_lines"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.sort_sam"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.skip_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.set_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.set_match_bonus"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.seed_substring_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.seed_extension_attempts"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.report_k_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.report_all_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.reorder_output"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.read_sequence",
          "source": [
            "#fastq_files"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.quality_scale"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.preset_option"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.paired_unaligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.paired_aligned_reads"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.output_file_suffix",
          "default": "scrambled"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.omit_seq_and_qual"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.number_of_cpu",
          "default": 6
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.non_deterministic"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.minimum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.maximum_mismatch_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.maximum_fragment_length"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.max_number_of_re_seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.mates_alignment_orientation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.integer_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.input_fasta_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.ignore_qualities"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.function_i"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.dynamic_padding"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.dont_align_reverse_complement"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.dont_align_forward"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.disallow_gaps"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.disable_unpaired_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.disable_overlapping_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.disable_dovetail_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.disable_discordant_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.disable_containing_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.disable_1_mismatch_alignments"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.constant_i_a"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.coefficient_i_b"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_scrambled_junctions"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.ambiguous_character_penalty"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.allowed_mismatch_number"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.alignment_mode"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.unaligned_reads_only"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.result_sam_file"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.aligned_reads_only"
        }
      ],
      "sbg:x": 891.6668445136874,
      "sbg:y": 73.38543229839922,
      "scatter": "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.read_sequence"
    },
    {
      "id": "#Knife_Preprocess_Aligned_Reads",
      "run": {
        "inputs": [
          {
            "id": "#overlap",
            "required": false,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "id": "#output_name",
            "required": false,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "id": "#junction_midpoint",
            "required": false,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "id": "#input_sam",
            "required": true,
            "type": [
              "File"
            ]
          },
          {
            "id": "#aligned_reference",
            "required": true,
            "type": [
              {
                "symbols": [
                  "ribosomal",
                  "genome",
                  "regular",
                  "scrambled"
                ],
                "name": "aligned_reference",
                "type": "enum"
              }
            ]
          }
        ],
        "sbg:revisionNotes": "revision 4 copied",
        "stdout": "",
        "cwlVersion": "sbg:draft-2",
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \toutput_file_name = $job.inputs.input_sam.path.split(\"/\").pop()\n    output_file_name = output_file_name.slice(0, output_file_name.length - 4)\n  \tif ($job.inputs.output_name)\n    {\n    \toutput_file_name = $job.inputs.output_name\n    }\n\tif($job.inputs.aligned_reference == \"genome\" || $job.inputs.aligned_reference == \"ribosomal\")\n    {\n      \treturn \"awk '$1 !~ /^@/ && $2 != 4 {print $1  \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3 \\\"\\\\t\\\" $4}' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n  \telse if($job.inputs.aligned_reference == \"regular\" || $job.inputs.aligned_reference == \"scrambled\")\n    {\n    \treturn \"awk \\'$1 !~ /^@/ && $4 >= \" + $job.inputs.junction_midpoint + \" -length($10)+ \" + $job.inputs.overlap + \" +1 && $4 <= \" + $job.inputs.junction_midpoint + \"- \" + $job.inputs.overlap + \" +1 {print $1 \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3}\\' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n}"
            }
          }
        ],
        "label": "Knife Preprocess Aligned Reads",
        "temporaryFailCodes": [],
        "baseCommand": [
          ""
        ],
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:job": {
          "inputs": {
            "aligned_reference": "ribosomal",
            "overlap": 5,
            "output_name": "output_name-string-value",
            "input_sam": {
              "class": "File",
              "secondaryFiles": [],
              "size": 0,
              "path": "/path/to/input_sam.sam"
            },
            "junction_midpoint": 3
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#aligned_reads",
            "outputBinding": {
              "glob": "*.txt",
              "sbg:inheritMetadataFrom": "#input_sam"
            }
          }
        ],
        "sbg:cmdPreview": "awk '$1 !~ /^@/ && $2 != 4 {print $1  \"\\t\" $2 \"\\t\" $3 \"\\t\" $4}' /path/to/input_sam.sam > output_name-string-value.txt",
        "description": "",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "class": "CommandLineTool",
        "sbg:image_url": null,
        "successCodes": [],
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:publisher": "sbg",
        "stdin": "",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520442509,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520442544,
            "sbg:revisionNotes": "revision 4 copied"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "ubuntu"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:revision": 1,
        "sbg:modifiedOn": 1520442544,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:createdOn": 1520442509,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:latestRevision": 1,
        "sbg:content_hash": null,
        "x": 1041.6667488151147,
        "y": -324.9479192077284
      },
      "inputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads.overlap"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads.output_name"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads.junction_midpoint"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads.input_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.result_sam_file"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads.aligned_reference",
          "default": "genome"
        }
      ],
      "outputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads.aligned_reads"
        }
      ],
      "sbg:x": 1041.6667488151147,
      "sbg:y": -324.9479192077284,
      "scatter": "#Knife_Preprocess_Aligned_Reads.input_sam"
    },
    {
      "id": "#Knife_Preprocess_Aligned_Reads_1",
      "run": {
        "inputs": [
          {
            "id": "#overlap",
            "required": false,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "id": "#output_name",
            "required": false,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "id": "#junction_midpoint",
            "required": false,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "id": "#input_sam",
            "required": true,
            "type": [
              "File"
            ]
          },
          {
            "id": "#aligned_reference",
            "required": true,
            "type": [
              {
                "symbols": [
                  "ribosomal",
                  "genome",
                  "regular",
                  "scrambled"
                ],
                "name": "aligned_reference",
                "type": "enum"
              }
            ]
          }
        ],
        "sbg:revisionNotes": "revision 4 copied",
        "stdout": "",
        "cwlVersion": "sbg:draft-2",
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \toutput_file_name = $job.inputs.input_sam.path.split(\"/\").pop()\n    output_file_name = output_file_name.slice(0, output_file_name.length - 4)\n  \tif ($job.inputs.output_name)\n    {\n    \toutput_file_name = $job.inputs.output_name\n    }\n\tif($job.inputs.aligned_reference == \"genome\" || $job.inputs.aligned_reference == \"ribosomal\")\n    {\n      \treturn \"awk '$1 !~ /^@/ && $2 != 4 {print $1  \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3 \\\"\\\\t\\\" $4}' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n  \telse if($job.inputs.aligned_reference == \"regular\" || $job.inputs.aligned_reference == \"scrambled\")\n    {\n    \treturn \"awk \\'$1 !~ /^@/ && $4 >= \" + $job.inputs.junction_midpoint + \" -length($10)+ \" + $job.inputs.overlap + \" +1 && $4 <= \" + $job.inputs.junction_midpoint + \"- \" + $job.inputs.overlap + \" +1 {print $1 \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3}\\' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n}"
            }
          }
        ],
        "label": "Knife Preprocess Aligned Reads",
        "temporaryFailCodes": [],
        "baseCommand": [
          ""
        ],
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:job": {
          "inputs": {
            "aligned_reference": "ribosomal",
            "overlap": 5,
            "output_name": "output_name-string-value",
            "input_sam": {
              "class": "File",
              "secondaryFiles": [],
              "size": 0,
              "path": "/path/to/input_sam.sam"
            },
            "junction_midpoint": 3
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#aligned_reads",
            "outputBinding": {
              "glob": "*.txt",
              "sbg:inheritMetadataFrom": "#input_sam"
            }
          }
        ],
        "sbg:cmdPreview": "awk '$1 !~ /^@/ && $2 != 4 {print $1  \"\\t\" $2 \"\\t\" $3 \"\\t\" $4}' /path/to/input_sam.sam > output_name-string-value.txt",
        "description": "",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "class": "CommandLineTool",
        "sbg:image_url": null,
        "successCodes": [],
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:publisher": "sbg",
        "stdin": "",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520442509,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520442544,
            "sbg:revisionNotes": "revision 4 copied"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "ubuntu"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:revision": 1,
        "sbg:modifiedOn": 1520442544,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:createdOn": 1520442509,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:latestRevision": 1,
        "sbg:content_hash": null,
        "x": 1045.000082943177,
        "y": -188.2812574816248
      },
      "inputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.overlap"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.output_name"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.junction_midpoint"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.input_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.result_sam_file"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.aligned_reference",
          "default": "ribosomal"
        }
      ],
      "outputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.aligned_reads"
        }
      ],
      "sbg:x": 1045.000082943177,
      "sbg:y": -188.2812574816248,
      "scatter": "#Knife_Preprocess_Aligned_Reads_1.input_sam"
    },
    {
      "id": "#SBG_Prepare_Scatter_Trim",
      "run": {
        "inputs": [
          {
            "sbg:stageInput": null,
            "id": "#input_files",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          }
        ],
        "sbg:revisionNotes": "revision 3 copied",
        "stdout": "",
        "cwlVersion": "sbg:draft-2",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "\"\"\"\nUsage:\n    group_by_metadata.py\n\nDescription:\n    Prepare Input Files manipulates / creates an output list as group of files with the same metadata.\n\nOptions:\n\n    -h, --help            Show this message.\n\n    -v, -V, --version     Tool version.\n\"\"\"\n\nimport json\n\njob = \"\"\nwith open('job.json') as data_file:\n    job = json.load(data_file)\n\nif \"inputs\" in job and \"input_files\" in job[\"inputs\"]:\n    input_files = job[\"inputs\"][\"input_files\"]\nelse:\n    input_files = []\n\nfiles_1 = []\nfiles_2 = []\n\nfor file_list in input_files:\n    if file_list and not isinstance(file_list, list):\n        f=file_list\n        d = {'class': 'File'}\n        d['path'] = f[\"path\"]\n        print f\n        if \"size\" in f:\n            d['size'] = f[\"size\"]\n\n        if \"contents\" in f:\n            d['contents'] = f[\"contents\"]\n\n        if \"name\" in f:\n            d['name'] = f[\"name\"]\n\n        if \"checksum\" in f:\n            d['checksum'] = f[\"checksum\"]\n\n        if \"location\" in f:\n            d['location'] = f[\"location\"]\n\n        if \"metadata\" in f:\n            d['metadata'] = f[\"metadata\"]\n\n        if \"secondaryFiles\" in f:\n            d['secondaryFiles'] = f[\"secondaryFiles\"]\n\n        if \"metadata\" in f and \"paired_end\" in f[\"metadata\"] and f[\"metadata\"][\"paired_end\"] == \"1\":\n            files_1.append(d)\n        else:\n            files_2.append(d)\n\n    elif file_list:\n        for f in file_list:\n            print(f)\n            d = {'class': 'File'}\n            d['path'] = f[\"path\"]\n\n            if \"size\" in f:\n                d['size'] = f[\"size\"]\n\n            if \"contents\" in f:\n                d['contents'] = f[\"contents\"]\n\n            if \"name\" in f:\n                d['name'] = f[\"name\"]\n\n            if \"checksum\" in f:\n                d['checksum'] = f[\"checksum\"]\n\n            if \"location\" in f:\n                d['location'] = f[\"location\"]\n\n            if \"metadata\" in f:\n                d['metadata'] = f[\"metadata\"]\n\n            if \"secondaryFiles\" in f:\n                d['secondaryFiles'] = f[\"secondaryFiles\"]\n\n            if \"metadata\" in f and \"paired_end\" in f[\"metadata\"] and f[\"metadata\"][\"paired_end\"] == \"1\":\n                files_1.append(d)\n            else:\n                files_2.append(d)\n\ndata = {}\nif files_1:\n    data['output_files_1'] = files_1\n\nif files_2:\n    data['output_files_2'] = files_2\n\nwith open('cwl.output.json', 'w') as w:\n    json.dump(data, w)",
                "filename": "prepare_scatter.py"
              }
            ]
          }
        ],
        "arguments": [],
        "label": "SBG Prepare Scatter Trim",
        "temporaryFailCodes": [],
        "baseCommand": [
          "python",
          "prepare_scatter.py"
        ],
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:job": {
          "inputs": {
            "input_files": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-1.ext"
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-2.ext"
              }
            ]
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "outputs": [
          {
            "id": "#output_files_2",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          },
          {
            "id": "#output_files_1",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "sbg:cmdPreview": "python prepare_scatter.py",
        "description": "",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "class": "CommandLineTool",
        "sbg:image_url": null,
        "successCodes": [],
        "sbg:publisher": "sbg",
        "stdin": "",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432762,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432783,
            "sbg:revisionNotes": "revision 3 copied"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/sbg-prepare-scatter-trim/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/sbg-prepare-scatter-trim/1",
        "sbg:revision": 1,
        "sbg:modifiedOn": 1520432783,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:createdOn": 1520432762,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:latestRevision": 1,
        "sbg:content_hash": null,
        "x": 1441.6666848527054,
        "y": -159.94791459830304
      },
      "inputs": [
        {
          "id": "#SBG_Prepare_Scatter_Trim.input_files",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.result_sam_file",
            "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.result_sam_file",
            "#fastq_files",
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.result_sam_file",
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SBG_Prepare_Scatter_Trim.output_files_2"
        },
        {
          "id": "#SBG_Prepare_Scatter_Trim.output_files_1"
        }
      ],
      "sbg:x": 1441.6666848527054,
      "sbg:y": -159.94791459830304
    },
    {
      "id": "#getUnalignedReads_1",
      "run": {
        "inputs": [
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-n"
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ]
          },
          {
            "label": "Ntrim",
            "description": "Ntrim used in denovo pipeline.",
            "sbg:stageInput": null,
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-t"
            },
            "id": "#ntrim",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mode",
            "description": "\"Appended\" mode should be selected if read_ids in first mate ends with 1 and in the second. If reads have the same read_id in both paired_end files, \"complete\" should be selected.",
            "sbg:stageInput": null,
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-q"
            },
            "id": "#mode",
            "type": [
              "null",
              {
                "symbols": [
                  "appended",
                  "complete"
                ],
                "name": "mode",
                "type": "enum"
              }
            ],
            "sbg:includeInPorts": true,
            "required": false
          },
          {
            "label": "Mate input files",
            "description": "Mate fastq file and mate genome, ribosomal, regular and scrambled sam files.",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM, FASTQ",
            "sbg:stageInput": "link",
            "id": "#mate_input_files",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "label": "Input files",
            "description": "Fastq file, genome, ribosomal, regular and scrambled sam files.",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM, FASTQ",
            "id": "#input_files",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          }
        ],
        "sbg:revisionNotes": "revision 3 copied",
        "stdout": "",
        "cwlVersion": "sbg:draft-2",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# Creates a fasta and fastq file containing all reads for the sample that did not align to any of\n# the Bowtie2 indices in the directory \"orig/unaligned\". It also creates a fastq file under\n# \"orig/unaligned/forDenovoIndex\" that contains the subset of unaligned reads that are long\n# enough to be used for the de novo index (NTRIM + 8). This forDenovoIndex file had to be\n# created because Bowtie does not gracefully handle when a read gets trimmed to a negative length.\n#\n# This script is called by qualityStatsSingleSample.sh when the sampleStats reports are being generated,\n# so it returns the number of unaligned reads to be reported. This is the total number of unaligned reads,\n# not just those that were long enough to be used for the de novo index.\n\nimport argparse\nimport subprocess\nfrom ParseFastQ import ParseFastQ\nimport multiprocessing\nimport Queue\n\n\ndef addAlignedIds(samFile):\n    handle = open(samFile, \"rU\")\n\n    for line in handle:\n        if not line.startswith(\"@\"):  # ignore header lines\n            if args.fastqIdStyle == \"appended\":\n                aligned[line.strip().split()[0][:-1]] = None\n            else:\n                aligned[line.strip().split()[0]] = None\n\n    handle.close()\n\ndef RemoveIds(samFile, tmpSamFile):\n    handle = open(samFile, \"rU\")\n    output = open(tmpSamFile, \"w\")\n\n    for line in handle:\n        if line.startswith(\"@\"):\n            output.write(line)\n        elif args.fastqIdStyle == \"appended\" and line.strip().split()[0][:-1] not in aligned:\n            output.write(line)\n        elif args.fastqIdStyle == \"complete\" and line.strip().split()[0] not in aligned:\n            output.write(line)\n\n    handle.close()\n    output.close()\n\n    cmd = \"mv -f \" + tmpSamFile + \" \" + samFile\n    print(cmd)\n    subprocess.call(cmd, shell=True)\n\n\nif __name__ == \"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-r', '--readFile', help='path to fastq file containing reads you attempted to align',required=True)\n    #parser.add_argument('-r2', '--readFile2', help='path to fastq file 2 containing reads you attempted to align',required=True)\n\n    parser.add_argument('-s', '--sample', help='base name used in alignment output files', required=True)\n    parser.add_argument('-n', '--suffix', help='base name used in alignment output files', required=True)\n    parser.add_argument('-t', '--ntrim', help='ntrim used in denovo pipeline', type=int, required=True)\n\n    parser.add_argument('-v', '--verbose', help='print info about data obtained', action='store_true')\n\n    parser.add_argument('-q', '--fastqIdStyle', help='type of read ids used', required=True, choices=['appended', 'complete'])\n\n    parser.add_argument('-gens', '--genomeSAM', help = 'path to the genome SAM file', required=True)\n    parser.add_argument('-ribs', '--ribosomalSAM', help='path to the ribosomal SAM file', required=True)\n    parser.add_argument('-regs', '--regularSAM', help='path to the regular junction SAM file', required=True)\n    parser.add_argument('-scrs', '--scrambledSAM', help='path to the scrambled junction SAM file', required=True)\n\n    parser.add_argument('-gensm', '--genomeSAMMate', help = 'path to the genome mate SAM file', required=True)\n    parser.add_argument('-ribsm', '--ribosomalSAMMate', help='path to the ribosomal mate SAM file', required=True)\n    parser.add_argument('-regsm', '--regularSAMMate', help='path to the regular junction mate SAM file', required=True)\n    parser.add_argument('-scrsm', '--scrambledSAMMate', help='path to the scrambled junction mate SAM file', required=True)\n\n    args = parser.parse_args()\n\n    aligned = {}\n    unaligned = {}\n\n    #aligned2 = {}\n    #unaligned2 = {}\n\n    minReadLen = args.ntrim + 8  # we want to have at least 8 nt left after read is trimmed for denovo split reads\n\n    try:\n        # put each id from sam files in a dict\n\n\n        addAlignedIds(args.genomeSAM)\n        addAlignedIds(args.ribosomalSAM)\n        addAlignedIds(args.regularSAM)\n        addAlignedIds(args.scrambledSAM)\n\n        # get each id from fastq file, add it to a dict if not in the aligned dict\n        parser = ParseFastQ(args.readFile)\n        for (seqHeader, seqStr, qualHeader, qualStr) in parser:\n            if args.fastqIdStyle == \"appended\":\n                title = seqHeader.split()[0][1:-1]\n            else:\n                title = seqHeader.split()[0][1:]\n\n            if title not in aligned:\n                unaligned[seqHeader.split()[0][1:]] = (seqHeader, seqStr, qualHeader, qualStr)\n\n        # write list of unaligned ids to fasta and fastq files\n        out_handle = open(\"unaligned_\" + args.sample + \".\" + args.suffix + \".fasta\", \"wb\")\n        out_fq_handle = open(\"unaligned_\" + args.sample + \".\" + args.suffix + \".fq\", \"wb\")\n        out_denovo_handle = open(\"forDenovoIndex_unaligned_\" + args.suffix + \".fq\", \"wb\")\n        for id in unaligned.keys():\n            # fasta file\n            out_handle.write(\">\" + id + \"\\n\")\n            out_handle.write(unaligned[id][1] + \"\\n\")\n            # fastq file\n            out_fq_handle.write(\"%s\\n%s\\n%s\\n%s\\n\" % (unaligned[id][0], unaligned[id][1], unaligned[id][2], unaligned[id][3]))\n            # fastq file for denovo index\n            if len(unaligned[id][1]) >= minReadLen:\n                out_denovo_handle.write(\"%s\\n%s\\n%s\\n%s\\n\" % (unaligned[id][0], unaligned[id][1], unaligned[id][2], unaligned[id][3]))\n\n        out_handle.close()\n        out_fq_handle.close()\n        out_denovo_handle.close()\n\n        # return size of unaligned dict\n        print len(unaligned)\n    except Exception as e:\n        print \"Exception:\", e\n\n    procs = []\n    try:\n        p_genome_mate = multiprocessing.Process(target=RemoveIds, args=(args.genomeSAMMate, \"tmp_genome.sam\"))\n        procs.append(p_genome_mate)\n        p_genome_mate.start()\n        #p_genome_mate.join()\n\n        p_ribosomal_mate = multiprocessing.Process(target=RemoveIds, args=(args.ribosomalSAMMate, \"tmp_ribosomal.sam\"))\n        procs.append(p_ribosomal_mate)\n        p_ribosomal_mate.start()\n        #p_ribosomal_mate.join()\n\n        p_regular_mate = multiprocessing.Process(target=RemoveIds, args=(args.regularSAMMate, \"tmp_regular.sam\"))\n        procs.append(p_regular_mate)\n        p_regular_mate.start()\n        #p_regular_mate.join()\n\n        p_scambled_mate = multiprocessing.Process(target=RemoveIds, args=(args.scrambledSAMMate, \"tmp_scrambled.sam\"))\n        procs.append(p_scambled_mate)\n        p_scambled_mate.start()\n        #p_scambled_mate.join()\n\n        for p in procs:\n            p.join()\n\n        #RemoveIds(args.genomeSAMMate, \"tmp_genome.sam\")\n        #RemoveIds(args.ribosomalSAMMate, \"tmp_ribosomal.sam\")\n        #RemoveIds(args.regularSAMMate, \"tmp_regular.sam\")\n        #RemoveIds(args.scrambledSAMMate, \"tmp_scrambled.sam\")\n    except Exception as e:\n        print \"Exception:\", e",
                "filename": "getUnalignedReadCount.py"
              },
              {
                "fileContent": "import gzip\n\n\nclass ParseFastQ(object):\n    \"\"\"Returns a read-by-read fastQ parser analogous to file.readline()\"\"\"\n\n    def __init__(self, filePath, headerSymbols=['@', '+']):\n        \"\"\"Returns a read-by-read fastQ parser analogous to file.readline().\n        Exmpl: parser.next()\n        -OR-\n        Its an iterator so you can do:\n        for rec in parser:\n            ... do something with rec ...\n\n        rec is tuple: (seqHeader,seqStr,qualHeader,qualStr)\n        \"\"\"\n        if filePath.endswith('.gz'):\n            self._file = gzip.open(filePath)\n        else:\n            self._file = open(filePath, 'rU')\n        self._currentLineNumber = 0\n        self._hdSyms = headerSymbols\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        \"\"\"Reads in next element, parses, and does minimal verification.\n        Returns: tuple: (seqHeader,seqStr,qualHeader,qualStr)\"\"\"\n        # ++++ Get Next Four Lines ++++\n        elemList = []\n        for i in range(4):\n            line = self._file.readline()\n            self._currentLineNumber += 1  ## increment file position\n            if line:\n                elemList.append(line.strip('\\n'))\n            else:\n                elemList.append(None)\n\n        # ++++ Check Lines For Expected Form ++++\n        trues = [bool(x) for x in elemList].count(True)\n        nones = elemList.count(None)\n        # -- Check for acceptable end of file --\n        if nones == 4:\n            raise StopIteration\n        # -- Make sure we got 4 full lines of data --\n        assert trues == 4, \\\n            \"** ERROR: It looks like I encountered a premature EOF or empty line.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._currentLineNumber)\n        # -- Make sure we are in the correct \"register\" --\n        assert elemList[0].startswith(self._hdSyms[0]), \\\n            \"** ERROR: The 1st line in fastq element does not start with '%s'.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._hdSyms[0], self._currentLineNumber)\n        assert elemList[2].startswith(self._hdSyms[1]), \\\n            \"** ERROR: The 3rd line in fastq element does not start with '%s'.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._hdSyms[1], self._currentLineNumber)\n        # -- Make sure the seq line and qual line have equal lengths --\n        assert len(elemList[1]) == len(elemList[3]), \"** ERROR: The length of Sequence data and Quality data of the last record aren't equal.\\n\\\n               Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n        self._currentLineNumber)\n\n        # ++++ Return fatsQ data as tuple ++++\n        return tuple(elemList)",
                "filename": "ParseFastQ.py"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n\tinput_files = [].concat($job.inputs.input_files)\n    for(i = 0; i < input_files.length; i++)\n    {\n    \tif(input_files[i].path.indexOf(\"regular\") !== -1)\n        {\n          cmd += \" -regs \" + input_files[i].path\n          continue\n        }\n        if(input_files[i].path.indexOf(\"scrambled\") !== -1)\n        {\n          cmd += \" -scrs \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"genome\") !== -1)\n        {\n          cmd += \" -gens \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"ribosomal\") !== -1)\n        {\n          cmd += \" -ribs \" + input_files[i].path\n          continue\n        }\n      \telse\n        {\n        \tcmd += \" -r \" + input_files[i].path\n        }\n      \n    }\n  \treturn cmd\n}"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    for(i = 0; i < input_files.length; i++)\n    {\n    \tif(input_files[i].path.indexOf(\"regular\") !== -1)\n        {\n          cmd += \" -regsm \" + input_files[i].path\n          continue\n        }\n        if(input_files[i].path.indexOf(\"scrambled\") !== -1)\n        {\n          cmd += \" -scrsm \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"genome\") !== -1)\n        {\n          cmd += \" -gensm \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"ribosomal\") !== -1)\n        {\n          cmd += \" -ribsm \" + input_files[i].path\n          continue\n        }\n      \n    }\n  \treturn cmd\n}"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.input_files)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}"
            }
          }
        ],
        "label": "getUnalignedReads_1",
        "temporaryFailCodes": [],
        "baseCommand": [
          "python",
          "getUnalignedReadCount.py"
        ],
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:job": {
          "inputs": {
            "mode": "appended",
            "input_files": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-ribosomal.ext",
                "metadata": {
                  "sample_id": "sample_name",
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-genome.ext"
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-regular.ext"
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-scrambled.ext"
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files.ext"
              }
            ],
            "ntrim": 2,
            "suffix": "output_name-string-value",
            "mate_input_files": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files-ribosomal.ext",
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files-genome.ext",
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files-regular.ext",
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files-scrambled.ext",
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files.ext",
                "metadata": {
                  "case_id": "1"
                }
              }
            ]
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 3000
          }
        },
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#unaligned_fastq",
            "outputBinding": {
              "glob": "unaligned_*.fq",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#unaligned_fasta",
            "outputBinding": {
              "glob": "unaligned_*fasta",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_scrambled_sam",
            "outputBinding": {
              "glob": "*scrambled.sam",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_ribosomal_sam",
            "outputBinding": {
              "glob": "*ribosomal.sam",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_regular_sam",
            "outputBinding": {
              "glob": "*regular_sorted.sam",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_genome_sam",
            "outputBinding": {
              "glob": "*genome_sorted.sam",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}"
                }
              }
            }
          },
          {
            "label": "ForDenovoIndex unaligned reads",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "FQ, FASTQ",
            "id": "#denovo_unaligned",
            "outputBinding": {
              "glob": "forDenovoIndex_unaligned*.fq",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}"
                }
              }
            }
          }
        ],
        "sbg:links": [
          {
            "label": "Publication",
            "id": "https://academic.oup.com/nar/article-lookup/doi/10.1093/nar/gkx453"
          }
        ],
        "sbg:cmdPreview": "python getUnalignedReadCount.py   -ribs /path/to/input_files-ribosomal.ext -gens /path/to/input_files-genome.ext -regs /path/to/input_files-regular.ext -scrs /path/to/input_files-scrambled.ext -r /path/to/input_files.ext   -ribsm /path/to/mate_input_files-ribosomal.ext -gensm /path/to/mate_input_files-genome.ext -regsm /path/to/mate_input_files-regular.ext -scrsm /path/to/mate_input_files-scrambled.ext  -s sample_name",
        "description": "Tool getUnalignedReads takes as input fastq file, ribosomal, genome, regular and scrambled junctions sam files of one read and ribosomal, genome, regular and scrambled junctions sam files for its mates and outputs the following files:\n\n1. unaligned\\_fastq file: all reads that are not aligned neither to ribosomal, genome, regular nor scrambled junctions.\n2. unaligned\\_fasta file: same as unaligned_fastq file, but in fasta format without qualities.\n3. mate\\_genome\\_sam: sam file contains only lines from mate genome sam file for which read_id is in unaligned\\_fastq\\_file.\n4. mate\\_ribosomal\\_sam: sam file contains only lines from mate ribosomal sam file for which read_id is in unaligned\\_fastq\\_file.\n5. mate\\_regular\\_sam: sam file contains only lines from mate regular sam file for which read_id is in unaligned\\_fastq\\_file.\n6. mate\\_scrambled\\_sam: sam file contains only lines from mate scrambled sam file for which read_id is in unaligned\\_fastq\\_file.",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "class": "CommandLineTool",
        "sbg:image_url": null,
        "successCodes": [],
        "sbg:categories": [
          "RNA"
        ],
        "sbg:publisher": "sbg",
        "stdin": "",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432843,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432864,
            "sbg:revisionNotes": "revision 3 copied"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 3000
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "c4.8xlarge;ebs-gp2;1024"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/getunalignedreads/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/getunalignedreads/1",
        "sbg:revision": 1,
        "sbg:modifiedOn": 1520432864,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:createdOn": 1520432843,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:latestRevision": 1,
        "sbg:content_hash": null,
        "x": 1590.001201245566,
        "y": 15.051883143261392
      },
      "inputs": [
        {
          "id": "#getUnalignedReads_1.suffix",
          "default": "_1"
        },
        {
          "id": "#getUnalignedReads_1.ntrim",
          "default": 50
        },
        {
          "id": "#getUnalignedReads_1.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#getUnalignedReads_1.mate_input_files",
          "source": [
            "#SBG_Prepare_Scatter_Trim.output_files_2"
          ]
        },
        {
          "id": "#getUnalignedReads_1.input_files",
          "source": [
            "#SBG_Prepare_Scatter_Trim.output_files_1"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#getUnalignedReads_1.unaligned_fastq"
        },
        {
          "id": "#getUnalignedReads_1.unaligned_fasta"
        },
        {
          "id": "#getUnalignedReads_1.mate_scrambled_sam"
        },
        {
          "id": "#getUnalignedReads_1.mate_ribosomal_sam"
        },
        {
          "id": "#getUnalignedReads_1.mate_regular_sam"
        },
        {
          "id": "#getUnalignedReads_1.mate_genome_sam"
        },
        {
          "id": "#getUnalignedReads_1.denovo_unaligned"
        }
      ],
      "sbg:x": 1590.001201245566,
      "sbg:y": 15.051883143261392
    },
    {
      "id": "#getUnalignedReads_2",
      "run": {
        "inputs": [
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-n"
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ]
          },
          {
            "label": "Ntrim",
            "description": "Ntrim used in denovo pipeline.",
            "sbg:stageInput": null,
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-t"
            },
            "id": "#ntrim",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mode",
            "description": "\"Appended\" mode should be selected if read_ids in first mate ends with 1 and in the second. If reads have the same read_id in both paired_end files, \"complete\" should be selected.",
            "sbg:stageInput": null,
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-q"
            },
            "id": "#mode",
            "type": [
              "null",
              {
                "symbols": [
                  "appended",
                  "complete"
                ],
                "name": "mode",
                "type": "enum"
              }
            ],
            "sbg:includeInPorts": true,
            "required": false
          },
          {
            "label": "Mate input files",
            "description": "Mate fastq file and mate genome, ribosomal, regular and scrambled sam files.",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM, FASTQ",
            "sbg:stageInput": "link",
            "id": "#mate_input_files",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          },
          {
            "label": "Input files",
            "description": "Fastq file, genome, ribosomal, regular and scrambled sam files.",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM, FASTQ",
            "id": "#input_files",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": false
          }
        ],
        "sbg:revisionNotes": "revision 3 copied",
        "stdout": "",
        "cwlVersion": "sbg:draft-2",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "# Creates a fasta and fastq file containing all reads for the sample that did not align to any of\n# the Bowtie2 indices in the directory \"orig/unaligned\". It also creates a fastq file under\n# \"orig/unaligned/forDenovoIndex\" that contains the subset of unaligned reads that are long\n# enough to be used for the de novo index (NTRIM + 8). This forDenovoIndex file had to be\n# created because Bowtie does not gracefully handle when a read gets trimmed to a negative length.\n#\n# This script is called by qualityStatsSingleSample.sh when the sampleStats reports are being generated,\n# so it returns the number of unaligned reads to be reported. This is the total number of unaligned reads,\n# not just those that were long enough to be used for the de novo index.\n\nimport argparse\nimport subprocess\nfrom ParseFastQ import ParseFastQ\nimport multiprocessing\nimport Queue\n\n\ndef addAlignedIds(samFile):\n    handle = open(samFile, \"rU\")\n\n    for line in handle:\n        if not line.startswith(\"@\"):  # ignore header lines\n            if args.fastqIdStyle == \"appended\":\n                aligned[line.strip().split()[0][:-1]] = None\n            else:\n                aligned[line.strip().split()[0]] = None\n\n    handle.close()\n\ndef RemoveIds(samFile, tmpSamFile):\n    handle = open(samFile, \"rU\")\n    output = open(tmpSamFile, \"w\")\n\n    for line in handle:\n        if line.startswith(\"@\"):\n            output.write(line)\n        elif args.fastqIdStyle == \"appended\" and line.strip().split()[0][:-1] not in aligned:\n            output.write(line)\n        elif args.fastqIdStyle == \"complete\" and line.strip().split()[0] not in aligned:\n            output.write(line)\n\n    handle.close()\n    output.close()\n\n    cmd = \"mv -f \" + tmpSamFile + \" \" + samFile\n    print(cmd)\n    subprocess.call(cmd, shell=True)\n\n\nif __name__ == \"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-r', '--readFile', help='path to fastq file containing reads you attempted to align',required=True)\n    #parser.add_argument('-r2', '--readFile2', help='path to fastq file 2 containing reads you attempted to align',required=True)\n\n    parser.add_argument('-s', '--sample', help='base name used in alignment output files', required=True)\n    parser.add_argument('-n', '--suffix', help='base name used in alignment output files', required=True)\n    parser.add_argument('-t', '--ntrim', help='ntrim used in denovo pipeline', type=int, required=True)\n\n    parser.add_argument('-v', '--verbose', help='print info about data obtained', action='store_true')\n\n    parser.add_argument('-q', '--fastqIdStyle', help='type of read ids used', required=True, choices=['appended', 'complete'])\n\n    parser.add_argument('-gens', '--genomeSAM', help = 'path to the genome SAM file', required=True)\n    parser.add_argument('-ribs', '--ribosomalSAM', help='path to the ribosomal SAM file', required=True)\n    parser.add_argument('-regs', '--regularSAM', help='path to the regular junction SAM file', required=True)\n    parser.add_argument('-scrs', '--scrambledSAM', help='path to the scrambled junction SAM file', required=True)\n\n    parser.add_argument('-gensm', '--genomeSAMMate', help = 'path to the genome mate SAM file', required=True)\n    parser.add_argument('-ribsm', '--ribosomalSAMMate', help='path to the ribosomal mate SAM file', required=True)\n    parser.add_argument('-regsm', '--regularSAMMate', help='path to the regular junction mate SAM file', required=True)\n    parser.add_argument('-scrsm', '--scrambledSAMMate', help='path to the scrambled junction mate SAM file', required=True)\n\n    args = parser.parse_args()\n\n    aligned = {}\n    unaligned = {}\n\n    #aligned2 = {}\n    #unaligned2 = {}\n\n    minReadLen = args.ntrim + 8  # we want to have at least 8 nt left after read is trimmed for denovo split reads\n\n    try:\n        # put each id from sam files in a dict\n\n\n        addAlignedIds(args.genomeSAM)\n        addAlignedIds(args.ribosomalSAM)\n        addAlignedIds(args.regularSAM)\n        addAlignedIds(args.scrambledSAM)\n\n        # get each id from fastq file, add it to a dict if not in the aligned dict\n        parser = ParseFastQ(args.readFile)\n        for (seqHeader, seqStr, qualHeader, qualStr) in parser:\n            if args.fastqIdStyle == \"appended\":\n                title = seqHeader.split()[0][1:-1]\n            else:\n                title = seqHeader.split()[0][1:]\n\n            if title not in aligned:\n                unaligned[seqHeader.split()[0][1:]] = (seqHeader, seqStr, qualHeader, qualStr)\n\n        # write list of unaligned ids to fasta and fastq files\n        out_handle = open(\"unaligned_\" + args.sample + \".\" + args.suffix + \".fasta\", \"wb\")\n        out_fq_handle = open(\"unaligned_\" + args.sample + \".\" + args.suffix + \".fq\", \"wb\")\n        out_denovo_handle = open(\"forDenovoIndex_unaligned_\" + args.suffix + \".fq\", \"wb\")\n        for id in unaligned.keys():\n            # fasta file\n            out_handle.write(\">\" + id + \"\\n\")\n            out_handle.write(unaligned[id][1] + \"\\n\")\n            # fastq file\n            out_fq_handle.write(\"%s\\n%s\\n%s\\n%s\\n\" % (unaligned[id][0], unaligned[id][1], unaligned[id][2], unaligned[id][3]))\n            # fastq file for denovo index\n            if len(unaligned[id][1]) >= minReadLen:\n                out_denovo_handle.write(\"%s\\n%s\\n%s\\n%s\\n\" % (unaligned[id][0], unaligned[id][1], unaligned[id][2], unaligned[id][3]))\n\n        out_handle.close()\n        out_fq_handle.close()\n        out_denovo_handle.close()\n\n        # return size of unaligned dict\n        print len(unaligned)\n    except Exception as e:\n        print \"Exception:\", e\n\n    procs = []\n    try:\n        p_genome_mate = multiprocessing.Process(target=RemoveIds, args=(args.genomeSAMMate, \"tmp_genome.sam\"))\n        procs.append(p_genome_mate)\n        p_genome_mate.start()\n        #p_genome_mate.join()\n\n        p_ribosomal_mate = multiprocessing.Process(target=RemoveIds, args=(args.ribosomalSAMMate, \"tmp_ribosomal.sam\"))\n        procs.append(p_ribosomal_mate)\n        p_ribosomal_mate.start()\n        #p_ribosomal_mate.join()\n\n        p_regular_mate = multiprocessing.Process(target=RemoveIds, args=(args.regularSAMMate, \"tmp_regular.sam\"))\n        procs.append(p_regular_mate)\n        p_regular_mate.start()\n        #p_regular_mate.join()\n\n        p_scambled_mate = multiprocessing.Process(target=RemoveIds, args=(args.scrambledSAMMate, \"tmp_scrambled.sam\"))\n        procs.append(p_scambled_mate)\n        p_scambled_mate.start()\n        #p_scambled_mate.join()\n\n        for p in procs:\n            p.join()\n\n        #RemoveIds(args.genomeSAMMate, \"tmp_genome.sam\")\n        #RemoveIds(args.ribosomalSAMMate, \"tmp_ribosomal.sam\")\n        #RemoveIds(args.regularSAMMate, \"tmp_regular.sam\")\n        #RemoveIds(args.scrambledSAMMate, \"tmp_scrambled.sam\")\n    except Exception as e:\n        print \"Exception:\", e",
                "filename": "getUnalignedReadCount.py"
              },
              {
                "fileContent": "import gzip\n\n\nclass ParseFastQ(object):\n    \"\"\"Returns a read-by-read fastQ parser analogous to file.readline()\"\"\"\n\n    def __init__(self, filePath, headerSymbols=['@', '+']):\n        \"\"\"Returns a read-by-read fastQ parser analogous to file.readline().\n        Exmpl: parser.next()\n        -OR-\n        Its an iterator so you can do:\n        for rec in parser:\n            ... do something with rec ...\n\n        rec is tuple: (seqHeader,seqStr,qualHeader,qualStr)\n        \"\"\"\n        if filePath.endswith('.gz'):\n            self._file = gzip.open(filePath)\n        else:\n            self._file = open(filePath, 'rU')\n        self._currentLineNumber = 0\n        self._hdSyms = headerSymbols\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        \"\"\"Reads in next element, parses, and does minimal verification.\n        Returns: tuple: (seqHeader,seqStr,qualHeader,qualStr)\"\"\"\n        # ++++ Get Next Four Lines ++++\n        elemList = []\n        for i in range(4):\n            line = self._file.readline()\n            self._currentLineNumber += 1  ## increment file position\n            if line:\n                elemList.append(line.strip('\\n'))\n            else:\n                elemList.append(None)\n\n        # ++++ Check Lines For Expected Form ++++\n        trues = [bool(x) for x in elemList].count(True)\n        nones = elemList.count(None)\n        # -- Check for acceptable end of file --\n        if nones == 4:\n            raise StopIteration\n        # -- Make sure we got 4 full lines of data --\n        assert trues == 4, \\\n            \"** ERROR: It looks like I encountered a premature EOF or empty line.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._currentLineNumber)\n        # -- Make sure we are in the correct \"register\" --\n        assert elemList[0].startswith(self._hdSyms[0]), \\\n            \"** ERROR: The 1st line in fastq element does not start with '%s'.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._hdSyms[0], self._currentLineNumber)\n        assert elemList[2].startswith(self._hdSyms[1]), \\\n            \"** ERROR: The 3rd line in fastq element does not start with '%s'.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._hdSyms[1], self._currentLineNumber)\n        # -- Make sure the seq line and qual line have equal lengths --\n        assert len(elemList[1]) == len(elemList[3]), \"** ERROR: The length of Sequence data and Quality data of the last record aren't equal.\\n\\\n               Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n        self._currentLineNumber)\n\n        # ++++ Return fatsQ data as tuple ++++\n        return tuple(elemList)",
                "filename": "ParseFastQ.py"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n\tinput_files = [].concat($job.inputs.input_files)\n    for(i = 0; i < input_files.length; i++)\n    {\n    \tif(input_files[i].path.indexOf(\"regular\") !== -1)\n        {\n          cmd += \" -regs \" + input_files[i].path\n          continue\n        }\n        if(input_files[i].path.indexOf(\"scrambled\") !== -1)\n        {\n          cmd += \" -scrs \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"genome\") !== -1)\n        {\n          cmd += \" -gens \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"ribosomal\") !== -1)\n        {\n          cmd += \" -ribs \" + input_files[i].path\n          continue\n        }\n      \telse\n        {\n        \tcmd += \" -r \" + input_files[i].path\n        }\n      \n    }\n  \treturn cmd\n}"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    for(i = 0; i < input_files.length; i++)\n    {\n    \tif(input_files[i].path.indexOf(\"regular\") !== -1)\n        {\n          cmd += \" -regsm \" + input_files[i].path\n          continue\n        }\n        if(input_files[i].path.indexOf(\"scrambled\") !== -1)\n        {\n          cmd += \" -scrsm \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"genome\") !== -1)\n        {\n          cmd += \" -gensm \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"ribosomal\") !== -1)\n        {\n          cmd += \" -ribsm \" + input_files[i].path\n          continue\n        }\n      \n    }\n  \treturn cmd\n}"
            }
          },
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.input_files)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}"
            }
          }
        ],
        "label": "getUnalignedReads_2",
        "temporaryFailCodes": [],
        "baseCommand": [
          "python",
          "getUnalignedReadCount.py"
        ],
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:job": {
          "inputs": {
            "mode": "appended",
            "input_files": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-ribosomal.ext",
                "metadata": {
                  "sample_id": "sample_name",
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-genome.ext"
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-regular.ext"
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files-scrambled.ext"
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/input_files.ext"
              }
            ],
            "ntrim": 2,
            "suffix": "output_name-string-value",
            "mate_input_files": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files-ribosomal.ext",
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files-genome.ext",
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files-regular.ext",
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files-scrambled.ext",
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/mate_input_files.ext",
                "metadata": {
                  "case_id": "1"
                }
              }
            ]
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 3000
          }
        },
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#unaligned_fastq",
            "outputBinding": {
              "glob": "unaligned_*.fq",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#unaligned_fasta",
            "outputBinding": {
              "glob": "unaligned_*fasta",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_scrambled_sam",
            "outputBinding": {
              "glob": "*scrambled.sam",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_ribosomal_sam",
            "outputBinding": {
              "glob": "*ribosomal.sam",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_regular_sam",
            "outputBinding": {
              "glob": "*regular_sorted.sam",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}"
                }
              }
            }
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_genome_sam",
            "outputBinding": {
              "glob": "*genome_sorted.sam",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}"
                }
              }
            }
          },
          {
            "label": "ForDenovoIndex unaligned reads",
            "type": [
              "null",
              "File"
            ],
            "sbg:fileTypes": "FQ, FASTQ",
            "id": "#denovo_unaligned",
            "outputBinding": {
              "glob": "forDenovoIndex_unaligned*.fq",
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}"
                },
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}"
                }
              }
            }
          }
        ],
        "sbg:links": [
          {
            "label": "Publication",
            "id": "https://academic.oup.com/nar/article-lookup/doi/10.1093/nar/gkx453"
          }
        ],
        "sbg:cmdPreview": "python getUnalignedReadCount.py   -ribs /path/to/input_files-ribosomal.ext -gens /path/to/input_files-genome.ext -regs /path/to/input_files-regular.ext -scrs /path/to/input_files-scrambled.ext -r /path/to/input_files.ext   -ribsm /path/to/mate_input_files-ribosomal.ext -gensm /path/to/mate_input_files-genome.ext -regsm /path/to/mate_input_files-regular.ext -scrsm /path/to/mate_input_files-scrambled.ext  -s sample_name",
        "description": "Tool getUnalignedReads takes as input fastq file, ribosomal, genome, regular and scrambled junctions sam files of one read and ribosomal, genome, regular and scrambled junctions sam files for its mates and outputs the following files:\n\n1. unaligned\\_fastq file: all reads that are not aligned neither to ribosomal, genome, regular nor scrambled junctions.\n2. unaligned\\_fasta file: same as unaligned_fastq file, but in fasta format without qualities.\n3. mate\\_genome\\_sam: sam file contains only lines from mate genome sam file for which read_id is in unaligned\\_fastq\\_file.\n4. mate\\_ribosomal\\_sam: sam file contains only lines from mate ribosomal sam file for which read_id is in unaligned\\_fastq\\_file.\n5. mate\\_regular\\_sam: sam file contains only lines from mate regular sam file for which read_id is in unaligned\\_fastq\\_file.\n6. mate\\_scrambled\\_sam: sam file contains only lines from mate scrambled sam file for which read_id is in unaligned\\_fastq\\_file.",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "class": "CommandLineTool",
        "sbg:image_url": null,
        "successCodes": [],
        "sbg:categories": [
          "RNA"
        ],
        "sbg:publisher": "sbg",
        "stdin": "",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432843,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432864,
            "sbg:revisionNotes": "revision 3 copied"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 3000
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "c4.8xlarge;ebs-gp2;1024"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/getunalignedreads/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/getunalignedreads/1",
        "sbg:revision": 1,
        "sbg:modifiedOn": 1520432864,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:createdOn": 1520432843,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:latestRevision": 1,
        "sbg:content_hash": null,
        "x": 1593.335557527099,
        "y": -316.6147992987683
      },
      "inputs": [
        {
          "id": "#getUnalignedReads_2.suffix",
          "default": "_2"
        },
        {
          "id": "#getUnalignedReads_2.ntrim",
          "default": 50
        },
        {
          "id": "#getUnalignedReads_2.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#getUnalignedReads_2.mate_input_files",
          "source": [
            "#SBG_Prepare_Scatter_Trim.output_files_1"
          ]
        },
        {
          "id": "#getUnalignedReads_2.input_files",
          "source": [
            "#SBG_Prepare_Scatter_Trim.output_files_2"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#getUnalignedReads_2.unaligned_fastq"
        },
        {
          "id": "#getUnalignedReads_2.unaligned_fasta"
        },
        {
          "id": "#getUnalignedReads_2.mate_scrambled_sam"
        },
        {
          "id": "#getUnalignedReads_2.mate_ribosomal_sam"
        },
        {
          "id": "#getUnalignedReads_2.mate_regular_sam"
        },
        {
          "id": "#getUnalignedReads_2.mate_genome_sam"
        },
        {
          "id": "#getUnalignedReads_2.denovo_unaligned"
        }
      ],
      "sbg:x": 1593.335557527099,
      "sbg:y": -316.6147992987683
    },
    {
      "id": "#KNIFE_GLM_model",
      "run": {
        "class": "CommandLineTool",
        "label": "KNIFE GLM model",
        "description": "GLM model fits logistic generalized linear model (GLM) model in order to predict probability that a paired-end read is a \"decoy\" read. GLM uses five predictors — alignment scores of read 1 and read 2 (a composite of sequencing quality and mismatch rate), mapping quality of read 1 and read 2, and offset position to predict the response variable, which is the binary set of class labels (class 1 or 2). Class 1 is a set of \"linear\" reads while class 2 is a set of \"decoy\" reads. In KNIFE, the GLM predicts the probability that each circular read belongs to class 1 (true positive) versus class 2 (false positive). \n\nThe GLM was fit with the larger class downweighted so that each class had equal influence in the model. All reads within a class were initially weighted equally. After fitting this model, the weights of reads with poor fit to the model were downweighted in proportion to their lack of fit, maintaining the constraint that, together, reads in each class had equal total weight. The model was then fit again to the dataset using the modified weights to obtain the final estimates of the five coefficients in the GLM and their statistical significance. This model is used to predict the probability of class membership in the independent set of reads with paired-end alignments consistent with being generated from circular RNA.\n\nThe next step of the algorithm is quantification of each putative junction via Bayesian hypothesis testing. For each junction, the posterior probability that junction-spanning reads, in aggregate, had a statistical profile consistent with decoy reads is computed , which would suggest they are artifacts versus those from linear splice junctions, which would suggest they are real. The posterior probability is the conditional probability that a junction is a true positive conditioned on one of two scenarios: reads from the junction are all decoys or all true positives.\n\nAfter estimating the predicted probabilities of each read, a p value for the posterior probability of a junction is computed based on the null hypothesis which induces a permutation distribution on the {pˆi}, the distribution that randomly assigns a p^j for each read independent of the junction to which the read aligned. The permutation distribution on {p^i} induces a distribution on the posterior probability for a linear junction as a function of number of aligned reads. An analogous test is performed for each circular junction with a simple model to provide a false discovery rate (FDR) because the above approach is too conservative for circular RNA junctions, as these reads were not used to fit the GLM model.\n\nThe GLM model outputs three files:\n\n1. r\\_data: R object which contains trained GLM model\n2. linear\\_junc\\_probs: predicted posterior probabilities for each junction using only \"linear\" reads\n3. circ\\_junc\\_probs: predicted posterior probabilities for each junction using only \"circular\" reads",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "#!/usr/bin/env Rscript\n#   PFA_VMEM=\"200000\"  # this is used for glm reports, needed for srun\n# DT[, c(\"z\",\"u\",\"v\"):=NULL] #remove several columns at once\n\n## The heart of the GLM. Uses the text files of ids generated by the naive method run\n# to assign reads to categories and outputs predictions per junction to glmReports. models\n# are saved into glmModels for further manual investigation.\n\n########## FUNCTIONS ##########\n\nrequire(data.table)\nlibrary(base)\nset.seed(1, kind = NULL, normal.kind = NULL)\n\n# allows for variable read length (for trimmed reads)\ngetOverlapForTrimmed <- function(x, juncMidpoint=150){\n    if (as.numeric(x[\"pos\"]) > juncMidpoint){\n      overlap = 0\n    } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n      overlap = 0\n    } else {\n      overlap = min(as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint,\n      juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n    }\n\n  return(overlap)\n}\n\nprocessScoreInput <- function(scoreFile){\n  setkey(scores, id)\n    return(scores)\n}\n\naddDerivedFields <- function(dt, useClass){\n# correction 4/2016 of class files\nif(nrow(dt) > 0){\n    # calculate and add on cols for junction overlap, score adjusted for N penalties,\n    ########## now, we have info for read1 and read2\n    # calculate and add on cols for junction overlap, score adjusted for N penalties,\n    dt[,`:=`(is.pos=useClass,overlap=apply(dt, 1, getOverlapForTrimmed))]  # syntax for multiple :=\n    # and length-adjusted alignment score (laplace smoothing so alignment score of 0 treated different for different length reads)\n    dt[, lenAdjScore:=(as.numeric(aScore) - 0.001)/as.numeric(readLen)]\n    dt[,`:=`(pos=NULL, aScore=NULL, numN=NULL, readLen=NULL)]\n################# repeat for read2\n ## therefore, only add length adjusted alignment score for R2 !!\n    # and length-adjusted alignment score (`` smoothing\" so alignment score of 0 treated different for different length reads)\n    dt[, lenAdjScoreR2:=(aScoreR2 - 0.001)/readLenR2]\n    dt[,`:=`(pos=NULL, aScoreR2=NULL, numNR2=NULL, readLenR2=NULL, adjScoreR2=NULL, aScore=NULL, numN=NULL, readLen=NULL, adjScore=NULL)]\n}\n    return(dt)\n}\n\n# the input file is just the file output by the circularRNApipeline under /ids\nprocessClassInput <- function(classFile,my.names){\n\n#cats = fread(classFile,  sep=\"\\t\", nrows=100000)\ncats = fread(classFile,  sep=\"\\t\")\n############################################################\nif ( my.names!=\"none\"){\nnames(cats)=my.names\n}\n\n# syntax for changing names setnames(cats, names(cats), c(\"id\", \"R1\", \"R2\", \"class\"))\n  setkey(cats, id)\n  return(cats)\n}\n\n# To avoid integer underflow issue when we have too many very small or very large probabilities.\n# Take inverse of posterior probability, then take log, which simplifies to sum(log(q) - /sum(log(p))\n# and then reverse operations to convert answer back to a probability.\n# param p: vector of p values for all reads aligning to junction\n# return posterior probability that this is a circular junction based on all reads aligned to it\ngetPprodByJunction <- function(p ){\n  out = tryCatch(\n{\n  x = sum(log(p))  # use sum of logs to avoid integer underflow\n  return(exp(x))\n},\nerror = function(cond){\n  print(cond)\n  print(p)\n  return(\"?\")\n},\nwarning = function(cond){\n  print(cond)\n  print(p)\n  return(\"-\")\n}\n  )\nreturn(out)\n}\n\napplyToClass <- function(dt, expr) {\n  e = substitute(expr)\n  dt[,eval(e),by=is.pos]\n}\n\napplyToJunction <- function(dt, expr) {\n  e = substitute(expr)\n  dt[,eval(e),by=junction]\n}\n\n\n#######################################################################\n######################## BEGIN JS ADDITION ############################\n####################### FIRST JS FUNCTION #############################\n########################################################################\n################# JS added function to FIT the GLM using arbitrary two-classes\n\nmy.glm.model<-function( linear_reads, decoy_reads,use_R2 , max.iter){\n### FUNCTION TO FIT GLM TO linear READS, returns the GLM and junction predictions,\nsaves = list()  # to hold all of the glms for future use\n#max.iter = 2  # number of iterations updating weights and retraining glm\n\n# set up structure to hold per-read predictions\nn.neg = nrow(decoy_reads)\nn.pos = nrow(linear_reads)\nn.reads = n.neg+n.pos\nclass.weight = min(n.pos, n.neg)\n\n## note that this is coded as linear_reads and decoy_reads but applies to any pair class\n\nreadPredictions = rbindlist(list(linear_reads, decoy_reads))\n\n# set initial weights uniform for class sum off all weights within any class is equal\nif (n.pos >= n.neg){\n  readPredictions[,cur_weight:=c(rep(n.neg/n.pos, n.pos), rep(1, n.neg))]\n} else {\n  readPredictions[,cur_weight:=c(rep(1, n.pos), rep(n.pos/n.neg, n.neg))]\n}\n\n# glm\nfor(i in 1:max.iter){\n  # M step: train model based on current read assignments, down-weighting the class with more reasourcds\n\nif (use_R2==1){\n  x = glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n\n}\nif (use_R2==0){\n  x = glm(is.pos~overlap+lenAdjScore+qual , data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n}\n  saves[[i]] = x\n\n  # get CI on the output probabilities and use 95% CI\n  preds = predict(x, type = \"link\", se.fit = TRUE)\n  critval = 1.96 # ~ 95% CI\n  upr = preds$fit + (critval * preds$se.fit)\n  lwr = preds$fit - (critval * preds$se.fit)\n  upr2 = x$family$linkinv(upr)\n  lwr2 = x$family$linkinv(lwr)\n\n  # use the upper 95% value for decoys and lower 95% for linear\n  adj_vals = c(rep(NA, n.reads))\n  adj_vals[which(readPredictions$is.pos == 1)] = lwr2[which(readPredictions$is.pos == 1)]\n  adj_vals[which(readPredictions$is.pos == 0)] = upr2[which(readPredictions$is.pos == 0)]\n  x$fitted.values = adj_vals  # so I don't have to modify below code\n\n  # report some info about how we did on the training predictions\n  totalerr = sum(abs(readPredictions[,is.pos] - round(x$fitted.values)))\n  print (paste(i,\"total reads:\",n.reads))\n  print(paste(\"both negative\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==0), \"out of \", n.neg))\n  print(paste(\"both positive\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==2), \"out of \", n.pos))\n  print(paste(\"classification errors\", totalerr, \"out of\", n.reads, totalerr/n.reads ))\n  print(coef(summary(x)))\n  readPredictions[, cur_p:=x$fitted.values] # add this round of predictions to the running totals\n\n  # calculate junction probabilities based on current read probabilities and add to junction predictions data.table\n\n  tempDT = applyToJunction(subset(readPredictions, is.pos == 1), getPprodByJunction(cur_p))\n  setnames(tempDT, \"V1\", paste(\"iter\", i, sep=\"_\")) # iter_x is the iteration of product of ps\n  setkey(tempDT, junction)\n  junctionPredictions = junctionPredictions[tempDT]  # join junction predictions and the new posterior probabilities\n  rm(tempDT)  # clean up\n\n  # E step: weight the reads according to how confident we are in their classification. Only if we are doing another loop\n  if(i < max.iter){\n    posScale = class.weight/applyToClass(readPredictions,sum(cur_p))[is.pos == 1,V1]\n    negScale = class.weight/(n.neg - applyToClass(readPredictions,sum(cur_p))[is.pos == 0,V1])\n    readPredictions[is.pos == 1,cur_weight:=cur_p*posScale]\n    readPredictions[is.pos == 0,cur_weight:=((1 - cur_p)*negScale)]\n  }\n  setnames(readPredictions, \"cur_p\", paste(\"iter\", i, sep=\"_\")) # update names\n}\n\n# calculate mean and variance for null distribution\n## this uses a normal approximation which holds only in cases with large numbers of reads, ie the CLT only holds as the number of reads gets very large\n\n## should be called p-predicted\n##read_pvals = readPredictions[,max.iter]\n\n# rename cols to be consistent with circular glmReports, syntax below removes col. \"ITER_1\"\nif (max.iter>1){\n# cleaning up\nfor (myi in c(1:(max.iter-1))){\njunctionPredictions[, paste(\"iter_\",myi,sep=\"\"):=NULL]\n}\n}\nsetnames(junctionPredictions, paste(\"iter_\",max.iter,sep=\"\"), \"p_predicted\")\nlist(saves, junctionPredictions) ## JS these are the outputs and done with function\n}\n\n\n########################################################################\n###################### prediction from model ##########################\n##### as a function, needs input data and model\n\npredictNewClassP <- function(my_reads, null){ ## need not be circ_reads, just easier syntax\n######### up until this point, every calculation is PER READ, now we want a function to collapse\n######### want to do hypothesis testing\n# calculate junction probabilities based on predicted read probabilities\n## Use simple function-- NOTE: \"p predicted\" is a CI bound not the point estimate. It is still technically a consistent estimate of p predicted\n## prob of an anomaly by glm is phat/(1+phat) under 'real' 1/(1+phat) under 'decoy' junction, so the ratio of these two reduces to 1/phat. as phat -> 1, no penalty is placed on anomaly.\n\n#merge\njunctionPredictions = my_reads[, .N, by = junction] # get number of reads per junction\nsetnames(junctionPredictions, \"N\", \"numReads\")\nsetkey(junctionPredictions, junction)\n\nmy_reads[, logproduct:=sum( log (p_predicted) * (1-is.anomaly) + log( 1/(1+p_predicted) *is.anomaly)), by=junction]\n\n## is anomaly adjusted log sum scoremm\nlogsum=my_reads[,sum( log ( p_predicted / (1+p_predicted*is.anomaly))), by=junction]\nlogsum_2=my_reads[,sum( log ( p_predicted_2 / (1+p_predicted_2*is.anomaly))), by=junction]\nprint (\"Logsum is reported which is equal to the sum of the logs of phats-- if exponentiated, corresponds to product of ps\")\n\n## merge these new variables to the dataframe\njunctionPredictions=merge(junctionPredictions,logsum)\nsetnames(junctionPredictions, \"V1\", \"logsum\")\n\njunctionPredictions=merge(junctionPredictions,logsum_2)\nsetnames(junctionPredictions, \"V1\", \"logsum_2\")\n\nprint (names(junctionPredictions))\n\n########### adding quantiles of p_predicted\nn.quant=2\nfor (qi in 1:n.quant){\nmy_quantiles = my_reads[,round(10*quantile(p_predicted/(1+is.anomaly* p_predicted),probs=c(0:n.quant)/n.quant)[qi])/10,by=junction]\n\n# merge into junctionPredictions\nprint (head(my_quantiles))\nsetkey(my_quantiles,junction)\njunctionPredictions=merge(junctionPredictions,my_quantiles)\nsetnames(junctionPredictions, \"V1\", paste(\"q_\",qi,sep=\"\"))\n}\n\n##################################\n##  tempDT, to collapse across junctions\n# p_predicteds are the exponentiation\njunctionPredictions [ ,p_predicted_2:=exp(logsum_2),by=junction]\njunctionPredictions [ ,p_predicted:=exp(logsum),by=junction]\n\nprint (head(junctionPredictions[order(junction),]))\n\n## NOTE: P VALUE IS probability of observing a posterior as extreme as it is, \"getPvaluebyJunction\" is a bayesian posterior\njunctionPredictionsWP=assignP(junctionPredictions,null)\n\nrm(tempDT)  # clean up\n## adding here:\n\nunique(junctionPredictionsWP) ## returned\n\n}\n########################################################################################### ASSIGN p values through permutation\n###################################\nassignP<-function(junctionPredictions,null) {\n# logsum is the logged sum\n# add p-value to junctionPredictions (see GB supplement with logic for this)\n\nlognull=log(null)\n\nuse_mu = mean(lognull) # this is actually the mean of the read level predictions\nuse_var=var(lognull)\n## for large n,\n#print (\"using cdf of null distribution as \"p_value\" which is misnomer for convenient and replaced below \")\nn.thresh.exact=15\nprint (n.thresh.exact)\n\njunctionPredictions[ (numReads>n.thresh.exact) , p_value :=  pnorm((logsum - numReads*use_mu)/sqrt(numReads*use_var))]\n\njunctionPredictions[ (numReads>n.thresh.exact) , p_value_2 :=  pnorm((logsum_2 - numReads*use_mu)/sqrt(numReads*use_var))]\n\n## make empirical distribution of posteriors:\n\nprint (\"exact calculation through sampling 10K p predicted\")\nmy.dist=list(n.thresh.exact)\nfor ( tempN in 1:n.thresh.exact){ #### get distributions to convolve in next loop\nn.sampled=1000 # used to compute the null distribution of posteriors\nmy.dist[[tempN]]=sample(lognull, n.sampled, replace=T)\n}\n\nfor ( tempN in 1:n.thresh.exact){ ## use this loop to assign jncts w/ tempN\nsim.readps=my.dist[[1]]\nif (tempN>1){\nfor (tj in 2: tempN){ # loop, taking products\nsim.readps=my.dist[[tj]] +  sim.readps\n}\n}\n# convert to posterior\n## fraction of time p_predicted is smaller than -- so if p_predicted is very large, the fraction of time it is smaller is big\n## use the null to compute p_vals\nprint (head(junctionPredictions))\nprint (paste(tempN, \"is value of readcount for exact calculation and length of sim reads is \",length(sim.readps)))\n\njunctionPredictions [ (numReads == tempN ), p_value:= sum( exp(sim.readps)<p_predicted)/length(sim.readps),by=junction]\n\nprint (\"if below table is not empty, ERROR\")\nprint (junctionPredictions[p_value>1])\n\n\njunctionPredictions [ (numReads == tempN ), p_value_2:= sum( exp(sim.readps)<p_predicted_2)/length(sim.readps), by=junction]\n\n}\nreturn(junctionPredictions)\n}\n###########################################################################################\n###########################################################################################\n###########################################################################################\n###########################################################################################\n######## END FUNCTIONS, BEGIN WORK #########\n\n## command line inputs\n\n################# USER INPUT SHOULD BE 0 if it is used in an automated script\n\n#parentdir=\"/scratch/PI/horence/alignments/EWS_FLI_bigmem/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/CML_UConn/circpipe_K562/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/alignments/EWS_FLI_bigmem/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/CML_test/aligned/CML/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/Ewing/circpipe/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/normal_breast/circpipe/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/SEQC_study_set/circpipe_SEQC/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/alignments/Stavros/circReads/ids/\"\n#output_dir=\"\"\nsampletest=\"EWS\"\nuser.input=0\n\n\nargs = commandArgs(trailingOnly = TRUE)\nclass_input = args[1]\nglm_out = args[2]\nlinear_juncp_out = args[3]\ncirc_juncp_out = args[4]\n#print(paste(\"predict junctions called with args:\", args))\n\nmax.iter=2 ## iterations for glm\n\nmy.names=\"none\" ## this is bc Gillians fields are not names like Lindas are\nmyClasses = processClassInput(class_input, my.names)\n\n\nprint(paste(\"class info processed\", dim(myClasses)))\n\nprint (\"finished circ_reads\")\n\ndecoy_reads = myClasses[(tolower(class) %like% 'anomaly'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2),]\nif (dim(decoy_reads)[1] == 0){\n  print(\"Exiting: number of decoy reads is 0.\")\n  quit(status = 0)\n}\ndecoy_reads = addDerivedFields(decoy_reads, 0)\ndecoy_reads [, is.anomaly:=1] ######## this IS an anomaly type\n\nprint (\"finished decoy_reads\")\n## was\nlinear_reads = myClasses[(tolower(class) %like% 'linear'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2),]\nif (dim(linear_reads)[1] == 0){\n  print(\"Exiting: number of linear reads is 0.\")\n  quit(status = 0)\n}\nlinear_reads = addDerivedFields(linear_reads, 1)\nlinear_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished linear_reads\")\n\n###############################################################################################\n## CANNOT ADD DERIVED FIELDS HERE BECAUSE WE DON'T KNOW WHICH ANOMALIES ARE GOOD AND/OR BAD\n##################### DERIVED FIELDS ADDED LATER ##############################################\n###############################################################################################\n\n# set up data structure to hold per-junction predictions\njunctionPredictions = linear_reads[, .N, by = junction] # get number of reads per junction\nsetnames(junctionPredictions, \"N\", \"numReads\")\nsetkey(junctionPredictions, junction)\n\n#### TRAIN EM ####\n## this should be a function of any two classes; and the output will be the model\n\n##\n\nn.row= dim(linear_reads)[1]\nn.sample=min(n.row,10000)\n\n#syntax example decoy_reads[,p_predicted:=NULL]\nprint (\"calling linear decoy model\")\nlinearDecoyGLMoutput = my.glm.model ( linear_reads[ sample(n.row,n.sample,replace=FALSE),], decoy_reads, 1, max.iter) ## 0 does not use R2 info\n\nsaves = linearDecoyGLMoutput[[1]]\nlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\nsave(saves, file=glm_out)  # save models\nlinearDecoyGLM = saves[[max.iter]] ##### this is the glm model\n\n## after fitting the GLM to linear vs. decoy, we want to store linear junction predictions in order to subset anomalies\n######## JS ADDITION: NOTE- NOT stratifying on permutation p value, although could add this too\n\n\n############################################################################\n### START LINEARS\n################# predict on anomaly reads -- AND TEST HOW THIS IMPACTS LINEAR PREDICTIONS\n############################ linear predictions ONLY ON THE BASIS of anomalies...\n\npreds = predict(linearDecoyGLM, newdata=linear_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\nlinear_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\nlinear_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n## for null\nprint (\"Assigning null distribution for all linear reads\")\nnull=linear_reads$p_predicted\n\n### ASSIGN p value:\nlinearJunctionPredictionsForModels = predictNewClassP(linear_reads, null)\n\npGoodThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.8)\ngood.linear=linearJunctionPredictionsForModels[p_value> pGoodThresh,]\n\npBadThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.2)\nbad.linear=linearJunctionPredictionsForModels[p_value< pBadThresh,]\n#####################################\n\n\n\n##### now, re-run script training on anomalies from good vs. bad\n\nsave(linearDecoyGLM, file=glm_out)  # save models\n\npreds = predict(linearDecoyGLM, newdata=decoy_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\ndecoy_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ndecoy_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n\nlinearJunctionPredictions = predictNewClassP(linear_reads, null)\n\nlinearJunctionPredictions[,q_1:=NULL]\nlinearJunctionPredictions[,q_2:=NULL]\nlinearJunctionPredictions[,logsum_2:=NULL]\nlinearJunctionPredictions[,p_predicted_2:=NULL]\nlinearJunctionPredictions[,p_value_2:=NULL]\nsetnames(linearJunctionPredictions,\"p_predicted\", \"productPhat.x\")\nsetnames(linearJunctionPredictions,\"p_value\", \"junction_cdf.x\")\n\nwrite.table(unique(linearJunctionPredictions), linear_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\n################# DONE WITH LINEARS\n#########################################################################\n\n#### PREDICT CIRCULAR JUNCTIONS #### SHOULD MAKE THIS MODULAR AND A FUNCTION so Farjunction and Anomalies can be used\n## SIMPLE PREDICT ON CIRCLES\n\ncirc_reads = myClasses[(tolower(class) %like% 'circ'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2),]\nif (dim(circ_reads)[1] == 0){\n  print(\"Exiting: number of circular reads is 0.\")\n  quit(status = 0)\n}\ncirc_reads = addDerivedFields(circ_reads, 1)\ncirc_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\npreds = predict(linearDecoyGLM, newdata=circ_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\ncirc_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ncirc_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\ncircularJunctionPredictions = predictNewClassP(circ_reads, null)\n\n\n\n## write circle prediction\n\ncircularJunctionPredictions[,q_1:=NULL]\ncircularJunctionPredictions[,q_2:=NULL]\ncircularJunctionPredictions[,logsum_2:=NULL]\ncircularJunctionPredictions[,p_predicted_2:=NULL]\ncircularJunctionPredictions[,p_value_2:=NULL]\n\nsetnames(circularJunctionPredictions,\"p_predicted\", \"productPhat.x\")\nsetnames(circularJunctionPredictions,\"p_value\", \"junction_cdf.x\")\n\nwrite.table(unique(circularJunctionPredictions), circ_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")",
                "filename": "JS_forFindCircularRNA_GLMfix.r"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "inputs": [
          {
            "label": "Input report",
            "type": [
              "File"
            ],
            "description": "Output of FilterFDR.py which contains report about reads.",
            "id": "#input_report",
            "required": true
          }
        ],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#r_data",
            "outputBinding": {
              "glob": "*.RData_cdf"
            }
          },
          {
            "label": "Linear junctions probability",
            "id": "#linear_junc_probs",
            "description": "Information about junctions which contain linear reads",
            "sbg:fileTypes": "TXT",
            "outputBinding": {
              "glob": "*linearJuncProbs.txt_cdf"
            },
            "type": [
              "null",
              "File"
            ]
          },
          {
            "label": "Circular junction probabilities",
            "id": "#circ_junc_probs",
            "description": "Information about junctions which contain circular reads",
            "sbg:fileTypes": "TXT",
            "outputBinding": {
              "glob": "*circJuncProbs.txt_cdf"
            },
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 5000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/machete_glm:r"
          }
        ],
        "baseCommand": [
          {
            "class": "Expression",
            "engine": "#cwl-js-engine",
            "script": "{\n  \tname = $job.inputs.input_report.path.split('/').pop()\n    sample_id = name.slice(0, name.length - 12)\n    \n\treturn \"chmod +x JS_forFindCircularRNA_GLMfix.r && Rscript JS_forFindCircularRNA_GLMfix.r \" + $job.inputs.input_report.path + \" \" + sample_id + \"_glm.RData_cdf \" + sample_id + \"_linearJuncProbs.txt_cdf \" + sample_id + \"_circJuncProbs.txt_cdf\"\n\n}"
          }
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [],
        "cwlVersion": "sbg:draft-2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:job": {
          "inputs": {
            "input_report": {
              "class": "File",
              "secondaryFiles": [],
              "size": 0,
              "path": "/path/to/SAMPLE_ID__output.txt"
            }
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 5000
          }
        },
        "sbg:links": [
          {
            "label": "Publication",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed/26076956"
          }
        ],
        "sbg:cmdPreview": "chmod +x JS_forFindCircularRNA_GLMfix.r && Rscript JS_forFindCircularRNA_GLMfix.r /path/to/SAMPLE_ID__output.txt SAMPLE_ID_glm.RData_cdf SAMPLE_ID_linearJuncProbs.txt_cdf SAMPLE_ID_circJuncProbs.txt_cdf",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:image_url": null,
        "sbg:categories": [
          "RNA"
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432659,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432679,
            "sbg:revisionNotes": "revision 21 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1547589225,
            "sbg:revisionNotes": "anomaly instead of decoy"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1566586708,
            "sbg:revisionNotes": "back to revision 1"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/glm-model/3",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/glm-model/3",
        "sbg:revision": 3,
        "sbg:revisionNotes": "back to revision 1",
        "sbg:modifiedOn": 1566586708,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520432659,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos",
          "milos_jordanski"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ad190ddfd40c1455ed0a6cd2ee7e38af35661e751f4fac3fa5d3d85fb3e103dbf",
        "x": 1316.668003400216,
        "y": -148.2813340139911
      },
      "inputs": [
        {
          "id": "#KNIFE_GLM_model.input_report",
          "source": [
            "#KNIFE_filterFDR.output"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_GLM_model.r_data"
        },
        {
          "id": "#KNIFE_GLM_model.linear_junc_probs"
        },
        {
          "id": "#KNIFE_GLM_model.circ_junc_probs"
        }
      ],
      "sbg:x": 1316.668003400216,
      "sbg:y": -148.2813340139911
    },
    {
      "id": "#KNIFE_filterFDR",
      "run": {
        "class": "CommandLineTool",
        "label": "KNIFE filterFDR",
        "description": "FilterFDR takes alignments to the ribosomal, genome, regular and scrambled junctions and assigns paired-end reads to the junctions. In addition it determines a type of paired-end reads. Paired-end reads might be:\n\n1. \"linear\" : paired-end read is a \"linear\" if first mate is aligned to a regular junction (and not aligned neither to ribosomal and genome reference) and second mate is aligned to the same chromosome in opposite orientation and downstream or slightly upstream (to account for errors).\n\n2. \"decoy\": paired-end read is a \"decoy\" if first mate is aligned to a scrambled junction (and not aligned neither to ribosomal, genome or regular junction) and second mate is aligned to:\na. different chromosome\nb. same chromosome, but in same orientation\nc. same chromosome, opposite orientation, but out of bound defined by scrambled junction on which mate1 is aligned\n\n3. \"anomaly\": paired-end read is a \"anomaly\" if first mate is aligned to a regular junction (and not aligned neither to ribosomal, genome nor regular junction) and second mate is aligned to:\n1. different chromosome\n2. same chromosome, but in same orientation\nc. same chromosome, opposite orientation, and far away upstream\n\n4. \"circular\" paired-end read is a \"circular\" if first mate is aligned to a scrambled junction (and not aligned neither to ribosomal, genome, nor regular junction) and second mate is aligned either to the same chromosome, in opposite orientation and either to or near by the same scrambled junction.\n\n5. \"multimapped\": paired-end read is a \"multimapped\" if fist mate is aligned either to a regular junction (and not aligned neither to ribosomal, genome nor regular junction) or a scrambled junction (and not aligned neither to ribosomal, genome nor regular junction) and second mate is aligned to either genome, regular or scrambled junction with poor quality.\n\n6. \"unmapped\": otherwise\n\nfilterFDR outputs two files:\n1. report: Report contains information about junctions.\n2. output: Output contains information about reads. This file is an input to the GLM model.",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "fileContent": "import os\nimport errno\nimport re\n\n# create directory if it does not exist\ndef createDirectory(dirPath):\n    try:\n        if not os.path.isdir(dirPath):\n            os.makedirs(dirPath)\n    except OSError, e:\n        if e.errno != errno.EEXIST:\n            raise\n        \n# parse a string of interest out of a filename\ndef getFileId(patt, grp, filename):\n    match = patt.search(filename)\n    if match:\n        return match.group(grp)\n    else:\n        print \"filename not structured correctly: \" + str(filename)\n\n# good way to grep, particularly for large files\ndef grep(pattern, file_obj, include_line_nums=False):\n    grepper = re.compile(pattern)\n    for line_num, line in enumerate(file_obj):\n        if grepper.search(line):\n            if include_line_nums:\n                yield (line_num, line)\n            else:\n                yield line",
                "filename": "utils_os.py"
              },
              {
                "fileContent": "# main data structures for tracking junctions and aligned reads and their associated properties\n\nimport re\nfrom collections import namedtuple\nfrom collections import deque\nfrom numpy import mean\n\nPOS_MATCH_FLAG = 0  # value used in sam file to indicate alignment to forward strand\nREV_MATCH_FLAG = 16  # value used in sam file to indicate alignment to reverse strand\n## locations of information in the junction id when it is split using id_patt regex\nG_CHR = 1\nG_GENE1 = 2\nG_POS1 = 3\nG_GENE2 = 4\nG_POS2 = 5\nG_JUNC_TYPE = 6\nG_JUNC_STRAND = 7\nBUFFER = 15  # allow wiggle room to minimize anomalies / decoys due to sequencing errors or adaptor sequence alignment\nUNALIGNED_BUFFER = 50  # allow extra wiggle room for unaligned because the headers contain bins, not exact alignment positions\nJUNC_MIDPOINT = 150  # we take 150bp from each exon to create a junction sequence\nMIN_MAPQUAL = 0 # minimum mapping quality to consider a read as providing any info  \n\n# junction ids look like chr10|TTC40:134751179|MYC1:134722640|reg|-\n# where we are interested in chr10, TTC40, 134751179, MYC1, 134722640, reg, and -\nid_patt = re.compile(\"(.+?)\\|(.+?):(.+?)\\|(.+?):(.+?)\\|(.+?)\\|(\\-|\\+)\")\n\n# MD strings look like 0N0N0N0N0N0N35T0A0G0G0G1T1C29 or 35T0A0G0G0G1T1C29N0N0 with any number of 0N or N0 repeats\n# where we are interested in the repeats 0N0N0N0N0N0N and N0N0\nmd_patt = re.compile(\"^((?:0N)*).+?((?:N0)*)$\")\n\n# Contains read and its mates that mapped to the genome or junction database.\n# Can have mate mapping to both since the alignment of all mates is done to both\n# indexes. Also knows whether it looks like a circle or a decoy.\nclass juncReadObj:\n    \n    def __init__(self, read):\n        self.juncRead = read  # read object that aligned to junction\n        self.mateGenomic = None # read object for mate that aligned to the genome\n        self.mateJunction = None # read object for mate that aligned to the junction index\n        self.mateRegJunction = None # read object for mate that aligned to the regular-only junction index\n        self.mateDenovoJunction = None # read object for mate that aligned to the denovo junction index\n        self.readType = None # will be updated to \"c\", \"d\",\"u\", \"l\", a\", or \"i\" for circular, decoy, mate-unmapped, linear, anomaly or ignore\n        self.useMate = None # will be updated to self.mateGenomic, self.mateJunction, or self.mateRegJunction after we have all options\n        self.readStat = None # will be updated to include statistic I want to use for evaluating this read (for example avg)\n    \n    def __str__(self):\n        msg = \"juncRead: \" + str(self.juncRead)\n        msg += \"\\nmateGenomic: \" + str(self.mateGenomic)\n        msg += \"\\nmateJunction: \" + str(self.mateJunction)\n        msg += \"\\nmateRegJunction: \" + str(self.mateRegJunction)\n        msg += \"\\nmateDenovoJunction: \" + str(self.mateDenovoJunction)\n        msg += \"\\nreadType: \" + str(self.readType)\n        msg += \"\\nuseMate: \" + str(self.useMate)\n        msg += \"\\nreadStat: \" + str(self.readStat)\n        return msg        \n    \n    # param junc: juncObj\n    # param isSingleEnd: T/F since we need to know if the mate isn't there because it never existed or because it didn't align or pass quality filters\n    # param isUnalignedMode: T/F since the header info is slightly different for the index built for the denovo run (only applicable to scrambled junctions for now)\n    def updateInfo(self, junc, isSingleEnd, isUnalignedMode):\n        # if the junction-spanning read had poor mapping quality,\n        # it will end up being placed in the multi-mapped bucket\n        # so no need to take a look at mates and read types\n        # otherwise, pick a mate and calculate values based on mate selected\n        if int(self.juncRead.mapQual) >= MIN_MAPQUAL:\n            if not isSingleEnd:\n                self.useMate = self.selectMate()\n            self.readType = self.selectReadType(junc, isSingleEnd, isUnalignedMode)\n            self.readStat = self.calcReadStat()    \n    \n    # set useMate\n    # select the highest scoring alignment for Rd2. If multiple alignments have the same\n    # score, default to genome, then regular junction, then scrambled.\n    # only consider mates with good mapping quality, since poor quality reads most likely came from another location\n    def selectMate(self):\n        possibleMates = []\n        \n        \n        if self.mateGenomic and int(self.mateGenomic.mapQual) >= MIN_MAPQUAL:\n            possibleMates.append(self.mateGenomic)\n        \n        if self.mateRegJunction and int(self.mateRegJunction.mapQual) >= MIN_MAPQUAL:\n            possibleMates.append(self.mateRegJunction)\n        \n        if self.mateJunction and int(self.mateJunction.mapQual) >= MIN_MAPQUAL:\n            possibleMates.append(self.mateJunction)\n        \n        if self.mateDenovoJunction and int(self.mateDenovoJunction.mapQual) >= MIN_MAPQUAL:\n            possibleMates.append(self.mateDenovoJunction)\n        \n        # mate did not align anywhere with a good mapping quality\n        if len(possibleMates) == 0:\n            return None\n        \n        # only consider those mates with the maximum alignment score\n        maxAS = max(int(x.aScore) for x in possibleMates)\n        possibleMates = [x for x in possibleMates if int(x.aScore) == maxAS]\n        \n        # if we only have one left with the max alignment score, that's the one we want\n        if len(possibleMates) == 1:\n            return possibleMates[0]\n\n        # otherwise go through the priority ranking\n        if self.mateGenomic in possibleMates:\n            return self.mateGenomic\n        \n        if self.mateRegJunction in possibleMates:\n            return self.mateRegJunction\n        \n        if self.mateJunction in possibleMates:\n            return self.mateJunction\n        \n        if self.mateDenovoJunction in possibleMates:\n            return self.mateDenovoJunction\n    \n    def calcReadStat(self):\n        if self.juncRead:\n            # if we have a mate we are using, take the avg of the 2 reads\n            if self.useMate:\n                return mean([int(self.juncRead.aScore), int(self.useMate.aScore)])\n            # otherwise just use my score\n            else:\n                return float(self.juncRead.aScore)\n        else:\n            return None\n        \n    # have to handle reg junctions separately since they could have a rev mate\n    # that makes them circular evidence, or they need to be assigned to linear or anomaly buckets\n    # param junc: juncObj\n    def selectReadType(self, junc, isSingleEnd, isUnalignedMode):\n        \n        # if mate mapped to neither junctions nor genome, it is unmapped\n        if not isSingleEnd and not self.useMate:\n            return None\n        \n        # for single end, we can only determine read type based on alignment to reg or scrambled junction\n        if isSingleEnd:\n            if junc.juncType == \"reg\":\n                useType = \"l\"\n            else:\n                useType = \"c\"\n        else:        \n            if junc.juncType == \"reg\":\n                useType = self.selectRegReadType(junc)\n            else:\n                useType = self.selectScrambledReadType(junc, isUnalignedMode)\n        \n        return useType        \n        \n    # this junction Rd1 is either dup or rev        \n    def selectScrambledReadType(self, junc, isUnalignedMode):\n        \n        myCoord = int(junc.minPos) - JUNC_MIDPOINT + int(self.juncRead.offset)\n        myEnd = myCoord + int(self.juncRead.readLen)\n\n        # get info for mate \n        isGenomicMate = self.useMate == self.mateGenomic\n        \n        if isGenomicMate:\n            mateChr = self.useMate.refName\n            mateCoord = int(self.useMate.offset)\n        else:\n            match2 = id_patt.search(self.useMate.refName)  # rd2 junction id\n            mateChr = match2.group(G_CHR)\n            minMateJunctionPos = min(int(match2.group(G_POS1)), int(match2.group(G_POS2)))\n            maxMateJunctionPos = max(int(match2.group(G_POS1)), int(match2.group(G_POS2)))\n            mateCoord = minMateJunctionPos - JUNC_MIDPOINT + int(self.useMate.offset)\n        \n        mateEnd = mateCoord + int(self.useMate.readLen)\n        \n        if isUnalignedMode:\n            USE_BUFFER = UNALIGNED_BUFFER\n        else:\n            USE_BUFFER = BUFFER\n            \n        # all info gathered, now see if it is consistent with circle or not\n        # reads need to map in opposite orientation (have opposite flags) \n        if junc.chromosome == mateChr and int(self.juncRead.flag) != int(self.useMate.flag):\n            # read2 mapping to same scrambled junction as read1 is always evidence of circle\n            if self.useMate.refName == self.juncRead.refName: \n                return \"c\"\n            # read2 mapping between read1 scrambled junction supports circle\n            elif (mateCoord >= (int(junc.minPos) - USE_BUFFER) and mateCoord <= (int(junc.maxPos) + USE_BUFFER)\n                  and mateEnd >= (int(junc.minPos) - USE_BUFFER) and mateEnd <= (int(junc.maxPos) + USE_BUFFER)):\n                    return \"c\"\n            # or Rd1 could map between bounds of a circle defined by scrambled junction-aligned Rd2\n            # but we want to ignore these for now because they will be identified in a swapped run  \n            elif (not isGenomicMate and match2.group(G_JUNC_TYPE) != \"reg\"\n                  and myCoord >= (minMateJunctionPos - USE_BUFFER) and myCoord <= (maxMateJunctionPos + USE_BUFFER)\n                  and myEnd >= (minMateJunctionPos - USE_BUFFER) and myEnd <= (maxMateJunctionPos + USE_BUFFER)):\n                return \"i\"\n            else:\n                # out of bounds \n                return \"d\"\n                    \n        else:\n            # the mate was on a different chromosome or alignment flags didn't agree with PE read\n            return \"d\"\n    \n    # this is a reg junction. If mate maps to scrambled junction we ignore it for now,\n    # since it will be picked up and considered in a swapped run (where we treat read 2 as read 1).\n    def selectRegReadType(self, junc):\n        \n        match1 = id_patt.search(self.juncRead.refName)  # reg junction rd1 id\n        myCoord = int(junc.minPos) - JUNC_MIDPOINT + int(self.juncRead.offset)\n        myEnd = myCoord + int(self.juncRead.readLen)\n            \n        # get info for mate \n        isGenomicMate = self.useMate == self.mateGenomic\n        \n        if isGenomicMate:\n            mateChr = self.useMate.refName\n            mateCoord = int(self.useMate.offset)\n        else:\n            match2 = id_patt.search(self.useMate.refName)  # rd2 junction id\n            mateChr = match2.group(G_CHR)\n            minMateJunctionPos = min(int(match2.group(G_POS1)), int(match2.group(G_POS2)))\n            maxMateJunctionPos = max(int(match2.group(G_POS1)), int(match2.group(G_POS2)))\n            mateCoord = minMateJunctionPos - JUNC_MIDPOINT + int(self.useMate.offset)\n                \n        mateEnd = mateCoord + int(self.useMate.readLen)\n        \n        ###### all info gathered, now see if it is consistent with circle or not\n        \n        # has to be on same chromosome and mates must be aligned in opposite orientation \n        if junc.chromosome == mateChr and int(self.juncRead.flag) != int(self.useMate.flag):\n            # check for evidence of linear \n            if isGenomicMate or match2.group(G_JUNC_TYPE) == \"reg\":\n                # figure out genomic coordinate for plus and minus read\n                if int(self.juncRead.flag) == POS_MATCH_FLAG:\n                    plusMateCoord = myCoord \n                    minusMateCoord = mateCoord\n                else:\n                    plusMateCoord = mateCoord\n                    minusMateCoord = myCoord\n                    \n                # rev read needs to map downstream, or only slightly upstream to account for errors\n                if minusMateCoord >= plusMateCoord - BUFFER:\n                    return \"l\"\n                else:\n                    return \"a\"\n            else:\n                # read 2 was to a scrambled junction, need to ignore for now\n                return \"i\"\n        else:\n            # the mate was on a different chromosome or alignment directions do not support PE read\n            return \"a\"\n\nclass juncObj:\n    \n    def __init__(self, id):\n        self.id = id # junction id\n        self.chromosome, self.direction, self.juncType, self.numGenes, self.minPos, self.maxPos = self.setInfo()\n        self.circularReads = deque([]) # will hold list of all reads spanning this junction that support circle\n        self.decoyReads = deque([]) # will hold list of all reads spanning this junction that do not support circle\n        self.unmappedReads = deque([]) # will hold list of all reads spanning this junction where mate is not mapped\n        self.multimappedReads = deque([]) # will hold list of all reads spanning this junction where mate has poor mapping quality\n        self.linearReads = deque([]) # all that look like true linear reads\n        self.anomalyReads = deque([]) # all that don't look like circular or linear\n        self.unknownReads = deque([]) # will hold list of all reads initially\n        self.fdr=None # will hold FDR or p-value printed in the per-junction report file  \n        \n    def __str__(self):\n        msg = \"\\nid: \" + str(self.id)\n        msg += \"\\nchromosome: \" + str(self.chromosome)\n        msg += \" direction: \" + str(self.direction)\n        msg += \" juncType: \" + str(self.juncType)\n        msg += \" minPos: \" + str(self.minPos)\n        msg += \" maxPos: \" + str(self.maxPos)\n        msg += \"\\ncircularReads: \" + str(len(self.circularReads))\n        msg += \" decoyReads: \" + str(len(self.decoyReads))\n        msg += \" unmappedReads: \" + str(len(self.unmappedReads))\n        msg += \" multimappedReads: \" + str(len(self.multimappedReads))\n        msg += \" linearReads: \" + str(len(self.linearReads))\n        msg += \" anolmalyReads: \" + str(len(self.anomalyReads))\n        msg += \" unknownReads: \" + str(len(self.unknownReads))\n        msg += \" fdr: \" + str(self.fdr)\n        \n        return msg\n    \n    def setInfo(self):\n        match = id_patt.search(self.id)\n        if match:\n            # if the 2 genes are the same, the junction involves only 1 gene\n            if match.group(G_GENE1) == match.group(G_GENE2):\n                numGenes = 1\n            else:\n                numGenes = 2\n            \n            # chr, direction, junctionType, numGenes, minPos, maxPos\n            return match.group(G_CHR), match.group(G_JUNC_STRAND), match.group(G_JUNC_TYPE), numGenes, min(int(match.group(G_POS1)), int(match.group(G_POS2))), max(int(match.group(G_POS1)), int(match.group(G_POS2))) \n        else:\n            return None,None,None,None,0,0\n            \n\n\n\nreadObj = namedtuple('readObj', ['name', 'flag', 'refName', 'offset', 'aScore', 'nextBest', 'mapQual', 'baseName', 'readLen', 'numN'])\n\n# param vals: result of calling line.strip().split() on a non-header line from sam file.\n# param readIdStyle: for now, options are just \"appended\" or \"complete\".\n#                    \"appended\" means /1 or /2 added to read 1 or read 2 respectively\n#                    \"complete\" means same id used in read1 and read2 files \n# Need to store read length because trimming could result in different lengths of reads within a single dataset\ndef newReadObj(vals, readIdStyle):\n    numN = 0\n    mmStr = \"\"\n    myScore = None\n    myNextBest = None\n    optFields = vals[11:]  \n    \n    for x in optFields:\n        curOpt = x.split(\":\")\n        if curOpt[0] == \"AS\":\n            myScore = curOpt[2]\n        elif curOpt[0] == \"XS\":  # next best score\n            myNextBest = curOpt[2]\n        elif curOpt[0] == \"XN\":  # num N in reference\n            numN = int(curOpt[2]) \n        elif curOpt[0] == \"MD\":  # string representing mismatch locations\n            mmStr = curOpt[2]\n            \n    # correct for N-penalty in junction alignments and update alignment score as needed\n    if numN > 0:\n        match = id_patt.search(vals[2])  # if this is a junction alignment, refName will fit this pattern\n        if match:  # only want to adjust junction alignments \n            # get MD string, string representation of where the mismatches or Ns occurred\n            # if Ns are on left the pattern is 0N, if on right of match the pattern is N0\n            match_md = md_patt.search(mmStr)\n            numOinStr = match_md.group(1).count(\"0N\")\n            numNinStr = match_md.group(2).count(\"N0\")\n            # confirm agreement between XN and MD string\n            if numNinStr == numN or numOinStr == numN or numNinStr + numOinStr == numN: \n                myOrigScore = myScore\n                #myScore = str(int(myScore) + numN) # 1 was deducted from score for each N matched in reference so add back, keep as string for consistency\n            #else:\n                #print \"could not update AS for\", vals[0], \"MD and XN do not agree\", mmStr, str(numN) \n                    \n    if readIdStyle == \"appended\":        \n        myBaseName = vals[0][:-1]  # name without trailing 1 or 2 so we can quickly match up paired reads\n    else:\n        myBaseName = vals[0]  # or sometimes the read ids are already the same in the 2 separate files  \n        \n    return readObj(name=vals[0], flag=int(vals[1]), refName=vals[2], offset=vals[3], aScore=myScore, nextBest=myNextBest, mapQual=vals[4], baseName=myBaseName, readLen=len(vals[9]), numN=numN)",
                "filename": "utils_juncReads_minimal.py"
              },
              {
                "fileContent": "# Assumes preprocessAlignedReads.sh has been called and files with read ids for genome,\n# junction, reg, ribo, and transcriptome alignments have been output.\n\n# Loops through all id files to find those Rd1 ids that are aligned to a junction and not to the ribosome\n# or genome. Then goes back to original sam files to get data for reads that aligned to each of these junctions\n# in order to create JuncObjs with all data for the reads that aligned to a junction.\n\n# Then assigns each read to a bucket based on where Rd1 and Rd2 aligned. Outputs reports based on analysis using the\n# Naive method described in the paper into the reports directory. A very early method using a hard cutoff on alignment\n# scores is still implemented here (passing alignment score thresholds for read1 as -a1 and read2 as -a2),\n# but should not be used as the naive method performs better.\n\nimport argparse\nimport os\nimport utils_os\nfrom utils_juncReads_minimal import *\nfrom scipy.stats import scoreatpercentile\nfrom scipy.stats import poisson\nfrom math import ceil\nimport sys\n\n\nlogfile = open(\"logfile_no_sym.txt\", \"w\")\n\n# look in the ribo id file for this sample, and in the associated genome id file for this\n# sample to find the read ids that aligned to the genome or the ribosome.\n# Then look in the associated regular junction overlapped read id file and select\n# only those ids that are junction overlapped and did not align to ribosome or genome.\n# Populate the global regIds with these ids. Then look in the associated all-junction\n# overlapped id file and populate the global nonRegIds variable with these read ids\n# that did not align to the ribosome, genome, or regular junctions\ndef selectCandidateIds():\n    # add the suffix if we used an alternate overlap specification and output the overlapped ids to an alternate location\n    #regIdDir = \"reg\" + args.junctionIdDirSuffix\n    #juncIdDir = useJuncStr + args.junctionIdDirSuffix\n\n    #idDir = \"/\".join([args.parentDir, \"orig\", \"ids\"])\n\n    # only need to look for ids to exclude if we are not looking at previously unaligned reads\n    if not args.unalignedMode:\n        # get ribo ids\n        try:\n            #handle = open(\"\".join([\"/\".join([idDir, \"ribo\", args.sampleId]), \"_ribo_output.txt\"]), \"rU\")\n            handle = open(args.ribosomalTXT1, \"rU\")\n            if args.fastqIdStyle == \"appended\":\n                for line in handle:\n                    ignoreIds[line.strip().split()[0][:-1]] = None\n            else:\n                for line in handle:\n                    ignoreIds[line.strip().split()[0]] = None\n            handle.close()\n        except Exception as e:\n            print \"Exception\"\n            print e\n            print \"parsing ribo ids for\", line\n\n        # load genome aligned id file for the same sample and add to ignoreIds\n\n        #handle = open(\"\".join([\"/\".join([idDir, \"genome\", args.sampleId]), \"_genome_output.txt\"]), \"rU\")\n        handle = open(args.genomeTXT1, \"rU\")\n        if args.fastqIdStyle == \"appended\":\n            for line in handle:\n                try:\n                    ignoreIds[line.strip().split()[0][:-1]] = None\n                except TypeError as e:\n                    print \"error parsing genome ids for\", line\n                    print \"Type error({0}): {1}\".format(e.errno, e.strerror)\n                    print \"error:\", sys.exc_info()[0]\n                except:\n                    print \"error parsing genome ids for\", line\n                    print \"error:\", sys.exc_info()[0]\n        else:\n            for line in handle:\n                ignoreIds[line.strip().split()[0]] = None\n        handle.close()\n\n        # load reg-junction aligned id file for same sample and load ids not in ignoreIds\n        try:\n            #handle = open(\"\".join([\"/\".join([idDir, regIdDir, args.sampleId]), \"_reg_output.txt\"]), \"rU\")\n            handle = open(args.regularTXT1, \"rU\")\n            for line in handle:\n                if args.fastqIdStyle == \"appended\":\n                    testId = line.strip().split()[0][:-1]\n                else:\n                    testId = line.strip().split()[0]\n\n                if testId not in ignoreIds:\n                    regIds[testId] = None\n            handle.close()\n        except Exception as e:\n            print \"Exception\"\n            print e\n            print \"parsing reg ids for\", line\n\n    # load junction aligned id file (or de novo aligned id file) for same sample and load ids not in ignoreIds or regJuncIds\n    try:\n        #handle = open(\"_\".join([\"/\".join([idDir, juncIdDir, args.sampleId]), useJuncStr, \"output.txt\"]), \"rU\")\n        handle = open(args.scrambledTXT1, \"rU\")\n        for line in handle:\n            if args.fastqIdStyle == \"appended\":\n                testId = line.strip().split()[0][:-1]\n            else:\n                testId = line.strip().split()[0]\n\n            if testId not in ignoreIds and testId not in regIds:\n                nonRegIds[testId] = None\n        handle.close()\n    except Exception as e:\n        print \"Exception\"\n        print e\n        print \"error parsing junction ids for\", line\n\n        # print out these ids for later debugging use\n    # try:\n    #     if args.unalignedMode:\n    #         out_handle = open(\"\".join([\"/\".join([idDir, \"denovoNonGR\", args.sampleId]), \"_output.txt\"]), \"wb\")\n    #     else:\n    #         out_handle = open(\"\".join([\"/\".join([idDir, \"juncNonGR\", args.sampleId]), \"_output.txt\"]), \"wb\")\n    #\n    #     if args.verbose:\n    #         print \"ready to write ids to\", \"\".join(\n    #             [\"/\".join([idDir, \"denovoNonGR\", args.sampleId]), \"_output.txt\"]), \"or\", \"\".join(\n    #             [\"/\".join([idDir, \"juncNonGR\", args.sampleId]), \"_output.txt\"])\n    #         print \"num nonRegIds:\", str(len(nonRegIds))\n    #         print \"num regIds:\", str(len(regIds))\n    #\n    #     for i in nonRegIds:\n    #         out_handle.write(i)\n    #         out_handle.write(\"\\n\")\n    #     for i in regIds:\n    #         out_handle.write(i)\n    #         out_handle.write(\"\\n\")\n    #     out_handle.close()\n    # except Exception as e:\n    #     print \"Exception\"\n    #     print e\n    #     print \"writing ids for\", i\n\n\n# Get mismatch rate for the decoys in this dataset. This is total_mismatches / total_bases\ndef getDecoyMismatchRate():\n    aScore = 0  # sum of all alignment scores\n    numBases = 0\n\n    for j in junctions:\n        for r in junctions[j].decoyReads:\n            aScore += r.readStat\n            numBases += r.juncRead.readLen\n            # this is average aScore, so it is aScore for read 1 or avg for read1 and read2 if mate is not None\n            if r.useMate != None:\n                aScore += r.readStat  # need to double the contribution of aScore since that was the avg of the 2 mates\n                numBases += r.useMate.readLen  # and need to add the length of the mate\n\n    if numBases == 0:\n        return None\n    else:\n        return (aScore / -6.0) / numBases  # this is the mismatch rate per base observed in the decoys\n\n\n# param alignedReads: array of juncReadObj that aligned to the junction\ndef getPval(alignedReads):\n    if len(alignedReads) > 0:\n        useMMrate = globalDecoyMMrate\n\n        # total number of mismatches observed for all reads aligning to this junction, rounded to get integer which is required for poisson.cdf\n        num_mm = int(ceil(sum([x.readStat for x in alignedReads]) / -6.0))\n        num_bases = sum([x.juncRead.readLen for x in alignedReads]) + sum(\n            [x.useMate.readLen for x in alignedReads if x.useMate != None])\n\n        return 1 - poisson.cdf(num_mm, useMMrate * num_bases)\n    else:\n        return \"-\"\n\n\ndef getReadScores(alignedReads):\n    scores = []\n    if len(alignedReads) > 0:\n        a1Scores = [int(r.juncRead.aScore) for r in alignedReads]\n        if args.singleEnd:\n            scores = a1Scores\n        else:\n            a2Scores = [int(r.useMate.aScore) for r in alignedReads]\n            scores = zip(a1Scores, a2Scores)\n\n    return scores\n\n\n# per-junction p-value is calculated assuming number of mismatches is Poisson(0.01*avg_read_length)\n# .01 is the high end of the Illumina sequencing error rate\n# prints all junctions, even those that have no circular reads\ndef reportCircularReads(cutoff):\n    if args.unalignedMode:\n        report_handle = open(\"_\".join([\"/\".join([args.parentDir, args.outDirName, \"reports\", args.sampleId]), \"denovo_report.txt\"]), \"wb\")\n    else:\n        report_handle = open(\"_\".join([\"/\".join([args.parentDir, args.outDirName, \"reports\", args.sampleId]), \"report.txt\"]), \"wb\")\n\n    if cutoff:\n        report_handle.write(\"\".join([\"@Global alignment score cutoff: \", str(cutoff), \"\\n\"]))\n    else:\n        report_handle.write(\"\".join([\"@GUsing Poisson distribution with p=: \", str(globalDecoyMMrate), \"\\n\"]))\n    report_handle.write(\"@junction\\tlinear\\tanomaly\\tunmapped\\tmultimapped\\tcirc\\tdecoy\\t\")\n\n    # if we specified a read cutoff, the value returned is an FDR, otherwise it is a p-value using naive model\n    if cutoff:\n        report_handle.write(\"FDR\")\n    else:\n        report_handle.write(\"pvalue\")\n\n    report_handle.write(\"\\tscores\\n\")\n\n    for j in junctions:\n        # print out the junction and read id for all good reads\n        # either both mates need to pass threshold, or single-end read needs to pass Rd1 threshold\n        if cutoff:\n            numGood = 0  # track any linear or circular that passed the score threshold\n            for elem in junctions[j].circularReads:\n                if int(elem.juncRead.aScore) >= int(cutoff[0]) and (\n                    args.singleEnd or int(elem.useMate.aScore) >= int(cutoff[1])):\n                    numGood += 1\n\n            for elem in junctions[j].linearReads:\n                if int(elem.juncRead.aScore) >= int(cutoff[0]) and (\n                    args.singleEnd or int(elem.useMate.aScore) >= int(cutoff[1])):\n                    numGood += 1\n\n                    # print out global junction reads stats\n            numCandidates = len(junctions[j].circularReads) + len(junctions[j].linearReads)\n            numBad = numCandidates - numGood\n            if numCandidates > 0:\n                sig_stat = float(numBad) / numCandidates\n            else:\n                sig_stat = \"-\"\n        elif \"|reg|\" not in junctions[j].id:  # if it's a circular junction\n            sig_stat = getPval(junctions[j].circularReads)  # p-value\n        elif \"|reg|\" in junctions[j].id:  # or it is a linear junction\n            sig_stat = getPval(junctions[j].linearReads)  # p-value\n        else:\n            print \"cound not get sig stat for\", junctions[j].id\n            sig_stat = \"NA\"\n\n        report_handle.write(str(j) + \"\\t\")\n        report_handle.write(str(len(junctions[j].linearReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].anomalyReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].unmappedReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].multimappedReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].circularReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].decoyReads)) + \"\\t\")\n        report_handle.write(str(sig_stat) + \"\\t\")\n\n        if \"|reg|\" not in junctions[j].id:  # if it's a circular junction\n            scores = getReadScores(junctions[j].circularReads)\n        elif \"|reg|\" in junctions[j].id:  # or it is a linear junction\n            scores = getReadScores(junctions[j].linearReads)  # scores to print in report\n        else:\n            scores = []\n\n        if len(scores) > 10:\n            # if we have lots of scores for this junction, just write out the quantiles\n            for i in xrange(0, 101, 10):\n                if args.singleEnd:\n                    report_handle.write(str(scoreatpercentile(scores, i, interpolation_method='lower')) + \",\")\n                else:\n                    report_handle.write(\n                        str(scoreatpercentile([x[0] for x in scores], i, interpolation_method='lower')) + \":\" +\n                        str(scoreatpercentile([x[1] for x in scores], i, interpolation_method='lower')) + \",\")\n        else:\n            # otherwise we have just a few so let's just print them all out\n            for s in scores:\n                report_handle.write(str(s) + \",\")\n\n        report_handle.write(\"\\n\")\n\n        # store FDR for this junction so we can decide if we think it is an artifact or not\n        if sig_stat != \"-\" and sig_stat != \"NA\":\n            junctions[\n                j].fdr = sig_stat  # will need to update this variable name in juncObj if we are using p-values in the future instead of FDRs\n\n    report_handle.close()\n\n\ndef reportAllReadIds2(cutoff):\n    if args.unalignedMode:\n        id_handle = open(\n            \"_\".join([\"/\".join([args.parentDir, args.outDirName, \"ids\", args.sampleId]), \"denovo__output.txt\"]), \"wb\")\n    else:\n        id_handle = open(\"_\".join([\"/\".join([args.parentDir, args.outDirName, \"ids\", args.sampleId]), \"_output.txt\"]),\n                         \"wb\")\n\n    # use the column names used in R\n    id_handle.write(\"\\t\".join([\"id\", \"class\", \"pos\", \"qual\", \"aScore\", \"numN\", \"readLen\", \"junction\", \"strand\",\n                               \"posR2\", \"qualR2\", \"aScoreR2\", \"numNR2\", \"readLenR2\", \"junctionR2\", \"strandR2\"]) + \"\\n\")\n\n    for j in junctions:\n        # print circular read ids\n        for elem in junctions[j].circularReads:\n            # if we pass a cutoff for read1 and read2 scores, then we are calculating an FDR which we want to keep low\n            # otherwise we are calculating a probability of observing these reads under the null that this really is a circle and then we want to get rid of those with low p-values\n            if junctions[j].fdr and ((cutoff and float(junctions[j].fdr) > args.reportFDR)\n                                     or (not cutoff and float(junctions[j].fdr) < args.reportFDR)):\n                readClass = \"circArtifact\"\n            elif cutoff:\n                if int(elem.juncRead.aScore) >= int(cutoff[0]) and (\n                    args.singleEnd or int(elem.useMate.aScore) >= int(cutoff[1])):\n                    readClass = \"circStrong\"\n                else:\n                    readClass = \"circFailed\"\n            else:\n                readClass = \"circStrong\"\n\n            myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j), str(elem.juncRead.flag)])\n            if args.singleEnd:\n                pairInfo = \"\\t\".join([\"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\"])\n            else:\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n            id_handle.write(\"\\t\".join([str(elem.juncRead.name), readClass, myInfo, pairInfo]) + \"\\n\")\n\n        # print linear read ids\n        for elem in junctions[j].linearReads:\n            if junctions[j].fdr and ((cutoff and float(junctions[j].fdr) > args.reportFDR)\n                                     or (not cutoff and float(junctions[j].fdr) < args.reportFDR)):\n                readClass = \"linearArtifact\"\n            elif cutoff:\n                if int(elem.juncRead.aScore) >= int(globalCutOff[0]) and (\n                    args.singleEnd or int(elem.useMate.aScore) >= int(globalCutOff[1])):\n                    readClass = \"linearStrong\"\n                else:\n                    readClass = \"linearFailed\"\n            else:\n                readClass = \"linearStrong\"\n\n            myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j), str(elem.juncRead.flag)])\n            if args.singleEnd:\n                pairInfo = \"\\t\".join([\"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\"])\n            else:\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n            id_handle.write(\"\\t\".join([str(elem.juncRead.name), readClass, myInfo, pairInfo]) + \"\\n\")\n\n        # print multimapped read ids\n        for elem in junctions[j].multimappedReads:\n            myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j), str(elem.juncRead.flag)])\n            if args.singleEnd or not elem.useMate:\n                pairInfo = \"\\t\".join([\"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\"])\n            else:\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n            id_handle.write(\"\\t\".join([str(elem.juncRead.name), \"multimapped\", myInfo, pairInfo]) + \"\\n\")\n\n        # print decoy read ids\n        if not args.singleEnd:\n            for elem in junctions[j].decoyReads:\n                myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                    str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j),\n                                    str(elem.juncRead.flag)])\n\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n                id_handle.write(\"\\t\".join([str(elem.juncRead.name), \"decoy\", myInfo, pairInfo]) + \"\\n\")\n\n            # print anomaly read ids\n            for elem in junctions[j].anomalyReads:\n                myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                    str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j),\n                                    str(elem.juncRead.flag)])\n\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n                id_handle.write(\"\\t\".join([str(elem.juncRead.name), \"anomaly\", myInfo, pairInfo]) + \"\\n\")\n\n            # print unmapped read ids\n            for elem in junctions[j].unmappedReads:\n                myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                    str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j),\n                                    str(elem.juncRead.flag)])\n                pairInfo = \"\\t\".join([\"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\"])\n                id_handle.write(\"\\t\".join([str(elem.juncRead.name), \"unmapped\", myInfo, pairInfo]) + \"\\n\")\n\n    id_handle.close()\n\n\n# loop through sam file, either creating a juncReadObj & juncObj (if this is read1s)\n# or updating mateGenome, mateJunction, or mateRegJunction if this is an alignment file from read2\n# to genome, all junctions, or regular junctions respectively.\n# The sam file may contain both aligned and unaligned reads. Only aligned reads will actually be stored.\n# param readType: \"r1rj\" is Rd1 to regular junction index, \"r1j\" is Rd1 to all junction,\n#                 \"gMate\" is Rd2 to genome, \"jMate\" is Rd2 to all junction, \"rjMate\" is Rd2 to regular junction\ndef parseSam(samFile, readType):\n    if args.verbose:\n        logfile.write(\"samFile: \" + samFile)\n        logfile.write(\"readType: \" + readType)\n\n    handle = open(samFile, \"rU\")\n\n    for line in handle:\n        if not line.startswith(\"@\"):  # ignore header lines\n            try:\n                read = newReadObj(line.strip().split(), args.fastqIdStyle)\n                # only need to store info if the read actually aligned\n                if read.aScore:\n                    readBase = read.baseName  # part of the read that is the same between Rd1 and Rd2\n                    # read1 that didn't map to genome, or ribo and then mapped to reg junctions or to all junctions and not to reg junction\n                    # since in unaligned mode we report all reads, we want to only count the first time in the file we see it (output order is highest alignment score first)\n                    if ((readType == \"r1j\" and readBase in nonRegIds and readBase not in juncReads) or\n                            (readType == \"r1rj\" and readBase in regIds and readBase not in juncReads)):\n                        curJuncReadObj = juncReadObj(\n                            read)  # create object for this read (mate info empty for now) to put in junction and juncReads dicts\n                        juncReads[readBase] = curJuncReadObj  # will look up this obj later to populate mates\n\n                        # this is first read aligning to this junction, need to create juncObj first\n                        if not read.refName in junctions:\n                            curJuncObj = juncObj(read.refName)\n                            junctions[read.refName] = curJuncObj\n                        # initially just append all reads to unknownReads, we will later remove some and move to circularReads, decoyReads, or unmappedReads\n                        junctions[read.refName].unknownReads.append(curJuncReadObj)\n                    elif readBase in juncReads:  # this is a mate so we only care about it if it's Rd1 was stored\n                        if readType == \"gMate\" and not juncReads[\n                            readBase].mateGenomic:  # only if we haven't already found the primary genomic alignment\n                            juncReads[readBase].mateGenomic = read\n                        else:\n                            # this is a junction mate, need to check offset\n                            if (int(read.offset) >= (JUNC_MIDPOINT - int(read.readLen) + args.overhang + 1) and\n                                        int(read.offset) <= (JUNC_MIDPOINT - args.overhang + 1)):\n                                # if it overlaps the junction, add it to the appropriate mate field\n                                if readType == \"jMate\" and not juncReads[\n                                    readBase].mateJunction:  # only if we haven't already found the primary junction alignment\n                                    juncReads[readBase].mateJunction = read\n                                elif readType == \"rjMate\" and not juncReads[\n                                    readBase].mateRegJunction:  # only if we haven't already found the primary reg junction alignment\n                                    juncReads[readBase].mateRegJunction = read\n                                elif readType == \"dMate\" and not juncReads[\n                                    readBase].mateDenovoJunction:  # only if we haven't already found the primary denovo junction alignment\n                                    juncReads[readBase].mateDenovoJunction = read\n            except Exception as e:\n                logfile.write(\"Exception\")\n                logfile.write(e)\n                logfile.write(\"parsing sam output for \" + line)\n\n    handle.close()\n\n\ndef updateReads():\n    # for each junction\n    for j in junctions:\n        # all reads were initially assigned to unknownReads, need to see which are circular,etc\n        while len(junctions[j].unknownReads) > 0:\n            r = junctions[j].unknownReads.pop()\n            r.updateInfo(junctions[j], args.singleEnd, args.unalignedMode)  # figure out which mate is best, whether this means it is decoy or not\n\n            # assign read to correct bucket\n            if r.readType == \"c\":\n                junctions[j].circularReads.append(r)\n            elif r.readType == \"d\":\n                junctions[j].decoyReads.append(r)\n            elif r.readType == \"l\":\n                junctions[j].linearReads.append(r)\n            elif r.readType == \"a\":\n                junctions[j].anomalyReads.append(r)\n            elif r.readType == \"i\":\n                # we are ignoring this read because Rd1 aligned to reg and Rd2 aligned to scrambled\n                pass\n            else:\n                if r.mateGenomic or r.mateJunction or r.mateRegJunction or r.mateDenovoJunction:\n                    # the mate did map, but had very poor mapping quality so we are discarding it\n                    junctions[j].multimappedReads.append(r)\n                else:\n                    # either mate was not in the file or did not align to either genome or junction index\n                    junctions[j].unmappedReads.append(r)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-p', '--parentDir', help='path to alignment parent directory for this dataset', required=True)\n    parser.add_argument('-s', '--sampleId', help='string used to identify this sample', required=True)\n    parser.add_argument('-o', '--outDirName', help='name of directory to output files under parentDir, created if does not exist', required=True)\n    parser.add_argument('-q', '--fastqIdStyle', help='type of read ids used', required=True, choices=['appended', 'complete'])\n    parser.add_argument('-f', '--reportFDR', help='FDR to select circular artifacts in report', type=float, default=0.9)\n    parser.add_argument('-e', '--seqErrorRate', help='per base sequencing error rate', type=float, default=0.01)\n    parser.add_argument('-a1', '--aScore1', help='specify bowtie min AS for read1 instead of using global FDR cutoff',type=int)\n    parser.add_argument('-a2', '--aScore2', help='specify bowtie min AS for read1 instead of using global FDR cutoff', type=int)\n    parser.add_argument('-oh', '--overhang', help='how much you want the read to overlap a junction to be considered aligned to junction', type=int, required=True)\n    parser.add_argument('-j', '--junctionIdDirSuffix', help='suffix appended to junc and reg to find overlapped reads for this run', default='')\n    parser.add_argument('-se', '--singleEnd', help='is this single end read data', action='store_true')\n    parser.add_argument('-u', '--unalignedMode', help='is this an unaligned mode run', action='store_true')\n    parser.add_argument('-v', '--verbose', help='print extra debugging info', action='store_true')\n\n    parser.add_argument('-gens1', '--genomeSAM1', help='path to the alignment of read1 to genome', required=True)\n    parser.add_argument('-gens2', '--genomeSAM2', help='path to the alignment of read2 to genome', required=True)\n    parser.add_argument('-gent1', '--genomeTXT1', help='path to the alignment of read1 to genome (txt file)', required=True)\n    parser.add_argument('-gent2', '--genomeTXT2', help='path to the alignment of read2 to genome (txt file)', required=True)\n\n    parser.add_argument('-ribs1', '--ribosomalSAM1', help='path to the alignment of read1 to ribosomal', required=True)\n    parser.add_argument('-ribs2', '--ribosomalSAM2', help='path to the alignment of read2 to ribosomal', required=True)\n    parser.add_argument('-ribt1', '--ribosomalTXT1', help='path to the alignment of read1 to ribosomal (txt file)', required=True)\n    parser.add_argument('-ribt2', '--ribosomalTXT2', help='path to the alignment of read2 to ribosomal (txt file)', required=True)\n\n    parser.add_argument('-regs1', '--regularSAM1', help='path to the alignment of read1 to regular junction', required=True)\n    parser.add_argument('-regs2', '--regularSAM2', help='path to the alignment of read2 to regular junction', required=True)\n    parser.add_argument('-regt1', '--regularTXT1', help='path to the alignment of read1 to regular junction (txt file)', required=True)\n    parser.add_argument('-regt2', '--regularTXT2', help='path to the alignment of read2 to regular junction (txt file)', required=True)\n\n    parser.add_argument('-scrs1', '--scrambledSAM1', help='path to the alignment of read1 to scrambled junction', required=True)\n    parser.add_argument('-scrs2', '--scrambledSAM2', help='path to the alignment of read2 to scrambled junction', required=True)\n    parser.add_argument('-scrt1', '--scrambledTXT1', help='path to the alignment of read1 to scrambled junction (txt file)', required=True)\n    parser.add_argument('-scrt2', '--scrambledTXT2', help='path to the alignment of read2 to scrambled junction (txt file)', required=True)\n\n    parser.add_argument('-jm', '--junctionMidpoint', help = 'Junction midpoint', type=int, default=150)\n\n    args = parser.parse_args()\n\n    if args.verbose:\n        logfile.write(\"parentDir: \" + args.parentDir + \"\\n\")\n        logfile.write(\"sampleId: \" + args.sampleId + \"\\n\")\n        logfile.write(\"outDirName: \" + args.outDirName + \"\\n\")\n        logfile.write(\"style: \" + args.fastqIdStyle + \"\\n\")\n        logfile.write(\"a1: \" + args.aScore1 + \"\\n\")\n        logfile.write(\"a2: \" + args.aScore2 + \"\\n\")\n        logfile.write(\"overhang: \" + args.overhang + \"\\n\")\n        logfile.write(\"id dir suffix: \" + args.junctionIdDirSuffix + \"\\n\")\n        logfile.write(\"unaligned: \" + args.unalignedMode + \"\\n\")\n\n    # make output dirs if they don't exist\n    utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName]))\n    utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName, \"reports\"]))  # these are the reports using the naive method\n    #utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName, \"glmReports\"]))  # GLM will be run later and those reports will be stored here\n    #utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName, \"glmModels\"]))  # GLM will be run later and those models will be stored here\n    utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName, \"ids\"]))  # txt files of read ids assigned to circular or linear category\n    # just doing read1s\n    if args.sampleId.endswith(\"1\"):\n\n        try:\n            # populate the ignoreIds, regIds, nonRegIds for this file and also print out regIds and nonRegIds to juncNonGR file\n            ignoreIds = {}  # ribo and genome aligned\n            regIds = {}  # regular junction overlapped and not ribo or genome aligned (aligned to reg-only index)\n            nonRegIds = {}  # junction overlapped and not ribo or genome aligned or regular-junction aligned\n\n            # we treat denovo reads as the equivalent of the junction reads in unalignedMode\n            if args.unalignedMode:\n                useJuncStr = \"denovo\"\n            else:\n                useJuncStr = \"junction\"\n            logfile.write(\"Start log file\\n\")\n            selectCandidateIds()\n            logfile.write(\"SelectCandidateIds finished\\n\")\n\n            #if args.verbose:\n            #    print \"ignoreIds (aligned to genome):\", str(len(ignoreIds))\n            #    print \"linearIds:\", str(len(regIds))\n            #    print \"scrambledIds:\", str(len(nonRegIds))\n\n            logfile.write(\"ignoreIds (aligned to genome):\" + str(len(ignoreIds)) + \"\\n\")\n            logfile.write(\"linearIds:\" + str(len(regIds)) + \"\\n\")\n            logfile.write(\"scrambledIds:\" + str(len(nonRegIds)) + \"\\n\")\n\n            juncReads = {}  # base read id: juncReadObj\n            junctions = {}  # junction id: list of juncObjs mapping to this junction\n\n            if not args.unalignedMode:\n                # make a pass through the sam file for read 1 to regular junctions to populate dict with juncReadObjs (key is portion of read id shared by Rd1 and Rd2)\n                #     and at the same time create entry in junction dictionary and add this read obj to the junction list of reads\n                #parseSam(\"\".join([\"/\".join([args.parentDir, \"orig\", \"reg\", args.sampleId]), \"_reg_output.sam\"]), \"r1rj\")\n                parseSam(args.regularSAM1, \"r1rj\")\n                logfile.write(\"RegularSAM1 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n            # make a pass through the sam for read 1 to all junctions file to populate dict with juncReadObjs (key is portion of read id shared by Rd1 and Rd2)\n            #     and at the same time create entry in junction dictionary and add this read obj to the junction list of reads\n            #parseSam(\"_\".join([\"/\".join([args.parentDir, \"orig\", useJuncStr, args.sampleId]), useJuncStr, \"output.sam\"]), \"r1j\")\n                parseSam(args.scrambledSAM1, \"r1j\")\n                logfile.write(\"ScrambledSAM1 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n            # get mate alignment data if this is from paired end sequencing\n            if not args.singleEnd:\n                if args.unalignedMode:\n                    alignedMateId = args.sampleId[10:-1] + \"2\"  # trim off unaligned_ from start of id, change 1 to 2\n                else:\n                    alignedMateId = args.sampleId[:-1] + \"2\"\n\n                # make a pass through Rd2 to genome sam file to update mateGenomic in each juncReadObj\n                #parseSam(\"\".join([\"/\".join([args.parentDir, \"orig\", \"genome\", alignedMateId]), \"_genome_output.sam\"]), \"gMate\")\n                parseSam(args.genomeSAM2, \"gMate\")\n                logfile.write(\"GenomeSAM2 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n                # make a pass through Rd2 to junction sam file to update mateRegJunction in each juncReadObj\n                #parseSam(\"\".join([\"/\".join([args.parentDir, \"orig\", \"reg\", alignedMateId]), \"_reg_output.sam\"]), \"rjMate\")\n                parseSam(args.regularSAM2, \"rjMate\")\n                logfile.write(\"RegularSAM2 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n                # make a pass through Rd2 to junction sam file to update mateJunction in each juncReadObj\n                #parseSam(\"\".join([\"/\".join([args.parentDir, \"orig\", \"junction\", alignedMateId]), \"_junction_output.sam\"]), \"jMate\")\n                parseSam(args.scrambledSAM2, \"rjMate\")\n                logfile.write(\"ScrambledSAM2 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n                # make a pass through Rd2 to de novo sam file to update mateDenovo in each juncReadObj\n                #if args.unalignedMode:\n                #    parseSam(\"\".join(\n                #        [\"/\".join([args.parentDir, \"orig\", \"denovo\", args.sampleId[:-1]]), \"2_denovo_output.sam\"]),\n                #             \"dMate\")\n\n            if args.verbose:\n                logfile.write(\"sample id: \" + str(args.sampleId))\n                logfile.write(\"single end? \" + str(args.singleEnd))\n                logfile.write(\"num junctions with aligned reads: \" + str(len(junctions)))\n                logfile.write(\"num reads: \" + str(len(juncReads)))\n\n            logfile.write(\"Num junctions with aligned reads: \" + str(len(junctions)))\n            logfile.write(\"Num reads: \" + str(len(juncReads)))\n\n            updateReads()  # assign reads to categories based on alignment data (circular, linear, decoy, etc)\n\n            # print out some alignment statistics after reads have all been assigned to a category\n            if args.verbose:\n                numCirc = numDecoy = numLinear = numAnomaly = numUnmapped = numMultimapped = numUnknown = 0\n                for j in junctions:\n                    numCirc = numCirc + len(junctions[j].circularReads)\n                    numDecoy = numDecoy + len(junctions[j].decoyReads)\n                    numLinear = numLinear + len(junctions[j].linearReads)\n                    numAnomaly = numAnomaly + len(junctions[j].anomalyReads)\n                    numUnmapped = numUnmapped + len(junctions[j].unmappedReads)\n                    numMultimapped = numMultimapped + len(junctions[j].multimappedReads)\n                    numUnknown = numUnknown + len(junctions[j].unknownReads)\n                logfile.write(\"number of reads kept in each category after update (multimapped & unknown should be 0, anomaly & decoy should be 0 for SE data):\\n\")\n                logfile.write(\"circ: \" + str(numCirc) + \", decoy: \" + str(numDecoy) + \", linear: \" + str(\n                    numLinear) + \", anomaly: \" + str(numAnomaly) + \", unmapped: \" + str(\n                    numUnmapped) + \", multimapped: \" + str(numMultimapped) + \", unknown: \" + str(numUnknown) + \"\\n\")\n                logfile.write(str(sum([numCirc, numDecoy, numLinear, numAnomaly, numUnmapped, numMultimapped, numUnknown])) + \"\\n\")\n\n            numCirc = numDecoy = numLinear = numAnomaly = numUnmapped = numMultimapped = numUnknown = 0\n            for j in junctions:\n                numCirc = numCirc + len(junctions[j].circularReads)\n                numDecoy = numDecoy + len(junctions[j].decoyReads)\n                numLinear = numLinear + len(junctions[j].linearReads)\n                numAnomaly = numAnomaly + len(junctions[j].anomalyReads)\n                numUnmapped = numUnmapped + len(junctions[j].unmappedReads)\n                numMultimapped = numMultimapped + len(junctions[j].multimappedReads)\n                numUnknown = numUnknown + len(junctions[j].unknownReads)\n            logfile.write(\"number of reads kept in each category after update (multimapped & unknown should be 0, anomaly & decoy should be 0 for SE data):\\n\")\n            logfile.write(\"circ: \" + str(numCirc) + \", decoy: \" + str(numDecoy) + \", linear: \" + str(numLinear) + \", anomaly: \" + str(numAnomaly) + \", unmapped: \" + str(numUnmapped) + \", multimapped: \" + str(numMultimapped) + \", unknown: \" + str(numUnknown) + \"\\n\")\n            logfile.write(str(sum([numCirc, numDecoy, numLinear, numAnomaly, numUnmapped, numMultimapped, numUnknown])) + \"\\n\")\n\n\n            if args.aScore1 and args.aScore2:\n                globalCutOff = (args.aScore1, args.aScore2)\n                globalDecoyMMrate = None\n                if args.verbose:\n                    logfile.write(\"globalCutOff specified: \" + str(globalCutOff) + \"\\n\")\n            else:\n                # use decoy distribution\n                globalCutOff = None\n                globalDecoyMMrate = getDecoyMismatchRate()\n\n                # if there were no decoys, use the default seqErrorRate\n                if globalDecoyMMrate == None:\n                    globalDecoyMMrate = args.seqErrorRate\n\n                if args.verbose:\n                    logfile.write(\"using decoy rate: \" + str(globalDecoyMMrate) + \"\\n\")\n\n            logfile.write(\"using decoy rate: \" + str(globalDecoyMMrate) + \"\\n\")\n            reportCircularReads(globalCutOff)  # output reports\n            reportAllReadIds2(globalCutOff)  # output ids used in the reports for further manual investigation if desired + GLM uses these category assignments\n\n        except Exception as e:\n            logfile.write(\"Exception\\n\")\n            logfile.write(e)",
                "filename": "filterFDR.py"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "inputs": [
          {
            "label": "Scrambled txt files",
            "description": "Txt files which contain information about all reads aligned to the scrambled junction.",
            "sbg:category": "Input",
            "sbg:fileTypes": "TXT",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 12,
              "itemSeparator": null,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_txt)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrt1 \" + inputs[i].path\n        else\n          cmd += \" -scrt2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              }
            },
            "id": "#scrambled_txt",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "label": "Scrambled SAM files",
            "description": "Sam files obtained by aligning paired_end fastq files as single-end files to the scrambled junction.",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 11,
              "itemSeparator": null,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              }
            },
            "id": "#scrambled_sam",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "label": "Ribosomal txt files",
            "description": "Txt files which contain information about all reads aligned to the ribosomal reference.",
            "sbg:category": "Input",
            "sbg:fileTypes": "TXT",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 8,
              "itemSeparator": null,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.ribosomal_txt)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -ribt1 \" + inputs[i].path\n        else\n          cmd += \" -ribt2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              }
            },
            "id": "#ribosomal_txt",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "label": "Ribosomal sam files",
            "description": "Sam files obtained by aligning paired_end fastq files as single-end files to the ribosomal reference.",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 7,
              "itemSeparator": null,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.ribosomal_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -ribs1 \" + inputs[i].path\n        else\n          cmd += \" -ribs2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              }
            },
            "id": "#ribosomal_sam",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "label": "Regular txt files",
            "description": "Txt files which contain information about all reads aligned to the regular junction.",
            "sbg:category": "Input",
            "sbg:fileTypes": "TXT",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 10,
              "itemSeparator": null,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_txt)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regt1 \" + inputs[i].path\n        else\n          cmd += \" -regt2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              }
            },
            "id": "#regular_txt",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "label": "Regular SAM files",
            "description": "Sam files obtained by aligning paired_end fastq files as single-end files to the regular junction.",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 9,
              "itemSeparator": null,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              }
            },
            "id": "#regular_sam",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "sbg:toolDefaultValue": "8",
            "label": "Overlap",
            "sbg:altPrefix": "--overhang",
            "description": "Number of bases the read needs to overlap a junction to be considered aligned to junction",
            "sbg:category": "Input",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 2,
              "prefix": "-oh",
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "$job.inputs.overlap|8"
              }
            },
            "id": "#overlap",
            "type": [
              "null",
              "int"
            ],
            "sbg:includeInPorts": true,
            "required": false
          },
          {
            "label": "Mode",
            "sbg:altPrefix": "--fastqIdStyle",
            "description": "\"Appended\" mode should be selected if read_ids in first mate ends with 1 and in the second. If reads have the same read_id in both paired_end files, \"complete\" should be selected.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 3,
              "prefix": "-q"
            },
            "id": "#mode",
            "type": [
              {
                "symbols": [
                  "appended",
                  "complete"
                ],
                "name": "mode",
                "type": "enum"
              }
            ],
            "sbg:includeInPorts": true,
            "required": true
          },
          {
            "label": "Genome txt file",
            "description": "Txt files which contain information about all reads aligned to the genome reference.",
            "sbg:category": "Input",
            "sbg:fileTypes": "TXT",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 6,
              "itemSeparator": null,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_txt)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gent1 \" + inputs[i].path\n        else\n          cmd += \" -gent2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              }
            },
            "id": "#genome_txt",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          },
          {
            "label": "Genome sam files",
            "description": "Sam files obtained by aligning paired_end fastq files as single-end files to the genome reference.",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 5,
              "itemSeparator": null,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}"
              }
            },
            "id": "#genome_sam",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": true
          }
        ],
        "outputs": [
          {
            "label": "Report",
            "description": "Report contains information about junctions",
            "sbg:fileTypes": "TXT",
            "type": [
              "null",
              "File"
            ],
            "id": "#report",
            "outputBinding": {
              "glob": "./output/reports/*",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n"
                }
              }
            }
          },
          {
            "label": "Output",
            "description": "Output contains information about reads.",
            "sbg:fileTypes": "TXT",
            "type": [
              "null",
              "File"
            ],
            "id": "#output",
            "outputBinding": {
              "glob": "./output/ids/*",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n"
                }
              }
            }
          },
          {
            "id": "#logfile_no_sym",
            "outputBinding": {
              "glob": "logfile_no_sym.txt"
            },
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 59000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "c4.8xlarge;ebs-gp2;1024"
          }
        ],
        "baseCommand": [
          "mkdir",
          "output",
          "&&",
          "python",
          "filterFDR.py",
          "-p",
          "./",
          "-o",
          "output"
        ],
        "stdin": "",
        "stdout": "",
        "successCodes": [],
        "temporaryFailCodes": [],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id + \"_1\"\n          break\n    }\n\treturn cmd\n}"
            }
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:job": {
          "inputs": {
            "ribosomal_txt": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/ribosomal_txt-1.ext",
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/ribosomal_txt-2.ext",
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "genome_sam": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/genome_sam-1.ext",
                "metadata": {
                  "paired_end": "1",
                  "sample_id": "sample_name"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/genome_sam-2.ext",
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "regular_sam": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/regular_sam-1.ext",
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/regular_sam-2.ext",
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "mode": "appended",
            "ribosomal_sam": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/ribosomal_sam-1.ext",
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/ribosomal_sam-2.ext",
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "scrambled_sam": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/scrambled_sam-1.ext",
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/scrambled_sam-2.ext",
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "scrambled_txt": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/scrambled_txt-1.ext",
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/scrambled_txt-2.ext",
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "overlap": 5,
            "regular_txt": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/regular_txt-1.ext",
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/regular_txt-2.ext",
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "genome_txt": [
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/genome_txt-1.ext",
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "class": "File",
                "secondaryFiles": [],
                "size": 0,
                "path": "/path/to/genome_txt-2.ext",
                "metadata": {
                  "paired_end": "2"
                }
              }
            ]
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 59000
          }
        },
        "sbg:links": [
          {
            "label": "Publication (KNIFE)",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed/26076956"
          }
        ],
        "sbg:cmdPreview": "mkdir output && python filterFDR.py -p ./ -o output  -s sample_name_1 -q appended   -gens1 /path/to/genome_sam-1.ext -gens2 /path/to/genome_sam-2.ext   -gent1 /path/to/genome_txt-1.ext -gent2 /path/to/genome_txt-2.ext   -ribs1 /path/to/ribosomal_sam-1.ext -ribs2 /path/to/ribosomal_sam-2.ext   -ribt1 /path/to/ribosomal_txt-1.ext -ribt2 /path/to/ribosomal_txt-2.ext   -regs1 /path/to/regular_sam-1.ext -regs2 /path/to/regular_sam-2.ext   -regt1 /path/to/regular_txt-1.ext -regt2 /path/to/regular_txt-2.ext   -scrs1 /path/to/scrambled_sam-1.ext -scrs2 /path/to/scrambled_sam-2.ext   -scrt1 /path/to/scrambled_txt-1.ext -scrt2 /path/to/scrambled_txt-2.ext",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:image_url": null,
        "sbg:categories": [
          "RNA-seq"
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432529,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520432567,
            "sbg:revisionNotes": "revision 21 copied"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1527007840,
            "sbg:revisionNotes": "logfile instead of print"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1555673133,
            "sbg:revisionNotes": "# myScore = str(int(myScore) + numN)"
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:modifiedOn": 1566586349,
            "sbg:revisionNotes": "back to revision 2"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/filterfdr/4",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/filterfdr/4",
        "sbg:revision": 4,
        "sbg:revisionNotes": "back to revision 2",
        "sbg:modifiedOn": 1566586349,
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:createdOn": 1520432529,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jordanski.milos",
          "milos_jordanski"
        ],
        "sbg:latestRevision": 4,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ad278c67d0198b31d4280eb874a6ab23f866550668ffec4d85b5e8d1a85aaa73a",
        "x": 1206.6678258048594,
        "y": -153.28141764593363
      },
      "inputs": [
        {
          "id": "#KNIFE_filterFDR.scrambled_txt",
          "source": [
            "#Knife_Preprocess_Aligned_Reads_3.aligned_reads"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.scrambled_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.result_sam_file"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.ribosomal_txt",
          "source": [
            "#Knife_Preprocess_Aligned_Reads_1.aligned_reads"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.ribosomal_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_RIBOSOMAL.result_sam_file"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.regular_txt",
          "source": [
            "#Knife_Preprocess_Aligned_Reads_2.aligned_reads"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.regular_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.result_sam_file"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.genome_txt",
          "source": [
            "#Knife_Preprocess_Aligned_Reads.aligned_reads"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.genome_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_GENOME.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_filterFDR.report"
        },
        {
          "id": "#KNIFE_filterFDR.output"
        },
        {
          "id": "#KNIFE_filterFDR.logfile_no_sym"
        }
      ],
      "sbg:x": 1206.6678258048594,
      "sbg:y": -153.28141764593363
    },
    {
      "id": "#Knife_Preprocess_Aligned_Reads_3",
      "run": {
        "inputs": [
          {
            "id": "#overlap",
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "sbg:includeInPorts": true
          },
          {
            "id": "#output_name",
            "required": false,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "id": "#junction_midpoint",
            "required": false,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "id": "#input_sam",
            "required": true,
            "type": [
              "File"
            ]
          },
          {
            "id": "#aligned_reference",
            "required": true,
            "type": [
              {
                "symbols": [
                  "ribosomal",
                  "genome",
                  "regular",
                  "scrambled"
                ],
                "name": "aligned_reference",
                "type": "enum"
              }
            ]
          }
        ],
        "sbg:revisionNotes": "revision 4 copied",
        "stdout": "",
        "cwlVersion": "sbg:draft-2",
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \toutput_file_name = $job.inputs.input_sam.path.split(\"/\").pop()\n    output_file_name = output_file_name.slice(0, output_file_name.length - 4)\n  \tif ($job.inputs.output_name)\n    {\n    \toutput_file_name = $job.inputs.output_name\n    }\n\tif($job.inputs.aligned_reference == \"genome\" || $job.inputs.aligned_reference == \"ribosomal\")\n    {\n      \treturn \"awk '$1 !~ /^@/ && $2 != 4 {print $1  \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3 \\\"\\\\t\\\" $4}' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n  \telse if($job.inputs.aligned_reference == \"regular\" || $job.inputs.aligned_reference == \"scrambled\")\n    {\n    \treturn \"awk \\'$1 !~ /^@/ && $4 >= \" + $job.inputs.junction_midpoint + \" -length($10)+ \" + $job.inputs.overlap + \" +1 && $4 <= \" + $job.inputs.junction_midpoint + \"- \" + $job.inputs.overlap + \" +1 {print $1 \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3}\\' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n}"
            }
          }
        ],
        "label": "Knife Preprocess Aligned Reads",
        "temporaryFailCodes": [],
        "baseCommand": [
          ""
        ],
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:job": {
          "inputs": {
            "aligned_reference": "ribosomal",
            "overlap": 5,
            "output_name": "output_name-string-value",
            "input_sam": {
              "class": "File",
              "secondaryFiles": [],
              "size": 0,
              "path": "/path/to/input_sam.sam"
            },
            "junction_midpoint": 3
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#aligned_reads",
            "outputBinding": {
              "glob": "*.txt",
              "sbg:inheritMetadataFrom": "#input_sam"
            }
          }
        ],
        "sbg:cmdPreview": "awk '$1 !~ /^@/ && $2 != 4 {print $1  \"\\t\" $2 \"\\t\" $3 \"\\t\" $4}' /path/to/input_sam.sam > output_name-string-value.txt",
        "description": "",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "class": "CommandLineTool",
        "sbg:image_url": null,
        "successCodes": [],
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:publisher": "sbg",
        "stdin": "",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520442509,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520442544,
            "sbg:revisionNotes": "revision 4 copied"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "ubuntu"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:revision": 1,
        "sbg:modifiedOn": 1520442544,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:createdOn": 1520442509,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:latestRevision": 1,
        "sbg:content_hash": null,
        "x": 1055.000041921934,
        "y": 68.38541971519594
      },
      "inputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.output_name"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.junction_midpoint",
          "default": 150
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.input_sam",
          "source": [
            "#Bowtie2_2_3_4_1_Aligner_Input_List_SCRAMBLED_JUNCTIONS.result_sam_file"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.aligned_reference",
          "default": "scrambled"
        }
      ],
      "outputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.aligned_reads"
        }
      ],
      "sbg:x": 1055.000041921934,
      "sbg:y": 68.38541971519594,
      "scatter": "#Knife_Preprocess_Aligned_Reads_3.input_sam"
    },
    {
      "id": "#Knife_Preprocess_Aligned_Reads_2",
      "run": {
        "inputs": [
          {
            "id": "#overlap",
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "sbg:includeInPorts": true
          },
          {
            "id": "#output_name",
            "required": false,
            "type": [
              "null",
              "string"
            ]
          },
          {
            "id": "#junction_midpoint",
            "required": false,
            "type": [
              "null",
              "int"
            ]
          },
          {
            "id": "#input_sam",
            "required": true,
            "type": [
              "File"
            ]
          },
          {
            "id": "#aligned_reference",
            "required": true,
            "type": [
              {
                "symbols": [
                  "ribosomal",
                  "genome",
                  "regular",
                  "scrambled"
                ],
                "name": "aligned_reference",
                "type": "enum"
              }
            ]
          }
        ],
        "sbg:revisionNotes": "revision 4 copied",
        "stdout": "",
        "cwlVersion": "sbg:draft-2",
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  \toutput_file_name = $job.inputs.input_sam.path.split(\"/\").pop()\n    output_file_name = output_file_name.slice(0, output_file_name.length - 4)\n  \tif ($job.inputs.output_name)\n    {\n    \toutput_file_name = $job.inputs.output_name\n    }\n\tif($job.inputs.aligned_reference == \"genome\" || $job.inputs.aligned_reference == \"ribosomal\")\n    {\n      \treturn \"awk '$1 !~ /^@/ && $2 != 4 {print $1  \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3 \\\"\\\\t\\\" $4}' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n  \telse if($job.inputs.aligned_reference == \"regular\" || $job.inputs.aligned_reference == \"scrambled\")\n    {\n    \treturn \"awk \\'$1 !~ /^@/ && $4 >= \" + $job.inputs.junction_midpoint + \" -length($10)+ \" + $job.inputs.overlap + \" +1 && $4 <= \" + $job.inputs.junction_midpoint + \"- \" + $job.inputs.overlap + \" +1 {print $1 \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3}\\' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n}"
            }
          }
        ],
        "label": "Knife Preprocess Aligned Reads",
        "temporaryFailCodes": [],
        "baseCommand": [
          ""
        ],
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:job": {
          "inputs": {
            "aligned_reference": "ribosomal",
            "overlap": 5,
            "output_name": "output_name-string-value",
            "input_sam": {
              "class": "File",
              "secondaryFiles": [],
              "size": 0,
              "path": "/path/to/input_sam.sam"
            },
            "junction_midpoint": 3
          },
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          }
        },
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#aligned_reads",
            "outputBinding": {
              "glob": "*.txt",
              "sbg:inheritMetadataFrom": "#input_sam"
            }
          }
        ],
        "sbg:cmdPreview": "awk '$1 !~ /^@/ && $2 != 4 {print $1  \"\\t\" $2 \"\\t\" $3 \"\\t\" $4}' /path/to/input_sam.sam > output_name-string-value.txt",
        "description": "",
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "class": "CommandLineTool",
        "sbg:image_url": null,
        "successCodes": [],
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:publisher": "sbg",
        "stdin": "",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520442509,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:modifiedOn": 1520442544,
            "sbg:revisionNotes": "revision 4 copied"
          }
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "ubuntu"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "sbg:revision": 1,
        "sbg:modifiedOn": 1520442544,
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:createdOn": 1520442509,
        "sbg:createdBy": "milos_jordanski",
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:latestRevision": 1,
        "sbg:content_hash": null,
        "x": 1051.666667567358,
        "y": -58.281250382049194
      },
      "inputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.output_name"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.junction_midpoint",
          "default": 150
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.input_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_Input_List_REGULAR_JUNCTIONS.result_sam_file"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.aligned_reference",
          "default": "regular"
        }
      ],
      "outputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.aligned_reads"
        }
      ],
      "sbg:x": 1051.666667567358,
      "sbg:y": -58.281250382049194,
      "scatter": "#Knife_Preprocess_Aligned_Reads_2.input_sam"
    }
  ],
  "requirements": [],
  "inputs": [
    {
      "sbg:x": 589.3334178527224,
      "id": "#fastq_files",
      "type": [
        "null",
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:y": -492.00006829367976,
      "sbg:fileTypes": "FQ,FASTQ,FQ.GZ,FASTQ.GZ",
      "label": "fastq_files"
    },
    {
      "sbg:x": 2197,
      "id": "#gtfs_info",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -350,
      "label": "gtfs_info"
    },
    {
      "sbg:x": 2355.0002710686886,
      "sbg:includeInPorts": true,
      "id": "#ambiguous_character_penalty",
      "type": [
        "null",
        "string"
      ],
      "sbg:y": 256.6667241520373,
      "label": "ambiguous_character_penalty"
    },
    {
      "sbg:x": 2005.000000079474,
      "id": "#gtfs_info_seq",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 281.6666664547394,
      "label": "gtfs_info_seq"
    },
    {
      "label": "bin_size",
      "id": "#bin_size",
      "type": [
        "null",
        "int"
      ],
      "sbg:includeInPorts": true,
      "sbg:x": 1888.333450052476,
      "sbg:y": 193.33333433998948
    },
    {
      "sbg:x": 5374.002164085787,
      "sbg:includeInPorts": true,
      "id": "#bowtie_index_archive_regular_indels_1",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:y": 221.66684840785834,
      "sbg:fileTypes": "TAR",
      "label": "bowtie_index_archive_regular_indels_1"
    },
    {
      "label": "bowtie_index_archive_regular_indels_2",
      "id": "#bowtie_index_archive_regular_indels_2",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:includeInPorts": true,
      "sbg:x": 5520.001195907635,
      "sbg:y": 223.33348019918364
    },
    {
      "label": "bowtie_index_archive_regular_indels_3",
      "id": "#bowtie_index_archive_regular_indels_3",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:includeInPorts": true,
      "sbg:x": 5375.000536190155,
      "sbg:y": 325.0000448226943
    },
    {
      "label": "bowtie_index_archive_regular_indels_4",
      "id": "#bowtie_index_archive_regular_indels_4",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:includeInPorts": true,
      "sbg:x": 5521.667518907153,
      "sbg:y": 328.33335575792586
    },
    {
      "label": "bowtie_index_archive_regular_indels_5",
      "id": "#bowtie_index_archive_regular_indels_5",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:includeInPorts": true,
      "sbg:x": 5450.000358992163,
      "sbg:y": 420.0000573131792
    },
    {
      "sbg:x": 588.0002466970112,
      "sbg:includeInPorts": true,
      "id": "#bowtie_index_archive_genome",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:y": -202.66672617859527,
      "sbg:fileTypes": "TAR",
      "label": "bowtie_index_archive_genome"
    },
    {
      "sbg:x": 589.3333814011692,
      "sbg:includeInPorts": true,
      "id": "#bowtie_index_archive_regular_junctions",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:y": -67.9999870459233,
      "sbg:fileTypes": "TAR",
      "label": "bowtie_index_archive_regular_junctions"
    },
    {
      "sbg:x": 589.6667350265734,
      "sbg:includeInPorts": true,
      "id": "#bowtie_index_archive_scrambled_junctions",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:y": 66.33336427476786,
      "sbg:fileTypes": "TAR",
      "label": "bowtie_index_archive_scrambled_junctions"
    },
    {
      "sbg:x": 4034.511222528529,
      "sbg:includeInPorts": true,
      "id": "#bowtie_index_archive_transcriptome",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:y": 196.90214865348642,
      "sbg:fileTypes": "TAR",
      "label": "bowtie_index_archive_transcriptome"
    },
    {
      "label": "bowtie_index_archive_ribosomal",
      "id": "#bowtie_index_archive_ribosomal",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:includeInPorts": true,
      "sbg:x": 590.0000438557743,
      "sbg:y": -336.6666896873056
    },
    {
      "sbg:toolDefaultValue": "25",
      "description": "5' and 3' flank length to use in SPACHETE, defaults to 25.",
      "id": "#flank_len_end",
      "sbg:category": "Input",
      "sbg:suggestedValue": 25,
      "type": [
        "null",
        "int"
      ],
      "label": "Flank length"
    },
    {
      "id": "#threshold_junction_overlap",
      "sbg:suggestedValue": 70,
      "type": [
        "null",
        "int"
      ],
      "sbg:stageInput": null
    },
    {
      "id": "#lower_junction_overlap",
      "sbg:suggestedValue": 8,
      "type": [
        "null",
        "int"
      ],
      "sbg:stageInput": null
    },
    {
      "id": "#higher_junction_overlap",
      "sbg:suggestedValue": 10,
      "type": [
        "null",
        "int"
      ],
      "sbg:stageInput": null
    },
    {
      "id": "#number_of_bases",
      "type": [
        "null",
        "int"
      ],
      "sbg:stageInput": null,
      "sbg:suggestedValue": 20
    },
    {
      "sbg:altPrefix": "--splice_flank_len",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "150",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "prefix": "-sfl",
        "separate": true
      },
      "id": "#splice_flank_len",
      "label": "Splice flank len",
      "sbg:stageInput": null,
      "description": "Flanking length on either side of the junction",
      "sbg:suggestedValue": 150
    },
    {
      "sbg:altPrefix": "--splice_finding_flank",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "30",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "prefix": "-sff",
        "separate": true
      },
      "id": "#splice_finding_flank",
      "label": "Splice finding flank",
      "sbg:stageInput": null,
      "description": "how long to make the pieces in splice site identification",
      "sbg:suggestedValue": 30
    },
    {
      "sbg:altPrefix": "--number_of_cpus",
      "id": "#number_of_cpus",
      "type": [
        "null",
        "int"
      ],
      "inputBinding": {
        "sbg:cmdInclude": true,
        "prefix": "-cpu",
        "separate": true
      },
      "sbg:stageInput": null,
      "sbg:suggestedValue": 30
    },
    {
      "sbg:altPrefix": "--min_bases_per_col",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "2",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "prefix": "-mbpc",
        "separate": true
      },
      "id": "#min_bases_per_col",
      "label": "Min bases per col",
      "sbg:stageInput": null,
      "description": "Only consider column if it has at least n bases.",
      "sbg:suggestedValue": 1
    },
    {
      "sbg:altPrefix": "--group_member_cutoff",
      "sbg:toolDefaultValue": "1",
      "label": "Group member cutoff",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "prefix": "-gmc",
        "separate": true
      },
      "id": "#group_member_cutoff",
      "type": [
        "null",
        "int"
      ],
      "description": "Minimum number of reads that need to map to a bin pair.",
      "sbg:suggestedValue": 1
    },
    {
      "sbg:altPrefix": "--fusion_max_gap",
      "type": [
        "null",
        "string"
      ],
      "sbg:toolDefaultValue": "0",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "prefix": "-fmg",
        "separate": true
      },
      "id": "#fusion_max_gap",
      "label": "Fusion max gap",
      "sbg:stageInput": null,
      "description": "Size of splice site gap to allow for fusions.",
      "sbg:suggestedValue": "0"
    },
    {
      "sbg:altPrefix": "--flank_len",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "25",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "prefix": "-fl",
        "separate": true
      },
      "id": "#flank_len",
      "label": "Flank len",
      "sbg:stageInput": null,
      "description": "Flank len.",
      "sbg:suggestedValue": 30
    },
    {
      "sbg:altPrefix": "--consensus_score_cutoff",
      "type": [
        "null",
        "float"
      ],
      "sbg:toolDefaultValue": "0.5",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "prefix": "-csc",
        "separate": true
      },
      "id": "#consensus_score_cutoff",
      "label": "Consensus score cutoff",
      "sbg:stageInput": null,
      "description": "elates to the number of mismatches in consensus.",
      "sbg:suggestedValue": 0.5
    },
    {
      "sbg:altPrefix": "--at_boundary_cutoff",
      "type": [
        "null",
        "int"
      ],
      "sbg:toolDefaultValue": "2",
      "inputBinding": {
        "sbg:cmdInclude": true,
        "prefix": "-abc",
        "separate": true
      },
      "id": "#at_boundary_cutoff",
      "label": "At boundary cutoff",
      "sbg:stageInput": null,
      "description": "At boundary cutoff.",
      "sbg:suggestedValue": 5
    },
    {
      "id": "#collapse_threshold",
      "type": [
        "null",
        "int"
      ],
      "sbg:stageInput": null,
      "sbg:suggestedValue": 5
    }
  ],
  "outputs": [
    {
      "sbg:x": 6660.334246251348,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#naive_report_Appended",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -106.66668094529092,
      "label": "SPORK_naive_report_Appended",
      "source": [
        "#AppendedReportSPORK.naive_report_Appended"
      ]
    },
    {
      "sbg:x": 6562.451099506389,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_fusion_w_anomaly_and_indel_juncp_out_lef_join",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -292.94120267793323,
      "label": "SPORK_fusion_w_anomaly_and_indel_juncp_out_lef_join",
      "source": [
        "#SPORK_GLM_script_UseIndel.fusion_w_anomaly_and_indel_juncp_out_lef_join"
      ]
    },
    {
      "sbg:x": 4299.901702731249,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#naive_report",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -401.17646857803896,
      "label": "SPORK_naive_report",
      "source": [
        "#SPORK_FarJuncNaiveReport.naive_report"
      ]
    },
    {
      "sbg:x": 4274.117855586811,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_fusion_classIDs",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 249.411752819602,
      "label": "SPORK_fusion_classIDs",
      "source": [
        "#SPORK_FarJuncNaiveReport.IDs"
      ]
    },
    {
      "sbg:x": 5520.588599466819,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#indels_txt",
      "type": [
        "null",
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:y": -300.19608003017936,
      "label": "SPORK_indels",
      "source": [
        "#SPORK_MakeIndelsHisto.indels_txt"
      ]
    },
    {
      "sbg:x": 4701.176661217504,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_Scrambled_PE",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 180.0000176479251,
      "sbg:fileTypes": "SAM",
      "label": "SPORK_Scrambled_PE",
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_PE.result_sam_file"
      ]
    },
    {
      "sbg:x": 4695.29402045807,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_Regular_PE",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 18.823532282687452,
      "sbg:fileTypes": "SAM",
      "label": "SPORK_Regular_PE",
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_PE.result_sam_file"
      ]
    },
    {
      "sbg:x": 4705.882368912743,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_Transcriptome_PE",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -202.3529395133151,
      "sbg:fileTypes": "SAM",
      "label": "SPORK_Transcriptome_PE",
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_PE.result_sam_file"
      ]
    },
    {
      "sbg:x": 4697.6471044217,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_Genome_PE",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -354.1176591166989,
      "sbg:fileTypes": "SAM",
      "label": "SPORK_Genome_PE",
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_PE.result_sam_file"
      ]
    },
    {
      "sbg:x": 4385.882447239437,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_Regular_FJ",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 25.882362042331597,
      "sbg:fileTypes": "SAM",
      "label": "SPORK_Regular_FJ",
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_Regular_FJ.result_sam_file"
      ]
    },
    {
      "sbg:x": 4396.470460858718,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_Transcriptome_FJ",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -214.11763811606392,
      "sbg:fileTypes": "SAM",
      "label": "SPORK_Transcriptome_FJ",
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_Transcriptome_FJ.result_sam_file"
      ]
    },
    {
      "sbg:x": 4395.293933155619,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_Genome_FJ",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -322.35295127419874,
      "sbg:fileTypes": "SAM",
      "label": "SPORK_Genome_FJ",
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_Genome_FJ.result_sam_file"
      ]
    },
    {
      "sbg:x": 2930.0000435246347,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#SPORK_novel_fusions",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -436.66668693224614,
      "label": "SPORK_novel_fusions",
      "source": [
        "#SPORK_BadFJ3.novel_fusions"
      ]
    },
    {
      "sbg:x": 6018.333728088282,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#output_FJIndels",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 293.33336526817845,
      "label": "output_FJIndels",
      "source": [
        "#SPORK_FJIndels_ClassIDFile.output_FJIndels"
      ]
    },
    {
      "sbg:x": 6260.000576125267,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#output_RegIndel",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 355.0000055631004,
      "label": "output_RegIndel",
      "source": [
        "#MACHETE_RegIndels_ClassIDFile.output_RegIndel"
      ]
    },
    {
      "sbg:x": 3108.3332250912904,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#seq_duplicates",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -358.33332762453233,
      "label": "seq_duplicates",
      "source": [
        "#SPORK_BadFJ3.seq_duplicates"
      ]
    },
    {
      "label": "SPORK_naive_report_Appended_With_Building_Reads",
      "id": "#SPORK_naive_report_Appended_With_Building_Reads",
      "type": [
        "null",
        "File"
      ],
      "sbg:includeInPorts": true,
      "sbg:x": 6680.000110493763,
      "sbg:y": 88.33333175712147,
      "required": false,
      "source": [
        "#AppendedReportSPORK_With_Building_Reads.naive_report_Appended"
      ]
    },
    {
      "label": "SPORK_Scrambled_FJ",
      "id": "#SPORK_Scrambled_FJ",
      "type": [
        "null",
        "File"
      ],
      "sbg:fileTypes": "SAM",
      "sbg:includeInPorts": true,
      "sbg:x": 4403.333839919848,
      "sbg:y": 160.00002341800314,
      "required": false,
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_Scrambled_FJ.result_sam_file"
      ]
    },
    {
      "label": "SPORK_5prime",
      "id": "#SPORK_5prime",
      "type": [
        "null",
        "File"
      ],
      "sbg:fileTypes": "SAM",
      "sbg:includeInPorts": true,
      "sbg:x": 4125.000334554257,
      "sbg:y": -663.3334029648059,
      "required": false,
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_5prime.result_sam_file"
      ]
    },
    {
      "label": "SPORK_3prime",
      "id": "#SPORK_3prime",
      "type": [
        "null",
        "File"
      ],
      "sbg:fileTypes": "SAM",
      "sbg:includeInPorts": true,
      "sbg:x": 4126.667158749384,
      "sbg:y": -418.3334003554473,
      "required": false,
      "source": [
        "#Bowtie2_2_3_4_1_Aligner_Input_List_3prime.result_sam_file"
      ]
    },
    {
      "label": "KNIFE_linear_junc_probs",
      "id": "#KNIFE_linear_junc_probs",
      "type": [
        "null",
        "File"
      ],
      "sbg:fileTypes": "TXT",
      "sbg:includeInPorts": true,
      "sbg:x": 1415.000056227049,
      "sbg:y": -261.6666556464298,
      "required": false,
      "source": [
        "#KNIFE_GLM_model.linear_junc_probs"
      ]
    },
    {
      "label": "KNIFE_circ_junc_probs",
      "id": "#KNIFE_circ_junc_probs",
      "type": [
        "null",
        "File"
      ],
      "sbg:fileTypes": "TXT",
      "sbg:includeInPorts": true,
      "sbg:x": 1411.6666030089018,
      "sbg:y": -31.66663830810046,
      "required": false,
      "source": [
        "#KNIFE_GLM_model.circ_junc_probs"
      ]
    }
  ],
  "sbg:canvas_x": -264,
  "sbg:canvas_y": 379,
  "sbg:revisionsInfo": [
    {
      "sbg:revision": 0,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1561132710,
      "sbg:revisionNotes": null
    },
    {
      "sbg:revision": 1,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1561133031,
      "sbg:revisionNotes": "SPORK Without KNIFE Fusions ONLY SCG rev 75 copied"
    },
    {
      "sbg:revision": 2,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1561147600,
      "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner Input List instead of Bowtie2-2.3.4.1 Aligner"
    },
    {
      "sbg:revision": 3,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1561455490,
      "sbg:revisionNotes": "Genome, Regular, Scrambled indices - list; RegIndels output file connected to MACHETE RegIndels_ClassIDFile"
    },
    {
      "sbg:revision": 4,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1561586849,
      "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner Input List: reference_genome metadata fixed"
    },
    {
      "sbg:revision": 5,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1561587744,
      "sbg:revisionNotes": "SPORK Create Junctions: Distance problem fixed"
    },
    {
      "sbg:revision": 6,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1561618032,
      "sbg:revisionNotes": "Bowtie2_2_3_4_1_Aligner_Input_List_Consensus scatter input"
    },
    {
      "sbg:revision": 7,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1561754865,
      "sbg:revisionNotes": "Bowtie2_2_3_4_1_Aligner_Input_List_5prime and Bowtie2_2_3_4_1_Aligner_Input_List_3prime instead of Bowtie2_2_3_4_1_Aligner_5prime and Bowtie2_2_3_4_1_Aligner_3prime"
    },
    {
      "sbg:revision": 8,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1561797560,
      "sbg:revisionNotes": "Bowtie2-2.3.4.1 Aligner FJ Indels R2 scatter index input"
    },
    {
      "sbg:revision": 9,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1562427194,
      "sbg:revisionNotes": "allow within gene splicing as well"
    },
    {
      "sbg:revision": 10,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1563310000,
      "sbg:revisionNotes": "SPORK_concatenate: protect _don.fasta and _acc.fasta to have empty reads"
    },
    {
      "sbg:revision": 11,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1566584272,
      "sbg:revisionNotes": "Scrambled_PE added to AppendedReports"
    },
    {
      "sbg:revision": 12,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1566589926,
      "sbg:revisionNotes": "KNIFE part added"
    },
    {
      "sbg:revision": 13,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1566717424,
      "sbg:revisionNotes": "bowtie_index_archive_ribosomal and bowtie_index_archive_genome fixed"
    },
    {
      "sbg:revision": 14,
      "sbg:modifiedBy": "jordanski.milos",
      "sbg:modifiedOn": 1566732839,
      "sbg:revisionNotes": "Knife_Preprocess_Aligned_Reads_2 and Knife_Preprocess_Aligned_Reads_3 fixed"
    }
  ],
  "sbg:projectName": "SPACHETE Salzman Collaboration ",
  "sbg:image_url": "https://cgc.sbgenomics.com/ns/brood/images/milos_jordanski/spachete-salzman-collaboration/spork-without-knife-fusions-only-sherlock/14.png",
  "sbg:canvas_zoom": 0.5999999999999996,
  "sbg:appVersion": [
    "sbg:draft-2"
  ],
  "sbg:id": "milos_jordanski/spachete-salzman-collaboration/spork-without-knife-fusions-only-sherlock/14",
  "sbg:revision": 14,
  "sbg:revisionNotes": "Knife_Preprocess_Aligned_Reads_2 and Knife_Preprocess_Aligned_Reads_3 fixed",
  "sbg:modifiedOn": 1566732839,
  "sbg:modifiedBy": "jordanski.milos",
  "sbg:createdOn": 1561132710,
  "sbg:createdBy": "jordanski.milos",
  "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
  "sbg:sbgMaintained": false,
  "sbg:validationErrors": [],
  "sbg:contributors": [
    "jordanski.milos"
  ],
  "sbg:latestRevision": 14,
  "sbg:publisher": "sbg",
  "sbg:content_hash": "a517c942ddf3d00742f3c57b0d066b1fdd8d7b431bd15ebbde1760a1a659d569d",
  "id": "milos_jordanski/spachete-salzman-collaboration/spork-without-knife-fusions-only-sherlock/14",
  "label": "SPORK Without KNIFE Fusions ONLY SHERLOCK",
  "description": "",
  "hints": [
    {
      "value": "r3.8xlarge",
      "class": "sbg:AWSInstanceType"
    }
  ]
}